Coverage Report by file with details

=================================================================================
=== File: ../modules/dut/pixelCord.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           97        22        75      22.6

================================Statement Details================================

Statement Coverage for file ../modules/dut/pixelCord.vhd --

    1                                                
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                
    8                                                entity pixelCord is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   iRed           : in std_logic_vector(7 downto 0);
    12                                                   iGreen         : in std_logic_vector(7 downto 0);
    13                                                   iBlue          : in std_logic_vector(7 downto 0);
    14                                                   iValid         : in std_logic;
    15                                                   iPixelEn       : in std_logic;
    16                                                   iEof           : in std_logic;
    17                                                   iX             : in integer;
    18                                                   iY             : in integer;
    19                                                   oRed           : out std_logic_vector(7 downto 0);
    20                                                   oGreen         : out std_logic_vector(7 downto 0);
    21                                                   oBlue          : out std_logic_vector(7 downto 0);
    22                                                   oValid         : out std_logic);
    23                                               end entity;
    24                                               architecture rtl of pixelCord is
    25                                                   signal iCord           : cord;
    26                                                   signal oRgb            : channel;
    27                                                   signal iRgb            : channel;
    28                                                   signal frameSize       : intersectPoint;
    29                                                   signal initCord        : intersectPoint;
    30                                                   signal newCord         : intersectPoint;
    31                                                   signal grid1Cord       : intersectPoint;
    32                                                   signal grid2Cord       : intersectPoint;
    33                                                   signal grid3Cord       : intersectPoint;
    34                                                   signal grid4Cord       : intersectPoint;
    35                                                   signal rgb             : channel;
    36                                               begin
    37              1                          1         iCord.x         <= iX;
    38              1                          1         iCord.y         <= iY;
    39                                                   
    40              1                          1         iRgb.red         <= iRed;
    41              1                          1         iRgb.green       <= iGreen;
    42              1                          1         iRgb.blue        <= iBlue;
    43              1                          1         iRgb.valid       <= iValid;
    44                                                   
    45              1                          1         oRed             <= oRgb.red;
    46              1                          1         oGreen           <= oRgb.green;
    47              1                          1         oBlue            <= oRgb.blue;
    48              1                          2         oValid           <= oRgb.valid;
    49                                                   
    50                                                   
    51              1                          1         initCord.rht   <= initCordValueRht;
    52              1                          1         initCord.lft   <= initCordValueLft;
    53              1                          1         initCord.top   <= initCordValueTop;
    54              1                          1         initCord.bot   <= initCordValueBot;
    55              1                          1         frameSize.lft  <= frameSizeLft;
    56              1                          1         frameSize.rht  <= frameSizeRht;
    57              1                          1         frameSize.top  <= frameSizeTop;
    58              1                          1         frameSize.bot  <= frameSizeBot;
    59                                               dataOutP: process (clk)begin
    60                                                   if rising_edge(clk) then
    61              1                          1             oRgb.valid  <= iRgb.valid;
    62              1                          1             oRgb.red    <= rgb.red;
    63              1                          1             oRgb.green  <= rgb.green;
    64              1                          1             oRgb.blue   <= rgb.blue;
    65                                                   end if;
    66                                               end process dataOutP;
    67                                               pixelCordP: process (clk)begin
    68                                                   if rising_edge(clk) then
    69                                                       if (iRgb.valid = hi) then
    70                                                           ------------------------------------
    71                                                           if (iPixelEn = hi) then 
    72                                                               ------------------------------------
    73                                                               --Left Coordinates
    74                                                               ------------------------------------
    75                                                               if (iCord.x <= newCord.lft) then
    76                                                                   if ( iCord.x >= frameSize.lft) then 
    77              1                    ***0***                             newCord.lft <= iCord.x - 1;
    78                                                                   end if;   
    79                                                               end if;
    80                                                               ------------------------------------
    81                                                               --Right Coordinates
    82                                                               ------------------------------------
    83                                                               if (iCord.x >= newCord.rht) then
    84                                                                   if ( iCord.x <= frameSize.rht) then 
    85              1                    ***0***                             newCord.rht <= iCord.x + 1;
    86                                                                   end if;   
    87                                                               end if;
    88                                                               ------------------------------------
    89                                                               --Top Coordinates
    90                                                               ------------------------------------
    91                                                               if (iCord.y <= newCord.top) then
    92                                                                   if ( iCord.y >= frameSize.top) then 
    93              1                    ***0***                             newCord.top <= iCord.y - 1;
    94                                                                   end if;   
    95                                                               end if;
    96                                                               ------------------------------------
    97                                                               --Bottom Coordinates
    98                                                               ------------------------------------
    99                                                               if (iCord.y >= newCord.bot) then
    100                                                                  if ( iCord.y <= frameSize.bot) then 
    101             1                    ***0***                             newCord.bot <= iCord.y + 1;
    102                                                                  end if;   
    103                                                              end if;
    104                                                          end if;--iPixelEn
    105                                                          ------------------------------------
    106                                                          -- 4TH FRAME
    107                                                          ------------------------------------
    108                                                          if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    109             1                    ***0***                     rgb.red        <= white;
    110             1                    ***0***                     rgb.green      <= black;
    111             1                    ***0***                     rgb.blue       <= black;
    112                                                          elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    113             1                    ***0***                     rgb.red        <= white;
    114             1                    ***0***                     rgb.green      <= black;
    115             1                    ***0***                     rgb.blue       <= black;
    116                                                          elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    117             1                    ***0***                     rgb.red        <= white;
    118             1                    ***0***                     rgb.green      <= black;
    119             1                    ***0***                     rgb.blue       <= black;
    120                                                          elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    121             1                    ***0***                     rgb.red        <= white;
    122             1                    ***0***                     rgb.green      <= black;
    123             1                    ***0***                     rgb.blue       <= black;
    124                                                          ------------------------------------
    125                                                         -- 3RD FRAME
    126                                                          ------------------------------------
    127                                                          elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    128             1                    ***0***                     rgb.red        <= black;
    129             1                    ***0***                     rgb.green      <= white;
    130             1                    ***0***                     rgb.blue       <= black;
    131                                                          elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    132             1                    ***0***                     rgb.red        <= black;
    133             1                    ***0***                     rgb.green      <= white;
    134             1                    ***0***                     rgb.blue       <= black;
    135                                                          elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    136             1                    ***0***                     rgb.red        <= black;
    137             1                    ***0***                     rgb.green      <= white;
    138             1                    ***0***                     rgb.blue       <= black;
    139                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    140             1                    ***0***                     rgb.red        <= black;
    141             1                    ***0***                     rgb.green      <= white;
    142             1                    ***0***                     rgb.blue       <= black;
    143                                                          ------------------------------------
    144                                                          -- 2ND FRAME
    145                                                          ------------------------------------
    146                                                          elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    147             1                    ***0***                     rgb.red        <= black;
    148             1                    ***0***                     rgb.green      <= black;
    149             1                    ***0***                     rgb.blue       <= white;
    150                                                          elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    151             1                    ***0***                     rgb.red        <= black;
    152             1                    ***0***                     rgb.green      <= black;
    153             1                    ***0***                     rgb.blue       <= white;
    154                                                          elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    155             1                    ***0***                     rgb.red        <= black;
    156             1                    ***0***                     rgb.green      <= black;
    157             1                    ***0***                     rgb.blue       <= white;
    158                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    159             1                    ***0***                     rgb.red        <= black;
    160             1                    ***0***                     rgb.green      <= black;
    161             1                    ***0***                     rgb.blue       <= white;
    162                                                          ------------------------------------
    163                                                          -- 1ST FRAME
    164                                                          ------------------------------------
    165                                                          elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    166             1                    ***0***                     rgb.red        <= x"80";
    167             1                    ***0***                     rgb.green      <= black;
    168             1                    ***0***                     rgb.blue       <= x"80";
    169                                                          elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    170             1                    ***0***                     rgb.red        <= x"80";
    171             1                    ***0***                     rgb.green      <= black;
    172             1                    ***0***                     rgb.blue       <= x"80";
    173                                                          elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    174             1                    ***0***                     rgb.red        <= x"80";
    175             1                    ***0***                     rgb.green      <= black;
    176             1                    ***0***                     rgb.blue       <= x"80";
    177                                                          elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    178             1                    ***0***                     rgb.red        <= x"80";
    179             1                    ***0***                     rgb.green      <= black;
    180             1                    ***0***                     rgb.blue       <= x"80";
    181                                                          else
    182             1                    ***0***                     rgb.red        <= iRgb.red;
    183             1                    ***0***                     rgb.green      <= iRgb.green;
    184             1                    ***0***                     rgb.blue       <= iRgb.blue;
    185                                                          end if;
    186                                                      end if;--iRgb.valid
    187                                                      if (iEof = hi)then
    188                                                          --RESET COORDINATES TO DEFAULT
    189             1                    ***0***                 newCord.lft       <= initCord.lft;
    190             1                    ***0***                 newCord.rht       <= initCord.rht;
    191             1                    ***0***                 newCord.top       <= initCord.top;
    192             1                    ***0***                 newCord.bot       <= initCord.bot;
    193                                                          -- 1ST FRAME
    194             1                    ***0***                 grid1Cord.lft     <= newCord.lft;
    195             1                    ***0***                 grid1Cord.rht     <= newCord.rht;
    196             1                    ***0***                 grid1Cord.top     <= newCord.top;
    197             1                    ***0***                 grid1Cord.bot     <= newCord.bot;
    198                                                          -- 2ND FRAME
    199             1                    ***0***                 grid2Cord.lft     <= grid1Cord.lft;
    200             1                    ***0***                 grid2Cord.rht     <= grid1Cord.rht;
    201             1                    ***0***                 grid2Cord.top     <= grid1Cord.top;
    202             1                    ***0***                 grid2Cord.bot     <= grid1Cord.bot;
    203                                                          -- 3RD FRAME
    204             1                    ***0***                 grid3Cord.lft     <= grid2Cord.lft;
    205             1                    ***0***                 grid3Cord.rht     <= grid2Cord.rht;
    206             1                    ***0***                 grid3Cord.top     <= grid2Cord.top;
    207             1                    ***0***                 grid3Cord.bot     <= grid2Cord.bot;
    208                                                          -- 4TH FRAME
    209             1                    ***0***                 grid4Cord.lft     <= grid3Cord.lft;
    210             1                    ***0***                 grid4Cord.rht     <= grid3Cord.rht;
    211             1                    ***0***                 grid4Cord.top     <= grid3Cord.top;
    212             1                    ***0***                 grid4Cord.bot     <= grid3Cord.bot;
    213                                                      end if;--iEof
    214                                                  end if;
    215                                              end process pixelCordP;
    216                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        41         4        37       9.7

================================Branch Details================================

Branch Coverage for file ../modules/dut/pixelCord.vhd --

------------------------------------IF Branch------------------------------------
    60                                         1     Count coming in to IF
    60              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    68                                         1     Count coming in to IF
    68              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         1     Count coming in to IF
    69              1                    ***0***             if (iRgb.valid = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    71                                   ***0***     Count coming in to IF
    71              1                    ***0***                 if (iPixelEn = hi) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    75                                   ***0***     Count coming in to IF
    75              1                    ***0***                     if (iCord.x <= newCord.lft) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***                         if ( iCord.x >= frameSize.lft) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    83                                   ***0***     Count coming in to IF
    83              1                    ***0***                     if (iCord.x >= newCord.rht) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    84                                   ***0***     Count coming in to IF
    84              1                    ***0***                         if ( iCord.x <= frameSize.rht) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    91                                   ***0***     Count coming in to IF
    91              1                    ***0***                     if (iCord.y <= newCord.top) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    92                                   ***0***     Count coming in to IF
    92              1                    ***0***                         if ( iCord.y >= frameSize.top) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    99                                   ***0***     Count coming in to IF
    99              1                    ***0***                     if (iCord.y >= newCord.bot) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    100                                  ***0***     Count coming in to IF
    100             1                    ***0***                         if ( iCord.y <= frameSize.bot) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    108                                  ***0***     Count coming in to IF
    108             1                    ***0***                 if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    112             1                    ***0***                 elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    116             1                    ***0***                 elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    120             1                    ***0***                 elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    127             1                    ***0***                 elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    131             1                    ***0***                 elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    135             1                    ***0***                 elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    139             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    146             1                    ***0***                 elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    150             1                    ***0***                 elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    154             1                    ***0***                 elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    158             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    165             1                    ***0***                 elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    169             1                    ***0***                 elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    173             1                    ***0***                 elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    177             1                    ***0***                 elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    181             1                    ***0***                 else
Branch totals: 0 hits of 17 branches = 0.0%

------------------------------------IF Branch------------------------------------
    187                                        1     Count coming in to IF
    187             1                    ***0***             if (iEof = hi)then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             48         0        48       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/pixelCord.vhd --

----------------Focused Condition View-------------------
Line       108 Item    1  ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.bot)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.bot) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       112 Item    1  ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.top)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.top) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       116 Item    1  ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.lft)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.lft) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       120 Item    1  ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.rht)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.rht) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       127 Item    1  ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.bot)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       131 Item    1  ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.top)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       135 Item    1  ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.lft)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.lft) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       139 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       146 Item    1  ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.bot)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       150 Item    1  ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.top)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       154 Item    1  ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid2Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid2Cord.lft)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid2Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid2Cord.lft) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       158 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       165 Item    1  ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.bot)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.bot) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       169 Item    1  ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.top)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.top) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       173 Item    1  ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.lft)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.lft) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)

----------------Focused Condition View-------------------
Line       177 Item    1  ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.rht)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.rht) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/template.v
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           24         8        16      33.3

================================Statement Details================================

Statement Coverage for file ../modules/dut/template.v --

    1                                                module template(input wire clk,
    2                                                		   input wire en_i,
    3                                                		   input wire ina,
    4                                                		   input wire inb,
    5                                                		   output reg en_o,
    6                                                		   output reg out);
    7                                                	integer counter, state;
    8                                                	reg[1:0] temp_a, temp_b;
    9                                                	reg[2:0] temp_out;
    10                                               	//Init
    11                                               	initial begin
    12              1                          1     		counter = 0;
    13              1                          1     		temp_a = 2'b00;
    14              1                          1     		temp_b = 2'b00;
    15              1                          1     		temp_out = 3'b000;
    16              1                          1     		out = 1;
    17              1                          1     		en_o <= 0;
    18              1                          1     		state = 0;
    19                                               	end
    20              1                       1131     	always@(posedge clk)
    21                                               	begin
    22                                               		//State 0: Wait for en_i
    23                                               		if(en_i==1'b1)
    24                                               		begin
    25              1                    ***0***     			state = 1;
    26                                               		end
    27                                               		case(state)
    28                                               			//State 1: Start reading inputs
    29                                               			1: begin
    30              1                    ***0***     				temp_a = temp_a << 1;
    31              1                    ***0***     				temp_a = temp_a | ina;
    32              1                    ***0***     				temp_b = temp_b << 1;
    33              1                    ***0***     				temp_b = temp_b | inb;
    34              1                    ***0***     				counter = counter + 1;
    35                                               				//After 2 bits, do the operation an move to the next state
    36                                               				if(counter==2) begin
    37              1                    ***0***     					temp_out = temp_a + temp_b;
    38              1                    ***0***     					state = 2;
    39                                               				end
    40                                               			end
    41                                               			//State 2: Enable en_o and sends result to the output
    42                                               			2: begin
    43              1                    ***0***     				out <= temp_out[2];
    44              1                    ***0***     				temp_out = temp_out << 1;
    45              1                    ***0***     				counter = counter + 1;
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
    48                                               				if(counter==6) begin
    49              1                    ***0***     					counter = 0;
    50              1                    ***0***     					out <= 1'b1;
    51              1                    ***0***     					state = 0;
    52                                               				end
    53                                               			end
    54                                               		endcase
    55                                               	end
    56                                               endmodule

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13         2        11      15.3

================================Branch Details================================

Branch Coverage for file ../modules/dut/template.v --

------------------------------------IF Branch------------------------------------
    23                                      1131     Count coming in to IF
    23              1                    ***0***     		if(en_i==1'b1)
                                            1131     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    27                                      1131     Count coming in to CASE
    29              1                    ***0***     			1: begin
    42              1                    ***0***     			2: begin
                                            1131     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    36                                   ***0***     Count coming in to IF
    36              1                    ***0***     				if(counter==2) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    46                                   ***0***     Count coming in to IF
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    47                                   ***0***     Count coming in to IF
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    48                                   ***0***     Count coming in to IF
    48              1                    ***0***     				if(counter==6) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                         0.0
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/template.v --

FSM_ID: state
    Current State Object : state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  29                 st0                   1
  42                 st1                   2
  25                 st2                   0
    Uncovered States :
    ------------------
                   State
                   -----
                     st0
                     st1
                     st2
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  38                   0          st0 -> st1          
  51                   1          st1 -> st2          
  25                   2          st1 -> st0          
  25                   3          st2 -> st0          


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

=================================================================================
=== File: ../modules/dut/vfpConfig.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                          492        95       397      19.3

================================Statement Details================================

Statement Coverage for file ../modules/dut/vfpConfig.vhd --

    1                                                --02072019 [02-07-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                
    8                                                entity vfpConfig is
    9                                                    port (
    10                                                       ACLK               : in std_logic;
    11                                                       ARESETN            : in std_logic;
    12                                                       AWADDR             : in std_logic_vector(7 downto 0);
    13                                                       AWPROT             : in std_logic_vector(2 downto 0);
    14                                                       AWVALID            : in std_logic;
    15                                                       AWREADY            : out std_logic;
    16                                                       WDATA              : in std_logic_vector(31 downto 0);
    17                                                       WSTRB              : in std_logic_vector(3 downto 0);
    18                                                       WVALID             : in std_logic;
    19                                                       WREADY             : out std_logic;
    20                                                       BRESP              : out std_logic_vector(1 downto 0);
    21                                                       BVALID             : out std_logic;
    22                                                       BREADY             : in std_logic;
    23                                                       ARADDR             : in std_logic_vector(7 downto 0);
    24                                                       ARPROT             : in std_logic_vector(2 downto 0);
    25                                                       ARVALID            : in std_logic;
    26                                                       ARREADY            : out std_logic;
    27                                                       RDATA              : out std_logic_vector(31 downto 0);
    28                                                       RRESP              : out std_logic_vector(1 downto 0);
    29                                                       RVALID             : out std_logic;
    30                                                       RREADY             : in std_logic);
    31                                               end vfpConfig;
    32                                               architecture arch_imp of vfpConfig is
    33                                                   constant C_DATA_WIDTH        : integer := 32;
    34                                                   constant C_ADDR_WIDTH        : integer := 8;
    35                                               	constant ADDR_LSB            : integer := (C_DATA_WIDTH/32)+ 1;
    36                                               	constant OPT_MEM_ADDR_BITS   : integer := 5;
    37                                               	signal axi_awaddr	         : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    38                                               	signal axi_awready	         : std_logic;
    39                                               	signal axi_wready	         : std_logic;
    40                                               	signal axi_bresp	         : std_logic_vector(1 downto 0);
    41                                               	signal axi_bvalid	         : std_logic;
    42                                               	signal axi_araddr	         : std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    43                                               	signal axi_arready	         : std_logic;
    44                                               	signal axi_rdata	         : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    45                                               	signal axi_rresp	         : std_logic_vector(1 downto 0);
    46                                               	signal axi_rvalid	         : std_logic;
    47                                                   signal slv_reg_rden          : std_logic;
    48                                                   signal slv_reg_wren          : std_logic;
    49                                                   signal reg_data_out          : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    50                                                   signal byte_index            : integer;
    51                                                   signal aw_en                 : std_logic;
    52                                                   signal localRegs             : mRegs;
    53                                                   signal wrRegsOut             : mRegs;
    54                                                   signal rdRegsIn              : mRegs;
    55                                                   
    56                                               begin
    57              1                          2         rdRegsIn            <= wrRegsOut;
    58              1                          2         AWREADY             <= axi_awready;
    59              1                          2         WREADY              <= axi_wready;
    60              1                          2         BRESP               <= axi_bresp;
    61              1                          2         BVALID              <= axi_bvalid;
    62              1                          2         ARREADY             <= axi_arready;
    63              1                          2         RDATA               <= axi_rdata;
    64              1                          2         RRESP               <= axi_rresp;
    65              1                          2         RVALID              <= axi_rvalid;
    66                                                   process (ACLK)
    67                                                   begin
    68                                                     if rising_edge(ACLK) then 
    69                                                       if ARESETN = '0' then
    70              1                          2               axi_awready <= '0';
    71              1                          2               aw_en <= '1';
    72                                                       else
    73                                                         if (axi_awready = '0' and AWVALID = '1' and WVALID = '1' and aw_en = '1') then
    74              1                    ***0***                 axi_awready <= '1';
    75                                                           elsif (BREADY = '1' and axi_bvalid = '1') then
    76              1                    ***0***                     aw_en <= '1';
    77              1                    ***0***                     axi_awready <= '0';
    78                                                         else
    79              1                          1                 axi_awready <= '0';
    80                                                         end if;
    81                                                       end if;
    82                                                     end if;
    83                                                   end process;
    84                                                   process (ACLK)
    85                                                   begin
    86                                                     if rising_edge(ACLK) then 
    87                                                       if ARESETN = '0' then
    88              1                          2               axi_awaddr <= (others => '0');
    89                                                       else
    90                                                         if (axi_awready = '0' and AWVALID = '1' and WVALID = '1' and aw_en = '1') then
    91              1                    ***0***                 axi_awaddr <= AWADDR;
    92                                                         end if;
    93                                                       end if;
    94                                                     end if;                   
    95                                                   end process; 
    96                                                   process (ACLK)
    97                                                   begin
    98                                                     if rising_edge(ACLK) then 
    99                                                       if ARESETN = '0' then
    100             1                          2               axi_wready <= '0';
    101                                                      else
    102                                                        if (axi_wready = '0' and WVALID = '1' and AWVALID = '1' and aw_en = '1') then
    103             1                    ***0***                   axi_wready <= '1';
    104                                                        else
    105             1                          1                 axi_wready <= '0';
    106                                                        end if;
    107                                                      end if;
    108                                                    end if;
    109                                                  end process; 
    110             1                          2         slv_reg_wren <= axi_wready and WVALID and axi_awready and AWVALID ;
    111                                              	process (ACLK)
    112                                              	variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0); 
    113                                              	begin
    114                                              	  if rising_edge(ACLK) then 
    115                                              	    if ARESETN = '0' then
    116             1                         99     	      localRegs.cfigReg0 <= (others => '0');
    117             1                         99     	      localRegs.cfigReg1 <= (others => '0');
    118             1                         99     	      localRegs.cfigReg2 <= (others => '0');
    119             1                         99     	      localRegs.cfigReg3 <= (others => '0');
    120             1                         99     	      localRegs.cfigReg4 <= (others => '0');
    121             1                         99     	      localRegs.cfigReg5 <= (others => '0');
    122             1                         99     	      localRegs.cfigReg6 <= (others => '0');
    123             1                         99     	      localRegs.cfigReg7 <= (others => '0');
    124             1                         99     	      localRegs.cfigReg8 <= (others => '0');
    125             1                         99     	      localRegs.cfigReg9 <= (others => '0');
    126             1                         99     	      localRegs.cfigReg10 <= (others => '0');
    127             1                         99     	      localRegs.cfigReg11 <= (others => '0');
    128             1                         99     	      localRegs.cfigReg12 <= (others => '0');
    129             1                         99     	      localRegs.cfigReg13 <= (others => '0');
    130             1                         99     	      localRegs.cfigReg14 <= (others => '0');
    131             1                         99     	      localRegs.cfigReg15 <= (others => '0');
    132             1                         99     	      localRegs.cfigReg16 <= (others => '0');
    133             1                         99     	      localRegs.cfigReg17 <= (others => '0');
    134             1                         99     	      localRegs.cfigReg18 <= (others => '0');
    135             1                         99     	      localRegs.cfigReg19 <= (others => '0');
    136             1                         99     	      localRegs.cfigReg20 <= (others => '0');
    137             1                         99     	      localRegs.cfigReg21 <= (others => '0');
    138             1                         99     	      localRegs.cfigReg22 <= (others => '0');
    139             1                         99     	      localRegs.cfigReg23 <= (others => '0');
    140             1                         99     	      localRegs.cfigReg24 <= (others => '0');
    141             1                         99     	      localRegs.cfigReg25 <= (others => '0');
    142             1                         99     	      localRegs.cfigReg26 <= (others => '0');
    143             1                         99     	      localRegs.cfigReg27 <= (others => '0');
    144             1                         99     	      localRegs.cfigReg28 <= (others => '0');
    145             1                         99     	      localRegs.cfigReg29 <= (others => '0');
    146             1                         99     	      localRegs.cfigReg30 <= (others => '0');
    147             1                         99     	      localRegs.cfigReg31 <= (others => '0');
    148             1                         99     	      localRegs.cfigReg32 <= (others => '0');
    149             1                         99     	      localRegs.cfigReg33 <= (others => '0');
    150             1                         99     	      localRegs.cfigReg34 <= (others => '0');
    151             1                         99     	      localRegs.cfigReg35 <= (others => '0');
    152             1                         99     	      localRegs.cfigReg36 <= (others => '0');
    153             1                         99     	      localRegs.cfigReg37 <= (others => '0');
    154             1                         99     	      localRegs.cfigReg38 <= (others => '0');
    155             1                         99     	      localRegs.cfigReg39 <= (others => '0');
    156             1                         99     	      localRegs.cfigReg40 <= (others => '0');
    157             1                         99     	      localRegs.cfigReg41 <= (others => '0');
    158             1                         99     	      localRegs.cfigReg42 <= (others => '0');
    159             1                         99     	      localRegs.cfigReg43 <= (others => '0');
    160             1                         99     	      localRegs.cfigReg44 <= (others => '0');
    161             1                         99     	      localRegs.cfigReg45 <= (others => '0');
    162             1                         99     	      localRegs.cfigReg46 <= (others => '0');
    163             1                         99     	      localRegs.cfigReg47 <= (others => '0');
    164             1                         99     	      localRegs.cfigReg48 <= (others => '0');
    165             1                         99     	      localRegs.cfigReg49 <= (others => '0');
    166             1                         99     	      localRegs.cfigReg50 <= (others => '0');
    167             1                         99     	      localRegs.cfigReg51 <= (others => '0');
    168             1                         99     	      localRegs.cfigReg52 <= (others => '0');
    169             1                         99     	      localRegs.cfigReg53 <= (others => '0');
    170             1                         99     	      localRegs.cfigReg54 <= (others => '0');
    171             1                         99     	      localRegs.cfigReg55 <= (others => '0');
    172             1                         99     	      localRegs.cfigReg56 <= (others => '0');
    173             1                         99     	      localRegs.cfigReg57 <= (others => '0');
    174             1                         99     	      localRegs.cfigReg58 <= (others => '0');
    175             1                         99     	      localRegs.cfigReg59 <= (others => '0');
    176             1                         99     	      localRegs.cfigReg60 <= (others => '0');
    177             1                         99     	      localRegs.cfigReg61 <= (others => '0');
    178             1                         99     	      localRegs.cfigReg62 <= (others => '0');
    179             1                         99     	      localRegs.cfigReg63 <= (others => '0');
    180                                              	    else
    181             1                       1032     	      loc_addr := axi_awaddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    182                                              	      if (slv_reg_wren = '1') then
    183                                              	        case loc_addr is
    184                                              	          when b"000000" =>
    185             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    185             2                    ***0***     
    186                                              	              if ( WSTRB(byte_index) = '1' ) then
    187             1                    ***0***     	                localRegs.cfigReg0(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    188                                              	              end if;
    189             1                    ***0***     	            end loop;
    190                                              	          when b"000001" =>
    191             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    191             2                    ***0***     
    192                                              	              if ( WSTRB(byte_index) = '1' ) then
    193             1                    ***0***     	                localRegs.cfigReg1(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    194                                              	              end if;
    195             1                    ***0***     	            end loop;
    196                                              	          when b"000010" =>
    197             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    197             2                    ***0***     
    198                                              	              if ( WSTRB(byte_index) = '1' ) then
    199             1                    ***0***     	                localRegs.cfigReg2(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    200                                              	              end if;
    201             1                    ***0***     	            end loop;
    202                                              	          when b"000011" =>
    203             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    203             2                    ***0***     
    204                                              	              if ( WSTRB(byte_index) = '1' ) then
    205             1                    ***0***     	                localRegs.cfigReg3(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    206                                              	              end if;
    207             1                    ***0***     	            end loop;
    208                                              	          when b"000100" =>
    209             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    209             2                    ***0***     
    210                                              	              if ( WSTRB(byte_index) = '1' ) then
    211             1                    ***0***     	                localRegs.cfigReg4(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    212                                              	              end if;
    213             1                    ***0***     	            end loop;
    214                                              	          when b"000101" =>
    215             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    215             2                    ***0***     
    216                                              	              if ( WSTRB(byte_index) = '1' ) then
    217             1                    ***0***     	                localRegs.cfigReg5(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    218                                              	              end if;
    219             1                    ***0***     	            end loop;
    220                                              	          when b"000110" =>
    221             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    221             2                    ***0***     
    222                                              	              if ( WSTRB(byte_index) = '1' ) then
    223             1                    ***0***     	                localRegs.cfigReg6(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    224                                              	              end if;
    225             1                    ***0***     	            end loop;
    226                                              	          when b"000111" =>
    227             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    227             2                    ***0***     
    228                                              	              if ( WSTRB(byte_index) = '1' ) then
    229             1                    ***0***     	                localRegs.cfigReg7(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    230                                              	              end if;
    231             1                    ***0***     	            end loop;
    232                                              	          when b"001000" =>
    233             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    233             2                    ***0***     
    234                                              	              if ( WSTRB(byte_index) = '1' ) then
    235             1                    ***0***     	                localRegs.cfigReg8(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    236                                              	              end if;
    237             1                    ***0***     	            end loop;
    238                                              	          when b"001001" =>
    239             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    239             2                    ***0***     
    240                                              	              if ( WSTRB(byte_index) = '1' ) then
    241             1                    ***0***     	                localRegs.cfigReg9(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    242                                              	              end if;
    243             1                    ***0***     	            end loop;
    244                                              	          when b"001010" =>
    245             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    245             2                    ***0***     
    246                                              	              if ( WSTRB(byte_index) = '1' ) then
    247             1                    ***0***     	                localRegs.cfigReg10(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    248                                              	              end if;
    249             1                    ***0***     	            end loop;
    250                                              	          when b"001011" =>
    251             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    251             2                    ***0***     
    252                                              	              if ( WSTRB(byte_index) = '1' ) then
    253             1                    ***0***     	                localRegs.cfigReg11(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    254                                              	              end if;
    255             1                    ***0***     	            end loop;
    256                                              	          when b"001100" =>
    257             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    257             2                    ***0***     
    258                                              	              if ( WSTRB(byte_index) = '1' ) then
    259             1                    ***0***     	                localRegs.cfigReg12(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    260                                              	              end if;
    261             1                    ***0***     	            end loop;
    262                                              	          when b"001101" =>
    263             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    263             2                    ***0***     
    264                                              	              if ( WSTRB(byte_index) = '1' ) then
    265             1                    ***0***     	                localRegs.cfigReg13(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    266                                              	              end if;
    267             1                    ***0***     	            end loop;
    268                                              	          when b"001110" =>
    269             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    269             2                    ***0***     
    270                                              	              if ( WSTRB(byte_index) = '1' ) then
    271             1                    ***0***     	                localRegs.cfigReg14(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    272                                              	              end if;
    273             1                    ***0***     	            end loop;
    274                                              	          when b"001111" =>
    275             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    275             2                    ***0***     
    276                                              	              if ( WSTRB(byte_index) = '1' ) then
    277             1                    ***0***     	                localRegs.cfigReg15(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    278                                              	              end if;
    279             1                    ***0***     	            end loop;
    280                                              	          when b"010000" =>
    281             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    281             2                    ***0***     
    282                                              	              if ( WSTRB(byte_index) = '1' ) then
    283             1                    ***0***     	                localRegs.cfigReg16(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    284                                              	              end if;
    285             1                    ***0***     	            end loop;
    286                                              	          when b"010001" =>
    287             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    287             2                    ***0***     
    288                                              	              if ( WSTRB(byte_index) = '1' ) then
    289             1                    ***0***     	                localRegs.cfigReg17(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    290                                              	              end if;
    291             1                    ***0***     	            end loop;
    292                                              	          when b"010010" =>
    293             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    293             2                    ***0***     
    294                                              	              if ( WSTRB(byte_index) = '1' ) then
    295             1                    ***0***     	                localRegs.cfigReg18(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    296                                              	              end if;
    297             1                    ***0***     	            end loop;
    298                                              	          when b"010011" =>
    299             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    299             2                    ***0***     
    300                                              	              if ( WSTRB(byte_index) = '1' ) then
    301             1                    ***0***     	                localRegs.cfigReg19(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    302                                              	              end if;
    303             1                    ***0***     	            end loop;
    304                                              	          when b"010100" =>
    305             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    305             2                    ***0***     
    306                                              	              if ( WSTRB(byte_index) = '1' ) then
    307             1                    ***0***     	                localRegs.cfigReg20(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    308                                              	              end if;
    309             1                    ***0***     	            end loop;
    310                                              	          when b"010101" =>
    311             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    311             2                    ***0***     
    312                                              	              if ( WSTRB(byte_index) = '1' ) then
    313             1                    ***0***     	                localRegs.cfigReg21(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    314                                              	              end if;
    315             1                    ***0***     	            end loop;
    316                                              	          when b"010110" =>
    317             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    317             2                    ***0***     
    318                                              	              if ( WSTRB(byte_index) = '1' ) then
    319             1                    ***0***     	                localRegs.cfigReg22(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    320                                              	              end if;
    321             1                    ***0***     	            end loop;
    322                                              	          when b"010111" =>
    323             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    323             2                    ***0***     
    324                                              	              if ( WSTRB(byte_index) = '1' ) then
    325             1                    ***0***     	                localRegs.cfigReg23(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    326                                              	              end if;
    327             1                    ***0***     	            end loop;
    328                                              	          when b"011000" =>
    329             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    329             2                    ***0***     
    330                                              	              if ( WSTRB(byte_index) = '1' ) then
    331             1                    ***0***     	                localRegs.cfigReg24(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    332                                              	              end if;
    333             1                    ***0***     	            end loop;
    334                                              	          when b"011001" =>
    335             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    335             2                    ***0***     
    336                                              	              if ( WSTRB(byte_index) = '1' ) then
    337             1                    ***0***     	                localRegs.cfigReg25(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    338                                              	              end if;
    339             1                    ***0***     	            end loop;
    340                                              	          when b"011010" =>
    341             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    341             2                    ***0***     
    342                                              	              if ( WSTRB(byte_index) = '1' ) then
    343             1                    ***0***     	                localRegs.cfigReg26(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    344                                              	              end if;
    345             1                    ***0***     	            end loop;
    346                                              	          when b"011011" =>
    347             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    347             2                    ***0***     
    348                                              	              if ( WSTRB(byte_index) = '1' ) then
    349             1                    ***0***     	                localRegs.cfigReg27(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    350                                              	              end if;
    351             1                    ***0***     	            end loop;
    352                                              	          when b"011100" =>
    353             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    353             2                    ***0***     
    354                                              	              if ( WSTRB(byte_index) = '1' ) then
    355             1                    ***0***     	                localRegs.cfigReg28(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    356                                              	              end if;
    357             1                    ***0***     	            end loop;
    358                                              	          when b"011101" =>
    359             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    359             2                    ***0***     
    360                                              	              if ( WSTRB(byte_index) = '1' ) then
    361             1                    ***0***     	                localRegs.cfigReg29(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    362                                              	              end if;
    363             1                    ***0***     	            end loop;
    364                                              	          when b"011110" =>
    365             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    365             2                    ***0***     
    366                                              	              if ( WSTRB(byte_index) = '1' ) then
    367             1                    ***0***     	                localRegs.cfigReg30(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    368                                              	              end if;
    369             1                    ***0***     	            end loop;
    370                                              	          when b"011111" =>
    371             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    371             2                    ***0***     
    372                                              	              if ( WSTRB(byte_index) = '1' ) then
    373             1                    ***0***     	                localRegs.cfigReg31(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    374                                              	              end if;
    375             1                    ***0***     	            end loop;
    376                                              	          when b"100000" =>
    377             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    377             2                    ***0***     
    378                                              	              if ( WSTRB(byte_index) = '1' ) then
    379             1                    ***0***     	                localRegs.cfigReg32(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    380                                              	              end if;
    381             1                    ***0***     	            end loop;
    382                                              	          when b"100001" =>
    383             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    383             2                    ***0***     
    384                                              	              if ( WSTRB(byte_index) = '1' ) then
    385             1                    ***0***     	                localRegs.cfigReg33(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    386                                              	              end if;
    387             1                    ***0***     	            end loop;
    388                                              	          when b"100010" =>
    389             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    389             2                    ***0***     
    390                                              	              if ( WSTRB(byte_index) = '1' ) then
    391             1                    ***0***     	                localRegs.cfigReg34(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    392                                              	              end if;
    393             1                    ***0***     	            end loop;
    394                                              	          when b"100011" =>
    395             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    395             2                    ***0***     
    396                                              	              if ( WSTRB(byte_index) = '1' ) then
    397             1                    ***0***     	                localRegs.cfigReg35(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    398                                              	              end if;
    399             1                    ***0***     	            end loop;
    400                                              	          when b"100100" =>
    401             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    401             2                    ***0***     
    402                                              	              if ( WSTRB(byte_index) = '1' ) then
    403             1                    ***0***     	                localRegs.cfigReg36(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    404                                              	              end if;
    405             1                    ***0***     	            end loop;
    406                                              	          when b"100101" =>
    407             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    407             2                    ***0***     
    408                                              	              if ( WSTRB(byte_index) = '1' ) then
    409             1                    ***0***     	                localRegs.cfigReg37(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    410                                              	              end if;
    411             1                    ***0***     	            end loop;
    412                                              	          when b"100110" =>
    413             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    413             2                    ***0***     
    414                                              	              if ( WSTRB(byte_index) = '1' ) then
    415             1                    ***0***     	                localRegs.cfigReg38(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    416                                              	              end if;
    417             1                    ***0***     	            end loop;
    418                                              	          when b"100111" =>
    419             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    419             2                    ***0***     
    420                                              	              if ( WSTRB(byte_index) = '1' ) then
    421             1                    ***0***     	                localRegs.cfigReg39(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    422                                              	              end if;
    423             1                    ***0***     	            end loop;
    424                                              	          when b"101000" =>
    425             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    425             2                    ***0***     
    426                                              	              if ( WSTRB(byte_index) = '1' ) then
    427             1                    ***0***     	                localRegs.cfigReg40(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    428                                              	              end if;
    429             1                    ***0***     	            end loop;
    430                                              	          when b"101001" =>
    431             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    431             2                    ***0***     
    432                                              	              if ( WSTRB(byte_index) = '1' ) then
    433             1                    ***0***     	                localRegs.cfigReg41(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    434                                              	              end if;
    435             1                    ***0***     	            end loop;
    436                                              	          when b"101010" =>
    437             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    437             2                    ***0***     
    438                                              	              if ( WSTRB(byte_index) = '1' ) then
    439             1                    ***0***     	                localRegs.cfigReg42(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    440                                              	              end if;
    441             1                    ***0***     	            end loop;
    442                                              	          when b"101011" =>
    443             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    443             2                    ***0***     
    444                                              	              if ( WSTRB(byte_index) = '1' ) then
    445             1                    ***0***     	                localRegs.cfigReg43(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    446                                              	              end if;
    447             1                    ***0***     	            end loop;
    448                                              	          when b"101100" =>
    449             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    449             2                    ***0***     
    450                                              	              if ( WSTRB(byte_index) = '1' ) then
    451             1                    ***0***     	                localRegs.cfigReg44(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    452                                              	              end if;
    453             1                    ***0***     	            end loop;
    454                                              	          when b"101101" =>
    455             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    455             2                    ***0***     
    456                                              	              if ( WSTRB(byte_index) = '1' ) then
    457             1                    ***0***     	                localRegs.cfigReg45(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    458                                              	              end if;
    459             1                    ***0***     	            end loop;
    460                                              	          when b"101110" =>
    461             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    461             2                    ***0***     
    462                                              	              if ( WSTRB(byte_index) = '1' ) then
    463             1                    ***0***     	                localRegs.cfigReg46(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    464                                              	              end if;
    465             1                    ***0***     	            end loop;
    466                                              	          when b"101111" =>
    467             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    467             2                    ***0***     
    468                                              	              if ( WSTRB(byte_index) = '1' ) then
    469             1                    ***0***     	                localRegs.cfigReg47(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    470                                              	              end if;
    471             1                    ***0***     	            end loop;
    472                                              	          when b"110000" =>
    473             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    473             2                    ***0***     
    474                                              	              if ( WSTRB(byte_index) = '1' ) then
    475             1                    ***0***     	                localRegs.cfigReg48(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    476                                              	              end if;
    477             1                    ***0***     	            end loop;
    478                                              	          when b"110001" =>
    479             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    479             2                    ***0***     
    480                                              	              if ( WSTRB(byte_index) = '1' ) then
    481             1                    ***0***     	                localRegs.cfigReg49(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    482                                              	              end if;
    483             1                    ***0***     	            end loop;
    484                                              	          when b"110010" =>
    485             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    485             2                    ***0***     
    486                                              	              if ( WSTRB(byte_index) = '1' ) then
    487             1                    ***0***     	                localRegs.cfigReg50(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    488                                              	              end if;
    489             1                    ***0***     	            end loop;
    490                                              	          when b"110011" =>
    491             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    491             2                    ***0***     
    492                                              	              if ( WSTRB(byte_index) = '1' ) then
    493             1                    ***0***     	                localRegs.cfigReg51(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    494                                              	              end if;
    495             1                    ***0***     	            end loop;
    496                                              	          when b"110100" =>
    497             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    497             2                    ***0***     
    498                                              	              if ( WSTRB(byte_index) = '1' ) then
    499             1                    ***0***     	                localRegs.cfigReg52(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    500                                              	              end if;
    501             1                    ***0***     	            end loop;
    502                                              	          when b"110101" =>
    503             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    503             2                    ***0***     
    504                                              	              if ( WSTRB(byte_index) = '1' ) then
    505             1                    ***0***     	                localRegs.cfigReg53(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    506                                              	              end if;
    507             1                    ***0***     	            end loop;
    508                                              	          when b"110110" =>
    509             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    509             2                    ***0***     
    510                                              	              if ( WSTRB(byte_index) = '1' ) then
    511             1                    ***0***     	                localRegs.cfigReg54(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    512                                              	              end if;
    513             1                    ***0***     	            end loop;
    514                                              	          when b"110111" =>
    515             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    515             2                    ***0***     
    516                                              	              if ( WSTRB(byte_index) = '1' ) then
    517             1                    ***0***     	                localRegs.cfigReg55(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    518                                              	              end if;
    519             1                    ***0***     	            end loop;
    520                                              	          when b"111000" =>
    521             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    521             2                    ***0***     
    522                                              	              if ( WSTRB(byte_index) = '1' ) then
    523             1                    ***0***     	                localRegs.cfigReg56(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    524                                              	              end if;
    525             1                    ***0***     	            end loop;
    526                                              	          when b"111001" =>
    527             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    527             2                    ***0***     
    528                                              	              if ( WSTRB(byte_index) = '1' ) then
    529             1                    ***0***     	                localRegs.cfigReg57(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    530                                              	              end if;
    531             1                    ***0***     	            end loop;
    532                                              	          when b"111010" =>
    533             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    533             2                    ***0***     
    534                                              	              if ( WSTRB(byte_index) = '1' ) then
    535             1                    ***0***     	                localRegs.cfigReg58(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    536                                              	              end if;
    537             1                    ***0***     	            end loop;
    538                                              	          when b"111011" =>
    539             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    539             2                    ***0***     
    540                                              	              if ( WSTRB(byte_index) = '1' ) then
    541             1                    ***0***     	                localRegs.cfigReg59(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    542                                              	              end if;
    543             1                    ***0***     	            end loop;
    544                                              	          when b"111100" =>
    545             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    545             2                    ***0***     
    546                                              	              if ( WSTRB(byte_index) = '1' ) then
    547             1                    ***0***     	                localRegs.cfigReg60(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    548                                              	              end if;
    549             1                    ***0***     	            end loop;
    550                                              	          when b"111101" =>
    551             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    551             2                    ***0***     
    552                                              	              if ( WSTRB(byte_index) = '1' ) then
    553             1                    ***0***     	                localRegs.cfigReg61(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    554                                              	              end if;
    555             1                    ***0***     	            end loop;
    556                                              	          when b"111110" =>
    557             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    557             2                    ***0***     
    558                                              	              if ( WSTRB(byte_index) = '1' ) then
    559             1                    ***0***     	                localRegs.cfigReg62(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    560                                              	              end if;
    561             1                    ***0***     	            end loop;
    562                                              	          when b"111111" =>
    563             1                    ***0***     	            for byte_index in 0 to (C_DATA_WIDTH/8-1) loop
    563             2                    ***0***     
    564                                              	              if ( WSTRB(byte_index) = '1' ) then
    565             1                    ***0***     	                localRegs.cfigReg63(byte_index*8+7 downto byte_index*8) <= WDATA(byte_index*8+7 downto byte_index*8);
    566                                              	              end if;
    567             1                    ***0***     	            end loop;
    568                                              	          when others =>
    569                                                              --stored cpu values
    570             1                    ***0***     	            localRegs.cfigReg0 <= localRegs.cfigReg0;
    571             1                    ***0***     	            localRegs.cfigReg1 <= localRegs.cfigReg1;
    572             1                    ***0***     	            localRegs.cfigReg2 <= localRegs.cfigReg2;
    573             1                    ***0***     	            localRegs.cfigReg3 <= localRegs.cfigReg3;
    574             1                    ***0***     	            localRegs.cfigReg4 <= localRegs.cfigReg4;
    575             1                    ***0***     	            localRegs.cfigReg5 <= localRegs.cfigReg5;
    576             1                    ***0***     	            localRegs.cfigReg6 <= localRegs.cfigReg6;
    577             1                    ***0***     	            localRegs.cfigReg7 <= localRegs.cfigReg7;
    578             1                    ***0***     	            localRegs.cfigReg8 <= localRegs.cfigReg8;
    579             1                    ***0***     	            localRegs.cfigReg9 <= localRegs.cfigReg9;
    580             1                    ***0***     	            localRegs.cfigReg10 <= localRegs.cfigReg10;
    581             1                    ***0***     	            localRegs.cfigReg11 <= localRegs.cfigReg11;
    582             1                    ***0***     	            localRegs.cfigReg12 <= localRegs.cfigReg12;
    583             1                    ***0***     	            localRegs.cfigReg13 <= localRegs.cfigReg13;
    584             1                    ***0***     	            localRegs.cfigReg14 <= localRegs.cfigReg14;
    585             1                    ***0***     	            localRegs.cfigReg15 <= localRegs.cfigReg15;
    586             1                    ***0***     	            localRegs.cfigReg16 <= localRegs.cfigReg16;
    587             1                    ***0***     	            localRegs.cfigReg17 <= localRegs.cfigReg17;
    588             1                    ***0***     	            localRegs.cfigReg18 <= localRegs.cfigReg18;
    589             1                    ***0***     	            localRegs.cfigReg19 <= localRegs.cfigReg19;
    590             1                    ***0***     	            localRegs.cfigReg20 <= localRegs.cfigReg20;
    591             1                    ***0***     	            localRegs.cfigReg21 <= localRegs.cfigReg21;
    592             1                    ***0***     	            localRegs.cfigReg22 <= localRegs.cfigReg22;
    593             1                    ***0***     	            localRegs.cfigReg23 <= localRegs.cfigReg23;
    594             1                    ***0***     	            localRegs.cfigReg24 <= localRegs.cfigReg24;
    595             1                    ***0***     	            localRegs.cfigReg25 <= localRegs.cfigReg25;
    596             1                    ***0***     	            localRegs.cfigReg26 <= localRegs.cfigReg26;
    597             1                    ***0***     	            localRegs.cfigReg27 <= localRegs.cfigReg27;
    598             1                    ***0***     	            localRegs.cfigReg28 <= localRegs.cfigReg28;
    599             1                    ***0***     	            localRegs.cfigReg29 <= localRegs.cfigReg29;
    600             1                    ***0***     	            localRegs.cfigReg30 <= localRegs.cfigReg30;
    601             1                    ***0***     	            localRegs.cfigReg31 <= localRegs.cfigReg31;
    602             1                    ***0***     	            localRegs.cfigReg32 <= localRegs.cfigReg32;
    603             1                    ***0***     	            localRegs.cfigReg33 <= localRegs.cfigReg33;
    604             1                    ***0***     	            localRegs.cfigReg34 <= localRegs.cfigReg34;
    605             1                    ***0***     	            localRegs.cfigReg35 <= localRegs.cfigReg35;
    606             1                    ***0***     	            localRegs.cfigReg36 <= localRegs.cfigReg36;
    607             1                    ***0***     	            localRegs.cfigReg37 <= localRegs.cfigReg37;
    608             1                    ***0***     	            localRegs.cfigReg38 <= localRegs.cfigReg38;
    609             1                    ***0***     	            localRegs.cfigReg39 <= localRegs.cfigReg39;
    610             1                    ***0***     	            localRegs.cfigReg40 <= localRegs.cfigReg40;
    611             1                    ***0***     	            localRegs.cfigReg41 <= localRegs.cfigReg41;
    612             1                    ***0***     	            localRegs.cfigReg42 <= localRegs.cfigReg42;
    613             1                    ***0***     	            localRegs.cfigReg43 <= localRegs.cfigReg43;
    614             1                    ***0***     	            localRegs.cfigReg44 <= localRegs.cfigReg44;
    615             1                    ***0***     	            localRegs.cfigReg45 <= localRegs.cfigReg45;
    616             1                    ***0***     	            localRegs.cfigReg46 <= localRegs.cfigReg46;
    617             1                    ***0***     	            localRegs.cfigReg47 <= localRegs.cfigReg47;
    618             1                    ***0***     	            localRegs.cfigReg48 <= localRegs.cfigReg48;
    619             1                    ***0***     	            localRegs.cfigReg49 <= localRegs.cfigReg49;
    620             1                    ***0***     	            localRegs.cfigReg50 <= localRegs.cfigReg50;
    621             1                    ***0***     	            localRegs.cfigReg51 <= localRegs.cfigReg51;
    622             1                    ***0***     	            localRegs.cfigReg52 <= localRegs.cfigReg52;
    623             1                    ***0***     	            localRegs.cfigReg53 <= localRegs.cfigReg53;
    624             1                    ***0***     	            localRegs.cfigReg54 <= localRegs.cfigReg54;
    625             1                    ***0***     	            localRegs.cfigReg55 <= localRegs.cfigReg55;
    626             1                    ***0***     	            localRegs.cfigReg56 <= localRegs.cfigReg56;
    627             1                    ***0***     	            localRegs.cfigReg57 <= localRegs.cfigReg57;
    628             1                    ***0***     	            localRegs.cfigReg58 <= localRegs.cfigReg58;
    629             1                    ***0***     	            localRegs.cfigReg59 <= localRegs.cfigReg59;
    630             1                    ***0***     	            localRegs.cfigReg60 <= localRegs.cfigReg60;
    631             1                    ***0***     	            localRegs.cfigReg61 <= localRegs.cfigReg61;
    632             1                    ***0***     	            localRegs.cfigReg62 <= localRegs.cfigReg62;
    633             1                    ***0***     	            localRegs.cfigReg63 <= localRegs.cfigReg63;
    634                                              	        end case;
    635                                              	      end if;
    636                                              	    end if;
    637                                              	  end if;                   
    638                                              	end process; 
    639                                                  process (ACLK)
    640                                                  begin
    641                                                    if rising_edge(ACLK) then 
    642                                                      if ARESETN = '0' then
    643             1                          2               axi_bvalid  <= '0';
    644             1                          2               axi_bresp   <= "00"; 
    645                                                      else
    646                                                        if (axi_awready = '1' and AWVALID = '1' and axi_wready = '1' and WVALID = '1' and axi_bvalid = '0'  ) then
    647             1                    ***0***                 axi_bvalid <= '1';
    648             1                    ***0***                 axi_bresp  <= "00"; 
    649                                                        elsif (BREADY = '1' and axi_bvalid = '1') then   
    650             1                    ***0***                 axi_bvalid <= '0';                                 
    651                                                        end if;
    652                                                      end if;
    653                                                    end if;                   
    654                                                  end process; 
    655                                                  process (ACLK)
    656                                                  begin
    657                                                    if rising_edge(ACLK) then 
    658                                                      if ARESETN = '0' then
    659             1                          2               axi_arready <= '0';
    660             1                          2               axi_araddr  <= (others => '1');
    661                                                      else
    662                                                        if (axi_arready = '0' and ARVALID = '1') then
    663             1                    ***0***                 axi_arready <= '1';
    664             1                    ***0***                 axi_araddr  <= ARADDR;           
    665                                                        else
    666             1                          1                 axi_arready <= '0';
    667                                                        end if;
    668                                                      end if;
    669                                                    end if;                   
    670                                                  end process; 
    671                                                  process (ACLK)
    672                                                  begin
    673                                                    if rising_edge(ACLK) then
    674                                                      if ARESETN = '0' then
    675             1                          2               axi_rvalid <= '0';
    676             1                          2               axi_rresp  <= "00";
    677                                                      else
    678                                                        if (axi_arready = '1' and ARVALID = '1' and axi_rvalid = '0') then
    679             1                    ***0***                 axi_rvalid <= '1';
    680             1                    ***0***                 axi_rresp  <= "00"; 
    681                                                        elsif (axi_rvalid = '1' and RREADY = '1') then
    682             1                    ***0***                 axi_rvalid <= '0';
    683                                                        end if;            
    684                                                      end if;
    685                                                    end if;
    686                                                  end process;
    687             1                          2         slv_reg_rden <= axi_arready and ARVALID and (not axi_rvalid);
    688             1                          6     process (axi_araddr, ARESETN, slv_reg_rden, rdRegsIn.cfigReg0, rdRegsIn.cfigReg1, rdRegsIn.cfigReg2, rdRegsIn.cfigReg3, rdRegsIn.cfigReg4, rdRegsIn.cfigReg5, rdRegsIn.cfigReg6, rdRegsIn.cfigReg7, rdRegsIn.cfigReg8, rdRegsIn.cfigReg9, rdRegsIn.cfigReg10, rdRegsIn.cfigReg11, rdRegsIn.cfigReg12, rdRegsIn.cfigReg13, rdRegsIn.cfigReg14, rdRegsIn.cfigReg15, rdRegsIn.cfigReg16, rdRegsIn.cfigReg17, rdRegsIn.cfigReg18, rdRegsIn.cfigReg19, rdRegsIn.cfigReg20, rdRegsIn.cfigReg21, rdRegsIn.cfigReg22, rdRegsIn.cfigReg23, rdRegsIn.cfigReg24, rdRegsIn.cfigReg25, rdRegsIn.cfigReg26, rdRegsIn.cfigReg27, rdRegsIn.cfigReg28, rdRegsIn.cfigReg29, rdRegsIn.cfigReg30, rdRegsIn.cfigReg31, rdRegsIn.cfigReg32, rdRegsIn.cfigReg33, rdRegsIn.cfigReg34, rdRegsIn.cfigReg35, rdRegsIn.cfigReg36, rdRegsIn.cfigReg37, rdRegsIn.cfigReg38, rdRegsIn.cfigReg39, rdRegsIn.cfigReg40, rdRegsIn.cfigReg41, rdRegsIn.cfigReg42, rdRegsIn.cfigReg43, rdRegsIn.cfigReg44, rdRegsIn.cfigReg45, rdRegsIn.cfigReg46, rdRegsIn.cfigReg47, rdRegsIn.cfigReg48, rdRegsIn.cfigReg49, rdRegsIn.cfigReg50, rdRegsIn.cfigReg51, rdRegsIn.cfigReg52, rdRegsIn.cfigReg53, rdRegsIn.cfigReg54, rdRegsIn.cfigReg55, rdRegsIn.cfigReg56, rdRegsIn.cfigReg57, rdRegsIn.cfigReg58, rdRegsIn.cfigReg59, rdRegsIn.cfigReg60, rdRegsIn.cfigReg61, rdRegsIn.cfigReg62, rdRegsIn.cfigReg63)
    689                                                  variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0);
    690                                                  begin
    691             1                          6             loc_addr := axi_araddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    692                                                      case loc_addr is
    693                                                        when b"000000" =>
    694             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg0;
    695                                                        when b"000001" =>
    696             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg1;
    697                                                        when b"000010" =>
    698             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg2;
    699                                                        when b"000011" =>
    700             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg3;
    701                                                        when b"000100" =>
    702             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg4;
    703                                                        when b"000101" =>
    704             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg5;
    705                                                        when b"000110" =>
    706             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg6;
    707                                                        when b"000111" =>
    708             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg7;
    709                                                        when b"001000" =>
    710             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg8;
    711                                                        when b"001001" =>
    712             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg9;
    713                                                        when b"001010" =>
    714             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg10;
    715                                                        when b"001011" =>
    716             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg11;
    717                                                        when b"001100" =>
    718             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg12;
    719                                                        when b"001101" =>
    720             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg13;
    721                                                        when b"001110" =>
    722             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg14;
    723                                                        when b"001111" =>
    724             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg15;
    725                                                        when b"010000" =>
    726             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg16;
    727                                                        when b"010001" =>
    728             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg17;
    729                                                        when b"010010" =>
    730             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg18;
    731                                                        when b"010011" =>
    732             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg19;
    733                                                        when b"010100" =>
    734             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg20;
    735                                                        when b"010101" =>
    736             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg21;
    737                                                        when b"010110" =>
    738             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg22;
    739                                                        when b"010111" =>
    740             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg23;
    741                                                        when b"011000" =>
    742             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg24;
    743                                                        when b"011001" =>
    744             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg25;
    745                                                        when b"011010" =>
    746             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg26;
    747                                                        when b"011011" =>
    748             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg27;
    749                                                        when b"011100" =>
    750             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg28;
    751                                                        when b"011101" =>
    752             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg29;
    753                                                        when b"011110" =>
    754             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg30;
    755                                                        when b"011111" =>
    756             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg31;
    757                                              	      when b"100000" =>
    758             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg32;
    759                                              	      when b"100001" =>
    760             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg33;
    761                                              	      when b"100010" =>
    762             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg34;
    763                                              	      when b"100011" =>
    764             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg35;
    765                                              	      when b"100100" =>
    766             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg36;
    767                                              	      when b"100101" =>
    768             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg37;
    769                                              	      when b"100110" =>
    770             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg38;
    771                                              	      when b"100111" =>
    772             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg39;
    773                                              	      when b"101000" =>
    774             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg40;
    775                                              	      when b"101001" =>
    776             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg41;
    777                                              	      when b"101010" =>
    778             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg42;
    779                                              	      when b"101011" =>
    780             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg43;
    781                                              	      when b"101100" =>
    782             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg44;
    783                                              	      when b"101101" =>
    784             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg45;
    785                                              	      when b"101110" =>
    786             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg46;
    787                                              	      when b"101111" =>
    788             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg47;
    789                                              	      when b"110000" =>
    790             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg48;
    791                                              	      when b"110001" =>
    792             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg49;
    793                                              	      when b"110010" =>
    794             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg50;
    795                                              	      when b"110011" =>
    796             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg51;
    797                                              	      when b"110100" =>
    798             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg52;
    799                                              	      when b"110101" =>
    800             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg53;
    801                                              	      when b"110110" =>
    802             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg54;
    803                                              	      when b"110111" =>
    804             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg55;
    805                                              	      when b"111000" =>
    806             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg56;
    807                                              	      when b"111001" =>
    808             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg57;
    809                                              	      when b"111010" =>
    810             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg58;
    811                                              	      when b"111011" =>
    812             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg59;
    813                                              	      when b"111100" =>
    814             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg60;
    815                                              	      when b"111101" =>
    816             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg61;
    817                                              	      when b"111110" =>
    818             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg62;
    819                                              	      when b"111111" =>
    820             1                          4     	        reg_data_out <= rdRegsIn.cfigReg63;
    821                                                        when others =>
    822             1                          2                 reg_data_out  <= (others => '0');
    823                                                      end case;
    824                                                  end process;
    825                                                  
    826                                                  process( ACLK ) begin
    827                                                    if (rising_edge (ACLK)) then
    828                                                      if ( ARESETN = '0' ) then
    829             1                          3               axi_rdata  <= (others => '0');
    830                                                      else
    831                                                        if (slv_reg_rden = '1') then
    832             1                    ***0***                   axi_rdata <= reg_data_out;     
    833                                                        end if;   
    834                                                      end if;
    835                                                    end if;
    836                                                  end process;
    837                                              
    838                                                  cpuOut: process (ACLK) begin
    839                                                      if (rising_edge (ACLK)) then
    840             1                       1131                 wrRegsOut <= localRegs;
    841                                                      end if;
    842                                                  end process cpuOut;
    843                                              
    844                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                       302        35       267      11.5

================================Branch Details================================

Branch Coverage for file ../modules/dut/vfpConfig.vhd --

------------------------------------IF Branch------------------------------------
    68                                         3     Count coming in to IF
    68              1                          3           if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         3     Count coming in to IF
    69              1                          2             if ARESETN = '0' then
    72              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    73                                         1     Count coming in to IF
    73              1                    ***0***               if (axi_awready = '0' and AWVALID = '1' and WVALID = '1' and aw_en = '1') then
    75              1                    ***0***                 elsif (BREADY = '1' and axi_bvalid = '1') then
    78              1                          1               else
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    86                                         3     Count coming in to IF
    86              1                          3           if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    87                                         3     Count coming in to IF
    87              1                          2             if ARESETN = '0' then
    89              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    90                                         1     Count coming in to IF
    90              1                    ***0***               if (axi_awready = '0' and AWVALID = '1' and WVALID = '1' and aw_en = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    98                                         3     Count coming in to IF
    98              1                          3           if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    99                                         3     Count coming in to IF
    99              1                          2             if ARESETN = '0' then
    101             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    102                                        1     Count coming in to IF
    102             1                    ***0***               if (axi_wready = '0' and WVALID = '1' and AWVALID = '1' and aw_en = '1') then
    104             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    114                                     1131     Count coming in to IF
    114             1                       1131     	  if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    115                                     1131     Count coming in to IF
    115             1                         99     	    if ARESETN = '0' then
    180             1                       1032     	    else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    182                                     1032     Count coming in to IF
    182             1                    ***0***     	      if (slv_reg_wren = '1') then
                                            1032     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    183                                  ***0***     Count coming in to CASE
    184             1                    ***0***     	          when b"000000" =>
    190             1                    ***0***     	          when b"000001" =>
    196             1                    ***0***     	          when b"000010" =>
    202             1                    ***0***     	          when b"000011" =>
    208             1                    ***0***     	          when b"000100" =>
    214             1                    ***0***     	          when b"000101" =>
    220             1                    ***0***     	          when b"000110" =>
    226             1                    ***0***     	          when b"000111" =>
    232             1                    ***0***     	          when b"001000" =>
    238             1                    ***0***     	          when b"001001" =>
    244             1                    ***0***     	          when b"001010" =>
    250             1                    ***0***     	          when b"001011" =>
    256             1                    ***0***     	          when b"001100" =>
    262             1                    ***0***     	          when b"001101" =>
    268             1                    ***0***     	          when b"001110" =>
    274             1                    ***0***     	          when b"001111" =>
    280             1                    ***0***     	          when b"010000" =>
    286             1                    ***0***     	          when b"010001" =>
    292             1                    ***0***     	          when b"010010" =>
    298             1                    ***0***     	          when b"010011" =>
    304             1                    ***0***     	          when b"010100" =>
    310             1                    ***0***     	          when b"010101" =>
    316             1                    ***0***     	          when b"010110" =>
    322             1                    ***0***     	          when b"010111" =>
    328             1                    ***0***     	          when b"011000" =>
    334             1                    ***0***     	          when b"011001" =>
    340             1                    ***0***     	          when b"011010" =>
    346             1                    ***0***     	          when b"011011" =>
    352             1                    ***0***     	          when b"011100" =>
    358             1                    ***0***     	          when b"011101" =>
    364             1                    ***0***     	          when b"011110" =>
    370             1                    ***0***     	          when b"011111" =>
    376             1                    ***0***     	          when b"100000" =>
    382             1                    ***0***     	          when b"100001" =>
    388             1                    ***0***     	          when b"100010" =>
    394             1                    ***0***     	          when b"100011" =>
    400             1                    ***0***     	          when b"100100" =>
    406             1                    ***0***     	          when b"100101" =>
    412             1                    ***0***     	          when b"100110" =>
    418             1                    ***0***     	          when b"100111" =>
    424             1                    ***0***     	          when b"101000" =>
    430             1                    ***0***     	          when b"101001" =>
    436             1                    ***0***     	          when b"101010" =>
    442             1                    ***0***     	          when b"101011" =>
    448             1                    ***0***     	          when b"101100" =>
    454             1                    ***0***     	          when b"101101" =>
    460             1                    ***0***     	          when b"101110" =>
    466             1                    ***0***     	          when b"101111" =>
    472             1                    ***0***     	          when b"110000" =>
    478             1                    ***0***     	          when b"110001" =>
    484             1                    ***0***     	          when b"110010" =>
    490             1                    ***0***     	          when b"110011" =>
    496             1                    ***0***     	          when b"110100" =>
    502             1                    ***0***     	          when b"110101" =>
    508             1                    ***0***     	          when b"110110" =>
    514             1                    ***0***     	          when b"110111" =>
    520             1                    ***0***     	          when b"111000" =>
    526             1                    ***0***     	          when b"111001" =>
    532             1                    ***0***     	          when b"111010" =>
    538             1                    ***0***     	          when b"111011" =>
    544             1                    ***0***     	          when b"111100" =>
    550             1                    ***0***     	          when b"111101" =>
    556             1                    ***0***     	          when b"111110" =>
    562             1                    ***0***     	          when b"111111" =>
    568             1                    ***0***     	          when others =>
Branch totals: 0 hits of 65 branches = 0.0%

------------------------------------IF Branch------------------------------------
    186                                  ***0***     Count coming in to IF
    186             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    192                                  ***0***     Count coming in to IF
    192             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    198                                  ***0***     Count coming in to IF
    198             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    204                                  ***0***     Count coming in to IF
    204             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    210                                  ***0***     Count coming in to IF
    210             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    216                                  ***0***     Count coming in to IF
    216             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    222                                  ***0***     Count coming in to IF
    222             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    228                                  ***0***     Count coming in to IF
    228             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    234                                  ***0***     Count coming in to IF
    234             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    240                                  ***0***     Count coming in to IF
    240             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    246                                  ***0***     Count coming in to IF
    246             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    252                                  ***0***     Count coming in to IF
    252             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    258                                  ***0***     Count coming in to IF
    258             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    264                                  ***0***     Count coming in to IF
    264             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    270                                  ***0***     Count coming in to IF
    270             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    276                                  ***0***     Count coming in to IF
    276             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    282                                  ***0***     Count coming in to IF
    282             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    288                                  ***0***     Count coming in to IF
    288             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    294                                  ***0***     Count coming in to IF
    294             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    300                                  ***0***     Count coming in to IF
    300             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    306                                  ***0***     Count coming in to IF
    306             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    312                                  ***0***     Count coming in to IF
    312             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    318                                  ***0***     Count coming in to IF
    318             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    324                                  ***0***     Count coming in to IF
    324             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    330                                  ***0***     Count coming in to IF
    330             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    336                                  ***0***     Count coming in to IF
    336             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    342                                  ***0***     Count coming in to IF
    342             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    348                                  ***0***     Count coming in to IF
    348             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    354                                  ***0***     Count coming in to IF
    354             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    360                                  ***0***     Count coming in to IF
    360             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    366                                  ***0***     Count coming in to IF
    366             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    372                                  ***0***     Count coming in to IF
    372             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    378                                  ***0***     Count coming in to IF
    378             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    384                                  ***0***     Count coming in to IF
    384             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    390                                  ***0***     Count coming in to IF
    390             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    396                                  ***0***     Count coming in to IF
    396             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    402                                  ***0***     Count coming in to IF
    402             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    408                                  ***0***     Count coming in to IF
    408             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    414                                  ***0***     Count coming in to IF
    414             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    420                                  ***0***     Count coming in to IF
    420             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    426                                  ***0***     Count coming in to IF
    426             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    432                                  ***0***     Count coming in to IF
    432             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    438                                  ***0***     Count coming in to IF
    438             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    444                                  ***0***     Count coming in to IF
    444             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    450                                  ***0***     Count coming in to IF
    450             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    456                                  ***0***     Count coming in to IF
    456             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    462                                  ***0***     Count coming in to IF
    462             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    468                                  ***0***     Count coming in to IF
    468             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    474                                  ***0***     Count coming in to IF
    474             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    480                                  ***0***     Count coming in to IF
    480             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    486                                  ***0***     Count coming in to IF
    486             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    492                                  ***0***     Count coming in to IF
    492             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    498                                  ***0***     Count coming in to IF
    498             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    504                                  ***0***     Count coming in to IF
    504             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    510                                  ***0***     Count coming in to IF
    510             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    516                                  ***0***     Count coming in to IF
    516             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    522                                  ***0***     Count coming in to IF
    522             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    528                                  ***0***     Count coming in to IF
    528             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    534                                  ***0***     Count coming in to IF
    534             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    540                                  ***0***     Count coming in to IF
    540             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    546                                  ***0***     Count coming in to IF
    546             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    552                                  ***0***     Count coming in to IF
    552             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    558                                  ***0***     Count coming in to IF
    558             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    564                                  ***0***     Count coming in to IF
    564             1                    ***0***     	              if ( WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    641                                        3     Count coming in to IF
    641             1                          3           if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    642                                        3     Count coming in to IF
    642             1                          2             if ARESETN = '0' then
    645             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    646                                        1     Count coming in to IF
    646             1                    ***0***               if (axi_awready = '1' and AWVALID = '1' and axi_wready = '1' and WVALID = '1' and axi_bvalid = '0'  ) then
    649             1                    ***0***               elsif (BREADY = '1' and axi_bvalid = '1') then   
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    657                                        3     Count coming in to IF
    657             1                          3           if rising_edge(ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    658                                        3     Count coming in to IF
    658             1                          2             if ARESETN = '0' then
    661             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    662                                        1     Count coming in to IF
    662             1                    ***0***               if (axi_arready = '0' and ARVALID = '1') then
    665             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    673                                        3     Count coming in to IF
    673             1                          3           if rising_edge(ACLK) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    674                                        3     Count coming in to IF
    674             1                          2             if ARESETN = '0' then
    677             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    678                                        1     Count coming in to IF
    678             1                    ***0***               if (axi_arready = '1' and ARVALID = '1' and axi_rvalid = '0') then
    681             1                    ***0***               elsif (axi_rvalid = '1' and RREADY = '1') then
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------CASE Branch------------------------------------
    692                                        6     Count coming in to CASE
    693             1                    ***0***               when b"000000" =>
    695             1                    ***0***               when b"000001" =>
    697             1                    ***0***               when b"000010" =>
    699             1                    ***0***               when b"000011" =>
    701             1                    ***0***               when b"000100" =>
    703             1                    ***0***               when b"000101" =>
    705             1                    ***0***               when b"000110" =>
    707             1                    ***0***               when b"000111" =>
    709             1                    ***0***               when b"001000" =>
    711             1                    ***0***               when b"001001" =>
    713             1                    ***0***               when b"001010" =>
    715             1                    ***0***               when b"001011" =>
    717             1                    ***0***               when b"001100" =>
    719             1                    ***0***               when b"001101" =>
    721             1                    ***0***               when b"001110" =>
    723             1                    ***0***               when b"001111" =>
    725             1                    ***0***               when b"010000" =>
    727             1                    ***0***               when b"010001" =>
    729             1                    ***0***               when b"010010" =>
    731             1                    ***0***               when b"010011" =>
    733             1                    ***0***               when b"010100" =>
    735             1                    ***0***               when b"010101" =>
    737             1                    ***0***               when b"010110" =>
    739             1                    ***0***               when b"010111" =>
    741             1                    ***0***               when b"011000" =>
    743             1                    ***0***               when b"011001" =>
    745             1                    ***0***               when b"011010" =>
    747             1                    ***0***               when b"011011" =>
    749             1                    ***0***               when b"011100" =>
    751             1                    ***0***               when b"011101" =>
    753             1                    ***0***               when b"011110" =>
    755             1                    ***0***               when b"011111" =>
    757             1                    ***0***     	      when b"100000" =>
    759             1                    ***0***     	      when b"100001" =>
    761             1                    ***0***     	      when b"100010" =>
    763             1                    ***0***     	      when b"100011" =>
    765             1                    ***0***     	      when b"100100" =>
    767             1                    ***0***     	      when b"100101" =>
    769             1                    ***0***     	      when b"100110" =>
    771             1                    ***0***     	      when b"100111" =>
    773             1                    ***0***     	      when b"101000" =>
    775             1                    ***0***     	      when b"101001" =>
    777             1                    ***0***     	      when b"101010" =>
    779             1                    ***0***     	      when b"101011" =>
    781             1                    ***0***     	      when b"101100" =>
    783             1                    ***0***     	      when b"101101" =>
    785             1                    ***0***     	      when b"101110" =>
    787             1                    ***0***     	      when b"101111" =>
    789             1                    ***0***     	      when b"110000" =>
    791             1                    ***0***     	      when b"110001" =>
    793             1                    ***0***     	      when b"110010" =>
    795             1                    ***0***     	      when b"110011" =>
    797             1                    ***0***     	      when b"110100" =>
    799             1                    ***0***     	      when b"110101" =>
    801             1                    ***0***     	      when b"110110" =>
    803             1                    ***0***     	      when b"110111" =>
    805             1                    ***0***     	      when b"111000" =>
    807             1                    ***0***     	      when b"111001" =>
    809             1                    ***0***     	      when b"111010" =>
    811             1                    ***0***     	      when b"111011" =>
    813             1                    ***0***     	      when b"111100" =>
    815             1                    ***0***     	      when b"111101" =>
    817             1                    ***0***     	      when b"111110" =>
    819             1                          4     	      when b"111111" =>
    821             1                          2               when others =>
Branch totals: 2 hits of 65 branches = 3.0%

------------------------------------IF Branch------------------------------------
    827                                        4     Count coming in to IF
    827             1                          4           if (rising_edge (ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    828                                        4     Count coming in to IF
    828             1                          3             if ( ARESETN = '0' ) then
    830             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    831                                        1     Count coming in to IF
    831             1                    ***0***               if (slv_reg_rden = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    839                                     1131     Count coming in to IF
    839             1                       1131             if (rising_edge (ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             28         0        28       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/vfpConfig.vhd --

----------------Focused Condition View-------------------
Line       73 Item    1  ((((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

           Input Term   Covered  Reason for no coverage   Hint
          -----------  --------  -----------------------  --------------
  (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
      (AWVALID = '1')         N  '_1' not hit             Hit '_1'
       (WVALID = '1')         N  No hits                  Hit '_0' and '_1'
        (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target             Non-masking condition(s)      
 ---------  ---------  --------------------   -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0  -                             
  Row   2:    ***0***  (axi_awready = '0')_1  (aw_en = '1') && (WVALID = '1') && (AWVALID = '1')
  Row   3:          1  (AWVALID = '1')_0      (axi_awready = '0')           
  Row   4:    ***0***  (AWVALID = '1')_1      (aw_en = '1') && (WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (WVALID = '1')_0       ((axi_awready = '0') and (AWVALID = '1'))
  Row   6:    ***0***  (WVALID = '1')_1       (aw_en = '1') && ((axi_awready = '0') and (AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0        (((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1        (((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1'))

----------------Focused Condition View-------------------
Line       75 Item    1  ((BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
      (BREADY = '1')         N  '_1' not hit             Hit '_1'
  (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (BREADY = '1')_0      -                             
  Row   2:    ***0***  (BREADY = '1')_1      (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0  (BREADY = '1')                
  Row   4:    ***0***  (axi_bvalid = '1')_1  (BREADY = '1')                

----------------Focused Condition View-------------------
Line       90 Item    1  ((((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

           Input Term   Covered  Reason for no coverage   Hint
          -----------  --------  -----------------------  --------------
  (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
      (AWVALID = '1')         N  '_1' not hit             Hit '_1'
       (WVALID = '1')         N  No hits                  Hit '_0' and '_1'
        (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target             Non-masking condition(s)      
 ---------  ---------  --------------------   -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0  -                             
  Row   2:    ***0***  (axi_awready = '0')_1  (aw_en = '1') && (WVALID = '1') && (AWVALID = '1')
  Row   3:          1  (AWVALID = '1')_0      (axi_awready = '0')           
  Row   4:    ***0***  (AWVALID = '1')_1      (aw_en = '1') && (WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (WVALID = '1')_0       ((axi_awready = '0') and (AWVALID = '1'))
  Row   6:    ***0***  (WVALID = '1')_1       (aw_en = '1') && ((axi_awready = '0') and (AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0        (((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1        (((axi_awready = '0') and (AWVALID = '1')) and (WVALID = '1'))

----------------Focused Condition View-------------------
Line       102 Item    1  ((((axi_wready = '0') and (WVALID = '1')) and (AWVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
  (axi_wready = '0')         N  No hits                  Hit '_0' and '_1'
      (WVALID = '1')         N  '_1' not hit             Hit '_1'
     (AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
       (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (axi_wready = '0')_0  -                             
  Row   2:    ***0***  (axi_wready = '0')_1  (aw_en = '1') && (AWVALID = '1') && (WVALID = '1')
  Row   3:          1  (WVALID = '1')_0      (axi_wready = '0')            
  Row   4:    ***0***  (WVALID = '1')_1      (aw_en = '1') && (AWVALID = '1') && (axi_wready = '0')
  Row   5:    ***0***  (AWVALID = '1')_0     ((axi_wready = '0') and (WVALID = '1'))
  Row   6:    ***0***  (AWVALID = '1')_1     (aw_en = '1') && ((axi_wready = '0') and (WVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0       (((axi_wready = '0') and (WVALID = '1')) and (AWVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1       (((axi_wready = '0') and (WVALID = '1')) and (AWVALID = '1'))

----------------Focused Condition View-------------------
Line       646 Item    1  (((((axi_awready = '1') and (AWVALID = '1')) and (axi_wready = '1')) and (WVALID = '1')) and (axi_bvalid = '0'))
Condition totals: 0 of 5 input terms covered = 0.0%

           Input Term   Covered  Reason for no coverage   Hint
          -----------  --------  -----------------------  --------------
  (axi_awready = '1')         N  '_1' not hit             Hit '_1'
      (AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
   (axi_wready = '1')         N  No hits                  Hit '_0' and '_1'
       (WVALID = '1')         N  No hits                  Hit '_0' and '_1'
   (axi_bvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target             Non-masking condition(s)      
 ---------  ---------  --------------------   -------------------------     
  Row   1:          1  (axi_awready = '1')_0  -                             
  Row   2:    ***0***  (axi_awready = '1')_1  (axi_bvalid = '0') && (WVALID = '1') && (axi_wready = '1') && (AWVALID = '1')
  Row   3:    ***0***  (AWVALID = '1')_0      (axi_awready = '1')           
  Row   4:    ***0***  (AWVALID = '1')_1      (axi_bvalid = '0') && (WVALID = '1') && (axi_wready = '1') && (axi_awready = '1')
  Row   5:    ***0***  (axi_wready = '1')_0   ((axi_awready = '1') and (AWVALID = '1'))
  Row   6:    ***0***  (axi_wready = '1')_1   (axi_bvalid = '0') && (WVALID = '1') && ((axi_awready = '1') and (AWVALID = '1'))
  Row   7:    ***0***  (WVALID = '1')_0       (((axi_awready = '1') and (AWVALID = '1')) and (axi_wready = '1'))
  Row   8:    ***0***  (WVALID = '1')_1       (axi_bvalid = '0') && (((axi_awready = '1') and (AWVALID = '1')) and (axi_wready = '1'))
  Row   9:    ***0***  (axi_bvalid = '0')_0   ((((axi_awready = '1') and (AWVALID = '1')) and (axi_wready = '1')) and (WVALID = '1'))
 Row   10:    ***0***  (axi_bvalid = '0')_1   ((((axi_awready = '1') and (AWVALID = '1')) and (axi_wready = '1')) and (WVALID = '1'))

----------------Focused Condition View-------------------
Line       649 Item    1  ((BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
      (BREADY = '1')         N  '_1' not hit             Hit '_1'
  (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (BREADY = '1')_0      -                             
  Row   2:    ***0***  (BREADY = '1')_1      (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0  (BREADY = '1')                
  Row   4:    ***0***  (axi_bvalid = '1')_1  (BREADY = '1')                

----------------Focused Condition View-------------------
Line       662 Item    1  ((axi_arready = '0') and (ARVALID = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

           Input Term   Covered  Reason for no coverage   Hint
          -----------  --------  -----------------------  --------------
  (axi_arready = '0')         N  No hits                  Hit '_0' and '_1'
      (ARVALID = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target             Non-masking condition(s)      
 ---------  ---------  --------------------   -------------------------     
  Row   1:    ***0***  (axi_arready = '0')_0  -                             
  Row   2:    ***0***  (axi_arready = '0')_1  (ARVALID = '1')               
  Row   3:          1  (ARVALID = '1')_0      (axi_arready = '0')           
  Row   4:    ***0***  (ARVALID = '1')_1      (axi_arready = '0')           

----------------Focused Condition View-------------------
Line       678 Item    1  (((axi_arready = '1') and (ARVALID = '1')) and (axi_rvalid = '0'))
Condition totals: 0 of 3 input terms covered = 0.0%

           Input Term   Covered  Reason for no coverage   Hint
          -----------  --------  -----------------------  --------------
  (axi_arready = '1')         N  '_1' not hit             Hit '_1'
      (ARVALID = '1')         N  No hits                  Hit '_0' and '_1'
   (axi_rvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target             Non-masking condition(s)      
 ---------  ---------  --------------------   -------------------------     
  Row   1:          1  (axi_arready = '1')_0  -                             
  Row   2:    ***0***  (axi_arready = '1')_1  (axi_rvalid = '0') && (ARVALID = '1')
  Row   3:    ***0***  (ARVALID = '1')_0      (axi_arready = '1')           
  Row   4:    ***0***  (ARVALID = '1')_1      (axi_rvalid = '0') && (axi_arready = '1')
  Row   5:    ***0***  (axi_rvalid = '0')_0   ((axi_arready = '1') and (ARVALID = '1'))
  Row   6:    ***0***  (axi_rvalid = '0')_1   ((axi_arready = '1') and (ARVALID = '1'))

----------------Focused Condition View-------------------
Line       681 Item    1  ((axi_rvalid = '1') and (RREADY = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
  (axi_rvalid = '1')         N  '_1' not hit             Hit '_1'
      (RREADY = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (axi_rvalid = '1')_0  -                             
  Row   2:    ***0***  (axi_rvalid = '1')_1  (RREADY = '1')                
  Row   3:    ***0***  (RREADY = '1')_0      (axi_rvalid = '1')            
  Row   4:    ***0***  (RREADY = '1')_1      (axi_rvalid = '1')            


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             7         0         7       0.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/vfpConfig.vhd --

----------------Focused Expression View-----------------
Line       110 Item    1  (((axi_wready and WVALID) and axi_awready) and AWVALID)
Expression totals: 0 of 4 input terms covered = 0.0%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
   axi_wready         N  No hits                  Hit '_0' and '_1'
       WVALID         N  No hits                  Hit '_0' and '_1'
  axi_awready         N  No hits                  Hit '_0' and '_1'
      AWVALID         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_wready_0          AWVALID && axi_awready && WVALID
  Row   2:    ***0***  axi_wready_1          AWVALID && axi_awready && WVALID
  Row   3:    ***0***  WVALID_0              AWVALID && axi_awready && axi_wready
  Row   4:    ***0***  WVALID_1              AWVALID && axi_awready && axi_wready
  Row   5:    ***0***  axi_awready_0         AWVALID && (axi_wready and WVALID)
  Row   6:    ***0***  axi_awready_1         AWVALID && (axi_wready and WVALID)
  Row   7:    ***0***  AWVALID_0             ((axi_wready and WVALID) and axi_awready)
  Row   8:    ***0***  AWVALID_1             ((axi_wready and WVALID) and axi_awready)

----------------Focused Expression View-----------------
Line       687 Item    1  ((axi_arready and ARVALID) and not(axi_rvalid))
Expression totals: 0 of 3 input terms covered = 0.0%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
  axi_arready         N  No hits                  Hit '_0' and '_1'
      ARVALID         N  No hits                  Hit '_0' and '_1'
   axi_rvalid         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_arready_0         not axi_rvalid && ARVALID     
  Row   2:    ***0***  axi_arready_1         not axi_rvalid && ARVALID     
  Row   3:    ***0***  ARVALID_0             not axi_rvalid && axi_arready 
  Row   4:    ***0***  ARVALID_1             not axi_rvalid && axi_arready 
  Row   5:    ***0***  axi_rvalid_0          (axi_arready and ARVALID)     
  Row   6:    ***0***  axi_rvalid_1          (axi_arready and ARVALID)     


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/vfpMaxisMM2s.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           29        25         4      86.2

================================Statement Details================================

Statement Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                entity videoProcess_v1_0_m_axis_mm2s is
    8                                                generic (
    9                                                    s_data_width	                : integer := 16);
    10                                               port (
    11                                                   aclk                            : in std_logic;
    12                                                   aresetn                         : in std_logic;
    13                                                   rgb_s_axis_tready               : out std_logic;
    14                                                   rgb_s_axis_tvalid               : in std_logic;
    15                                                   rgb_s_axis_tuser                : in std_logic;
    16                                                   rgb_s_axis_tlast                : in std_logic;
    17                                                   rgb_s_axis_tdata                : in std_logic_vector(s_data_width-1  downto 0);
    18                                                   m_axis_mm2s_tkeep               : out std_logic_vector(2 downto 0);
    19                                                   m_axis_mm2s_tstrb               : out std_logic_vector(2 downto 0);
    20                                                   m_axis_mm2s_tid                 : out std_logic_vector(0 downto 0);
    21                                                   m_axis_mm2s_tdest               : out std_logic_vector(0 downto 0);  
    22                                                   m_axis_mm2s_tready              : in std_logic;
    23                                                   m_axis_mm2s_tvalid              : out std_logic;
    24                                                   m_axis_mm2s_tuser               : out std_logic;
    25                                                   m_axis_mm2s_tlast               : out std_logic;
    26                                                   m_axis_mm2s_tdata               : out std_logic_vector(s_data_width-1 downto 0));
    27                                               end videoProcess_v1_0_m_axis_mm2s;
    28                                               architecture arch_imp of videoProcess_v1_0_m_axis_mm2s is
    29                                                   type pixel_locations is (video_trans_in_progress,wait_to_go);
    30                                                   signal pixel_locations_address  : pixel_locations; 
    31                                                   signal axis_tvalid              : std_logic:= lo;
    32                                                   signal axis_tuser               : std_logic:= lo;
    33                                                   signal axis_tlast               : std_logic:= lo;
    34                                                   signal axis_tdata               : std_logic_vector(s_data_width-1 downto 0):= (others => lo); 
    35                                                   signal maxis_mm2s_tdata         : std_logic_vector(s_data_width-1 downto 0):= (others => lo);
    36                                                   signal maxis_mm2s_tuser         : std_logic:= lo;
    37                                                   signal maxis_mm2s_tvalid        : std_logic:= lo;
    38                                                   signal maxis_mmss_tvalid        : std_logic:= lo;
    39                                                   signal mm2s_tready              : std_logic:= lo;
    40                                               begin
    41                                               process(aclk) begin
    42                                                   if rising_edge(aclk) then
    43              1                       1131             axis_tvalid <= rgb_s_axis_tvalid;
    44              1                       1131             mm2s_tready <= m_axis_mm2s_tready;
    45              1                       1131             axis_tuser  <= rgb_s_axis_tuser;
    46              1                       1131             axis_tdata  <= rgb_s_axis_tdata(15 downto 8) & rgb_s_axis_tdata(7 downto 0);
    47                                                   end if;
    48                                               end process;
    49                                               process (aclk) begin
    50                                                   if (rising_edge (aclk)) then
    51                                                       if (aresetn = lo) then
    52              1                          2                 pixel_locations_address <= wait_to_go;
    53              1                          2                 rgb_s_axis_tready       <=lo;
    54                                                       else
    55                                                       case (pixel_locations_address) is
    56                                                       when wait_to_go =>
    57              1                          2                 axis_tlast         <=lo;
    58              1                          2                 rgb_s_axis_tready  <=hi;--initiate
    59              1                          2                 maxis_mm2s_tvalid  <=lo;
    60                                                           if (rgb_s_axis_tvalid  = hi)then-- initiate response
    61              1                          1                     pixel_locations_address <= video_trans_in_progress;            
    62                                                           else
    63              1                          1                     pixel_locations_address <= wait_to_go;    
    64                                                           end if;        
    65                                                       when video_trans_in_progress =>
    66              1                        284                 maxis_mm2s_tuser   <= axis_tuser;
    67              1                        284                 maxis_mm2s_tdata   <= axis_tdata;
    68                                                           if (rgb_s_axis_tlast = hi)then
    69              1                    ***0***                     axis_tlast <=hi;
    70              1                    ***0***                     maxis_mm2s_tvalid  <=lo;
    71              1                    ***0***                     pixel_locations_address <= wait_to_go;
    72                                                           else
    73              1                        284                     axis_tlast <=lo;
    74              1                        284                     maxis_mm2s_tvalid  <=hi;
    75              1                        284                     pixel_locations_address <= video_trans_in_progress;
    76                                                           end if;
    77                                                       when others =>
    78              1                    ***0***                 pixel_locations_address <= wait_to_go;
    79                                                       end case;
    80                                                       end if;
    81                                                   end if;
    82                                               end process;
    83                                               process(aclk) begin
    84                                                   if rising_edge(aclk) then
    85              1                        194             m_axis_mm2s_tkeep      <= (others => hi);
    86              1                        194             m_axis_mm2s_tid        <= "0";
    87              1                        194             m_axis_mm2s_tdest      <= "0";
    88              1                        194             m_axis_mm2s_tstrb      <= (others => hi);
    89              1                        194             m_axis_mm2s_tdata      <= maxis_mm2s_tdata;
    90              1                        194             m_axis_mm2s_tlast      <= axis_tlast;
    91              1                        194             m_axis_mm2s_tuser      <= maxis_mm2s_tuser;
    92              1                        194             m_axis_mm2s_tvalid     <= maxis_mm2s_tvalid or maxis_mmss_tvalid;
    93                                                   end if;
    94                                               end process;
    95                                               process(aclk) begin
    96                                                   if rising_edge(aclk) then
    97              1                       1131             maxis_mmss_tvalid  <= maxis_mm2s_tvalid;
    98                                                   end if;
    99                                               end process;    
    100                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13        11         2      84.6

================================Branch Details================================

Branch Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

------------------------------------IF Branch------------------------------------
    42                                      1131     Count coming in to IF
    42              1                       1131         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    50                                       288     Count coming in to IF
    50              1                        288         if (rising_edge (aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    51                                       288     Count coming in to IF
    51              1                          2             if (aresetn = lo) then
    54              1                        286             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    55                                       286     Count coming in to CASE
    56              1                          2             when wait_to_go =>
    65              1                        284             when video_trans_in_progress =>
    77              1                    ***0***             when others =>
Branch totals: 2 hits of 3 branches = 66.6%

------------------------------------IF Branch------------------------------------
    60                                         2     Count coming in to IF
    60              1                          1                 if (rgb_s_axis_tvalid  = hi)then-- initiate response
    62              1                          1                 else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    68                                       284     Count coming in to IF
    68              1                    ***0***                 if (rgb_s_axis_tlast = hi)then
    72              1                        284                 else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    84                                       194     Count coming in to IF
    84              1                        194         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    96                                      1131     Count coming in to IF
    96              1                       1131         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         1         1      50.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

----------------Focused Expression View-----------------
Line       92 Item    1  (maxis_mm2s_tvalid or maxis_mmss_tvalid)
Expression totals: 1 of 2 input terms covered = 50.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  maxis_mm2s_tvalid         Y
  maxis_mmss_tvalid         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  maxis_mm2s_tvalid_0   not maxis_mmss_tvalid         
  Row   2:          1  maxis_mm2s_tvalid_1   not maxis_mmss_tvalid         
  Row   3:          1  maxis_mmss_tvalid_0   not maxis_mm2s_tvalid         
  Row   4:    ***0***  maxis_mmss_tvalid_1   not maxis_mm2s_tvalid         


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

FSM_ID: pixel_locations_address
    Current State Object : pixel_locations_address
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  56          wait_to_go                   1
  65video_trans_in_progress                   0
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
              wait_to_go                   3
    video_trans_in_progress                 285
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  61                   0                   1          wait_to_go -> video_trans_in_progress
  71                   1                   1          video_trans_in_progress -> wait_to_go


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

=================================================================================
=== File: ../modules/top.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           34        34         0     100.0

================================Statement Details================================

Statement Coverage for file ../modules/top.sv --

    1                                                `include "uvm_macros.svh"
    2                                                package socTest_pkg;
    3                                                import uvm_pkg::*;
    4                                                //====================================================================================
    5                                                //------------------------------------------------------------------------------------
    6                                                //--------------------------------- DEFINES
    7                                                //------------------------------------------------------------------------------------
    8                                                //====================================================================================
    9                                                typedef struct packed {
    10                                                  byte unsigned addr_width;
    11                                                  byte unsigned data_width;
    12                                               } width_confg1_t;
    13                                               typedef struct packed {
    14                                                  int unsigned payload_length;
    15                                               } width_confg2_t;
    16                                               typedef struct packed {
    17                                                  width_confg1_t w_p1;
    18                                                  width_confg2_t w_p2;
    19                                               } set_config;
    20                                               typedef enum { READ, WRITE } axiLite_txn_e;
    21                                               parameter set_config par_1 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 2 } };
    22                                               parameter set_config par_2 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 4 } };
    23                                               parameter set_config par_3 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 3 } };
    24                                               typedef enum bit [5:0] {
    25                                               	AX_FLOW_TYPE				= 6'h00,
    26                                               	AX_WRITE_TYPE				= 6'h08,
    27                                               	AX_MISC_WRITE_TYPE			= 6'h10,
    28                                               	AX_POSTED_WRITE_TYPE		= 6'h18,
    29                                               	AX_POSTED_MISC_WRITE_TYPE	= 6'h20,
    30                                               	AX_MODE_READ_TYPE			= 6'h28,
    31                                               	AX_READ_TYPE				= 6'h30,
    32                                               	AX_RESPONSE_TYPE			= 6'h38
    33                                               } ax_command_type;
    34                                               typedef enum bit [5:0] {
    35                                                   AX_NULL                = 6'h00,
    36                                                   AX_PRET                = 6'h01,
    37                                                   AX_TRET                = 6'h02,
    38                                                   AX_IRTRY                = 6'h03,
    39                                                   AX_WRITE_16            = 6'h08,
    40                                                   AX_WRITE_32            = 6'h09,
    41                                                   AX_WRITE_48            = 6'h0a,
    42                                                   AX_WRITE_64            = 6'h0b,
    43                                                   AX_WRITE_80            = 6'h0c,
    44                                                   AX_WRITE_96            = 6'h0d,
    45                                                   AX_WRITE_112            = 6'h0e,
    46                                                   AX_WRITE_128            = 6'h0f,
    47                                                   //-- misc write
    48                                                   AX_MODE_WRITE            = 6'h10,
    49                                                   AX_BIT_WRITE            = 6'h11,
    50                                                   AX_DUAL_8B_ADDI        = 6'h12,
    51                                                   AX_SINGLE_16B_ADDI        = 6'h13,
    52                                                   AX_POSTED_WRITE_16        = 6'h18,
    53                                                   AX_POSTED_WRITE_32        = 6'h19,
    54                                                   AX_POSTED_WRITE_48        = 6'h1a,
    55                                                   AX_POSTED_WRITE_64        = 6'h1b,
    56                                                   AX_POSTED_WRITE_80        = 6'h1c,
    57                                                   AX_POSTED_WRITE_96        = 6'h1d,
    58                                                   AX_POSTED_WRITE_112    = 6'h1e,
    59                                                   AX_POSTED_WRITE_128    = 6'h1f,
    60                                                   AX_POSTED_BIT_WRIT            = 6'h21,
    61                                                   AX_POSTED_DUAL_8B_ADDI        = 6'h22,
    62                                                   AX_POSTED_SINGLE_16B_ADDI    = 6'h23,
    63                                                   AX_MODE_READ            = 6'h28,
    64                                                   AX_READ_16                = 6'h30,
    65                                                   AX_READ_32                = 6'h31,
    66                                                   AX_READ_48                = 6'h32,
    67                                                   AX_READ_64                = 6'h33,
    68                                                   AX_READ_80                = 6'h34,
    69                                                   AX_READ_96                = 6'h35,
    70                                                   AX_READ_112            = 6'h36,
    71                                                   AX_READ_128            = 6'h37,
    72                                                   AX_READ_RESPONSE        = 6'h38,
    73                                                   AX_WRITE_RESPONSE        = 6'h39,
    74                                                   AX_MODE_READ_RESPONSE    = 6'h3A,
    75                                                   AX_MODE_WRITE_RESPONSE    = 6'h3B,
    76                                                   AX_ERROR_RESPONSE        = 6'h3E
    77                                               } ax_command_encoding;
    78                                               `define AX_TYPE_MASK 6'h38
    79                                               //====================================================================================
    80                                               //------------------------------------------------------------------------------------
    81                                               //--------------------------------- UVM_CONFIGURATIONS
    82                                               //------------------------------------------------------------------------------------
    83                                               //====================================================================================
    84                                               // UVM_OBJECT : TEMPLATE_CONFIGURATION [TEMPLATE]
    85                                               class template_configuration extends uvm_object;
    86                                                   `uvm_object_utils(template_configuration)
    87                                                   function new(string name = "");
    88                                                       super.new(name);
    89                                                   endfunction: new
    90                                               endclass: template_configuration
    91                                               // UVM_OBJECT : AXILITE_CONFIGURATION [AXILITE]
    92                                               class axiLite_configuration extends uvm_object;
    93                                                   `uvm_object_utils(axiLite_configuration)
    94                                                   function new(string name = "");
    95                                                       super.new(name);
    96                                                   endfunction: new
    97                                               endclass: axiLite_configuration
    98                                               // UVM_OBJECT : RGB_CONFIGURATION [RGB]
    99                                               class rgb_configuration extends uvm_object;
    100                                                  `uvm_object_utils(rgb_configuration)
    101                                                  function new(string name = "");
    102                                                      super.new(name);
    103                                                  endfunction: new
    104                                                  rand int count;
    105                                                  constraint c_count    { count > 0; count < 128; }
    106                                              endclass: rgb_configuration
    107                                              class axi4_stream_config extends uvm_object;
    108                                              	uvm_active_passive_enum master_active = UVM_ACTIVE;
    109                                              	uvm_active_passive_enum slave_active  = UVM_ACTIVE;
    110                                              	uvm_active_passive_enum open_rsp_mode = UVM_ACTIVE;
    111                                                  virtual axi4_stream_if vif;
    112                                              	`uvm_object_utils_begin(axi4_stream_config)
    113                                              		`uvm_field_enum(uvm_active_passive_enum, master_active, UVM_DEFAULT)
    114                                              		`uvm_field_enum(uvm_active_passive_enum, slave_active,  UVM_DEFAULT)
    115                                              		`uvm_field_enum(uvm_active_passive_enum, open_rsp_mode,  UVM_DEFAULT)
    116                                              	`uvm_object_utils_end
    117                                                  function new(string name = "");
    118                                                      super.new(name);
    119                                                  endfunction: new
    120                                              	virtual function void do_print (uvm_printer printer);
    121                                              		super.do_print(printer);
    122                                              	endfunction : do_print
    123                                              endclass : axi4_stream_config
    124                                              class axi4_stream_agents_config extends uvm_object;
    125                                                  `uvm_object_utils(axi4_stream_agents_config)
    126                                                  bit has_axi4_agent1 = 1; //switch to instantiate an agent #1
    127                                                  bit has_axi4_agent2 = 1; //switch to instantiate an agent #2
    128                                                  axi4_stream_config axi4_agent_handler1;
    129                                                  axi4_stream_config axi4_agent_handler2;
    130                                                  function new(string name = "");
    131                                                      super.new(name);
    132                                                  endfunction: new
    133                                              endclass: axi4_stream_agents_config
    134                                              //====================================================================================
    135                                              //------------------------------------------------------------------------------------
    136                                              //--------------------------------- UVM_SEQUENCE_ITEMES
    137                                              //------------------------------------------------------------------------------------
    138                                              //====================================================================================
    139                                              // UVM_SEQUENCE_ITEM : RGB_TRANSACTION [RGB]
    140                                              class rgb_transaction#(parameter set_config cfg = par_1) extends uvm_sequence_item;
    141                                                  rand bit[cfg.w_p1.data_width-1:0]       iRed;
    142                                                  rand bit[cfg.w_p1.data_width-1:0]       iGreen;
    143                                                  rand bit[cfg.w_p1.data_width-1:0]       iBlue;
    144                                                  rand bit            iPixelEn;
    145                                                  rand bit            iValid;
    146                                                  rand bit            iEof;
    147                                                  rand bit [cfg.w_p1.addr_width-1:0]      iX;
    148                                                  rand bit [cfg.w_p1.addr_width-1:0]      iY;
    149                                                  function new(string name = "");
    150                                                      super.new(name);
    151                                                  endfunction: new
    152                                                  `uvm_object_utils_begin(rgb_transaction#(cfg))
    153                                                      `uvm_field_int(iRed,         UVM_ALL_ON)
    154                                                      `uvm_field_int(iGreen,       UVM_ALL_ON)
    155                                                      `uvm_field_int(iBlue,        UVM_ALL_ON)
    156                                                      `uvm_field_int(iPixelEn,     UVM_ALL_ON)
    157                                                      `uvm_field_int(iEof,         UVM_ALL_ON)
    158                                                      `uvm_field_int(iValid,       UVM_ALL_ON)
    159                                                      `uvm_field_int(iX,           UVM_ALL_ON)
    160                                                      `uvm_field_int(iY,           UVM_ALL_ON)
    161                                                  `uvm_object_utils_end
    162                                              endclass: rgb_transaction
    163                                              // UVM_SEQUENCE_ITEM : AXILITE_TXN [AXILITE]
    164                                              class axiLite_transaction extends uvm_sequence_item;
    165                                                  rand bit [15:0]     addr;
    166                                                  rand bit [31:0]     data;
    167                                                  rand bit [31:0]     WDATA;
    168                                                  rand bit [31:0]     RDATA;
    169                                                  rand axiLite_txn_e  reqWriteRead;
    170                                                  rand int unsigned   cycles;
    171                                                  constraint c_cycles { 
    172                                                  cycles <= 20; }
    173                                                  function new (string name = "");
    174                                                      super.new(name);
    175                                                  endfunction
    176                                                  function string convert2string();
    177                                                      return $sformatf("addr='h%h, data='h%0h, cycles='d%0d",addr, data, cycles);
    178                                                  endfunction
    179                                                  `uvm_object_utils_begin(axiLite_transaction)
    180                                                      `uvm_field_int  (addr,                          UVM_DEFAULT)
    181                                                      `uvm_field_int  (data,                          UVM_DEFAULT)
    182                                                      `uvm_field_int  (WDATA,                         UVM_DEFAULT)
    183                                                      `uvm_field_int  (RDATA,                         UVM_DEFAULT)
    184                                                      `uvm_field_enum (axiLite_txn_e, reqWriteRead,   UVM_DEFAULT)    
    185                                                      `uvm_field_int  (cycles,                        UVM_DEFAULT)
    186                                                  `uvm_object_utils_end
    187                                              endclass: axiLite_transaction
    188                                              // UVM_SEQUENCE_ITEM : TEMPLATE_TRANSACTION [TEMPLATE]
    189                                              class template_transaction extends uvm_sequence_item;
    190                                                  rand bit[1:0] ina;
    191                                                  rand bit[1:0] inb;
    192                                                  bit[2:0]      out;
    193                                                  function new(string name = "");
    194                                                      super.new(name);
    195                                                  endfunction: new
    196                                                  `uvm_object_utils_begin(template_transaction)
    197                                                      `uvm_field_int(ina, UVM_ALL_ON)
    198                                                      `uvm_field_int(inb, UVM_ALL_ON)
    199                                                      `uvm_field_int(out, UVM_ALL_ON)
    200                                                  `uvm_object_utils_end
    201                                              endclass: template_transaction
    202                                              class axi4_stream_valid_cycle  extends uvm_sequence_item;
    203                                                  rand bit [15:0]    tdata;
    204                                                  rand bit               tuser;
    205                                                  rand int unsigned      delay = 0;
    206                                                  constraint c_packet_delay {
    207                                                      delay < 20 ;
    208                                                  }
    209                                                  function new(string name = "");
    210                                                      super.new(name);
    211                                                  endfunction: new
    212                                                  `uvm_object_utils_begin(axi4_stream_valid_cycle)
    213                                                      `uvm_field_int(tdata, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    214                                                      `uvm_field_int(tuser, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    215                                                      `uvm_field_int(delay, UVM_DEFAULT | UVM_DEC| UVM_NOPACK)
    216                                                  `uvm_object_utils_end
    217                                              endclass : axi4_stream_valid_cycle
    218                                              //====================================================================================
    219                                              //------------------------------------------------------------------------------------
    220                                              //--------------------------------- UVM_SEQUENCERS
    221                                              //------------------------------------------------------------------------------------
    222                                              //====================================================================================
    223                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCER [TEMPLATE]
    224                                              class template_sequencer extends uvm_sequencer #(template_transaction);
    225                                                  `uvm_component_utils(template_sequencer)
    226                                                  function new(string name, uvm_component parent);
    227                                                      super.new(name, parent);
    228                                                  endfunction
    229                                              endclass: template_sequencer
    230                                              // UVM_SEQUENCE : AXILITE_SQR [AXILITE]
    231                                              class axiLite_sequencer extends uvm_sequencer #(axiLite_transaction);
    232                                                  int id;
    233                                                  `uvm_component_utils_begin(axiLite_sequencer)
    234                                                      `uvm_field_int(id, UVM_DEFAULT)
    235                                                  `uvm_component_utils_end
    236                                                  function new (string name, uvm_component parent);
    237                                                      super.new(name, parent);
    238                                                  endfunction
    239                                              endclass: axiLite_sequencer
    240                                              // UVM_SEQUENCE : RGB_SEQUENCER [RGB]
    241                                              class rgb_sequencer#(parameter set_config cfg = par_1) extends uvm_sequencer#(rgb_transaction#(cfg));
    242                                                  `uvm_component_param_utils(rgb_sequencer#(cfg))
    243                                                  function new(string name, uvm_component parent);
    244                                                      super.new(name, parent);
    245                                                  endfunction
    246                                              endclass: rgb_sequencer
    247                                              class axi4_stream_master_sequencer extends uvm_sequencer #(axi4_stream_valid_cycle);
    248                                                  `uvm_component_utils(axi4_stream_master_sequencer)
    249                                                  function new(string name, uvm_component parent);
    250                                                      super.new(name, parent);
    251                                                  endfunction
    252                                              endclass : axi4_stream_master_sequencer
    253                                              //====================================================================================
    254                                              //------------------------------------------------------------------------------------
    255                                              //--------------------------------- UVM_SEQUENCES
    256                                              //------------------------------------------------------------------------------------
    257                                              //====================================================================================
    258                                              // UVM_SEQUENCE : RGB_RANDOM_SEQUENCE [RGB]
    259                                              class rgb_random_sequence#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    260                                                  `uvm_object_param_utils(rgb_random_sequence#(cfg));
    261                                                  function new(string name = "rgb_random_sequence");
    262                                                      super.new(name);
    263                                                  endfunction : new
    264                                                  task body();
    265                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    266                                                      repeat (100000) begin : random_loop
    267                                                          start_item(frame_tx);
    268                                                          assert(frame_tx.randomize());
    269                                                          finish_item(frame_tx);
    270                                                      end : random_loop
    271                                                  endtask : body
    272                                              endclass : rgb_random_sequence
    273                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R1 [RGB]
    274                                              class random_sequence_r1#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    275                                                  `uvm_object_param_utils(random_sequence_r1#(cfg));
    276                                                  function new(string name = "random_sequence_r1");
    277                                                      super.new(name);
    278                                                  endfunction : new
    279                                                  task body();
    280                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    281                                                  `uvm_info("random_sequence_r1", "executing...", UVM_LOW)
    282                                                      repeat (100) begin : random_loop
    283                                                          start_item(frame_tx);
    284                                                          assert(frame_tx.randomize());
    285                                                          finish_item(frame_tx);
    286                                                      end : random_loop
    287                                                  endtask : body
    288                                              endclass : random_sequence_r1
    289                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R2 [RGB]
    290                                              class random_sequence_r2 extends random_sequence_r1;
    291                                                  `uvm_object_utils(random_sequence_r2);
    292                                                  function new(string name = "random_sequence_r2");
    293                                                      super.new(name);
    294                                                  endfunction : new
    295                                                  task body();
    296                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    297                                                  `uvm_info("random_sequence_r2", "executing...", UVM_LOW)
    298                                                      repeat (1) begin : random_loop
    299                                                          start_item(frame_tx);
    300                                                          assert(frame_tx.randomize());
    301                                                          finish_item(frame_tx);
    302                                                      end : random_loop
    303                                                  endtask : body
    304                                              endclass : random_sequence_r2
    305                                              // UVM_SEQUENCE : TOP_SEQUENCE [RGB]
    306                                              class top_sequence extends uvm_sequence #(rgb_transaction);
    307                                                  `uvm_object_utils(top_sequence)
    308                                                  `uvm_declare_p_sequencer(rgb_sequencer)
    309                                                  function new (string name = "");
    310                                                      super.new(name);
    311                                                  endfunction
    312                                                  task body;
    313                                                      rgb_configuration cfg;
    314                                                      int count;
    315                                                      if ( uvm_config_db #(rgb_configuration)::get(p_sequencer, "", "config", cfg) ) begin
    316                                                          count    = cfg.count;
    317                                                      end
    318                                                      else begin
    319                                                          count    = 1;
    320                                                      end
    321                                                      if (starting_phase != null)
    322                                                          starting_phase.raise_objection(this);
    323                                                      repeat(count) begin
    324                                                          random_sequence_r1#(par_1) seq;
    325                                                          seq = random_sequence_r1#(par_1)::type_id::create("seq");
    326                                                          seq.start(p_sequencer, this);
    327                                                      end
    328                                                      if (starting_phase != null)
    329                                                          starting_phase.drop_objection(this);
    330                                                  endtask: body
    331                                              endclass: top_sequence
    332                                              // UVM_SEQUENCE : AXILITE_BASE_SEQ [AXILITE]
    333                                              virtual class axiLite_base_seq extends uvm_sequence #(axiLite_transaction);
    334                                                  function new (string name="axiLite_base_seq");
    335                                                      super.new(name);
    336                                                  endfunction
    337                                              endclass: axiLite_base_seq
    338                                              // UVM_SEQUENCE : AXILITE_NO_ACTIVITY_SEQ [AXILITE]
    339                                              class axiLite_no_activity_sequence extends axiLite_base_seq;
    340                                                  `uvm_object_utils(axiLite_no_activity_sequence)
    341                                                  function new(string name="axiLite_no_activity_sequence");
    342                                                      super.new(name);
    343                                                  endfunction
    344                                                  virtual task body();
    345                                                      `uvm_info("SEQ", "executing", UVM_LOW)
    346                                                  endtask: body
    347                                              endclass: axiLite_no_activity_sequence
    348                                              // UVM_SEQUENCE : AXILITE_RANDOM_SEQ [AXILITE]
    349                                              class axiLite_random_sequence extends axiLite_base_seq;
    350                                                  `uvm_object_utils(axiLite_random_sequence)
    351                                                  function new(string name="axiLite_random_sequence");
    352                                                      super.new(name);
    353                                                  endfunction
    354                                                  virtual task body();
    355                                                      axiLite_transaction item;
    356                                                      int num_txn;
    357                                                      bit typ_txn;
    358                                                      `uvm_info("SEQ", "executing...", UVM_LOW)
    359                                                      num_txn = $urandom_range(5,20);
    360                                                      repeat(num_txn) begin    
    361                                                      `uvm_create(item)
    362                                                      item.cycles         = $urandom_range(1,5);
    363                                                      item.addr           = $urandom();
    364                                                      item.data           = $urandom();
    365                                                      typ_txn             = $random();
    366                                                      item.reqWriteRead   = typ_txn ? WRITE : READ; 
    367                                                      `uvm_send(item);
    368                                                      end    
    369                                                  endtask: body
    370                                              endclass: axiLite_random_sequence
    371                                              // UVM_SEQUENCE : AXILITE_DIRECTED_SEQ [AXILITE]
    372                                              class axiLite_directed_sequence extends axiLite_base_seq;
    373                                                  `uvm_object_utils(axiLite_directed_sequence)
    374                                                  function new(string name="axiLite_directed_sequence");
    375                                                      super.new(name);
    376                                                  endfunction
    377                                                  virtual task body();
    378                                                      axiLite_transaction item;
    379                                                      bit [8:0] addr;
    380                                                      `uvm_info("SEQ", "executing...WR->RD->WR->RD", UVM_LOW)
    381                                                      for(addr = 0; addr < 256; addr ++) begin
    382                                                          `uvm_create(item)
    383                                                          item.addr           = {14'h0,addr[7:0]};
    384                                                          item.reqWriteRead   = addr[0] ? READ : WRITE;
    385                                                          item.cycles         = 0;
    386                                                          item.data           = addr;
    387                                                          `uvm_send(item);
    388                                                      end
    389                                                      `uvm_info("SEQ", "executing...WR->WR->RD->RD", UVM_LOW)
    390                                                      for(addr = 0; addr < 255; addr ++) begin
    391                                                          `uvm_create(item)
    392                                                          item.addr           = {14'h0,addr[7:0]};
    393                                                          item.reqWriteRead   = addr[8] ? READ : WRITE;
    394                                                          item.cycles         = 5;
    395                                                          item.data           = addr;
    396                                                          `uvm_send(item);
    397                                                      end
    398                                                  endtask: body
    399                                              endclass: axiLite_directed_sequence
    400                                              // UVM_SEQUENCE : AXILITE_USEVAR_SEQ [AXILITE]
    401                                              class axiLite_usevar_sequence extends axiLite_base_seq;
    402                                                  `uvm_object_utils(axiLite_usevar_sequence)
    403                                                  `uvm_declare_p_sequencer(axiLite_sequencer)
    404                                                  function new(string name="axiLite_usevar_sequence");
    405                                                      super.new(name);
    406                                                  endfunction
    407                                                  virtual task body();
    408                                                  axiLite_transaction item;
    409                                                  int id;
    410                                                  `uvm_info("SEQ", "executing...", UVM_LOW)
    411                                                  id = p_sequencer.id;
    412                                                  `uvm_info("SEQ", $sformatf("using id=%0hh from sequencer", id), UVM_LOW)
    413                                                  `uvm_create(item)
    414                                                  item.cycles = $urandom_range(1,5);
    415                                                  item.data = id;
    416                                                  `uvm_send(item);
    417                                                  endtask
    418                                              endclass:axiLite_usevar_sequence
    419                                              // UVM_SEQUENCE : TEMPLATE_BASE_SEQ [TEMPLATE]
    420                                              virtual class template_base_sequence extends uvm_sequence #(template_transaction);
    421                                                  function new (string name="template_base_sequence");
    422                                                      super.new(name);
    423                                                  endfunction
    424                                              endclass: template_base_sequence
    425                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCE [TEMPLATE]
    426                                              class template_sequence extends uvm_sequence#(template_transaction);
    427                                                  `uvm_object_utils(template_sequence)
    428                                                  function new(string name = "");
    429                                                      super.new(name);
    430                                                  endfunction: new
    431                                                  task body();
    432                                                      template_transaction tx;
    433                                                      repeat(10000) begin
    434                                                      tx = template_transaction::type_id::create(.name("tx"), .contxt(get_full_name()));
    435                                                      start_item(tx);
    436                                                          assert(tx.randomize());
    437                                                          //`uvm_info("sa_sequence", tx.sprint(), UVM_LOW);
    438                                                      finish_item(tx);
    439                                                      end
    440                                                  endtask: body
    441                                              endclass: template_sequence
    442                                              class ax_packet extends uvm_sequence_item;
    443                                              parameter AX_TYPE_MASK = 6'h38;
    444                                              	// request header fields
    445                                              	rand bit [2:0]			cube_ID;				// CUB
    446                                              	rand bit [33:0]		    address;				// ADRS
    447                                              	rand bit [8:0]			tag;					// TAG
    448                                              	rand bit [3:0]			packet_length;			// LNG 128-bit (16-byte) flits
    449                                              	rand bit [3:0]			duplicate_length;		// DLN
    450                                              	rand ax_command_encoding 	command;			// CMD
    451                                              	bit [127:0]				payload[$];				// 16-byte granularity
    452                                              	// request tail fields
    453                                              	rand bit [4:0]			return_token_count;		// RTC
    454                                              	rand bit [2:0]			source_link_ID;			// SLID
    455                                              	rand bit [2:0]			sequence_number;		// SEQ
    456                                              	rand bit [7:0]			forward_retry_pointer;	// FRP
    457                                              	rand bit [7:0]			return_retry_pointer;	// RRP
    458                                              	rand bit [31:0]		packet_crc;				// CRC
    459                                              	// response header fields not used before
    460                                              	rand bit [8:0]			return_tag;				// TGA (Optional)
    461                                              	// response tail fields not used before
    462                                              	rand bit [6:0]			error_status;			// ERRSTAT
    463                                              	rand bit				data_invalid;			// DINV
    464                                              	// special bits for IRTRY
    465                                              	rand bit				start_retry;
    466                                              	rand bit				clear_error_abort;
    467                                              	// CRC status fields
    468                                              	rand bit				poisoned;				// Inverted CRC
    469                                              	rand bit				crc_error;
    470                                              	// helper fields
    471                                              	rand int				flit_delay;
    472                                              	int						timestamp;
    473                                              	`uvm_object_utils_begin(ax_packet)
    474                                              		`uvm_field_int(flit_delay, UVM_ALL_ON | UVM_NOPACK | UVM_DEC | UVM_NOCOMPARE | UVM_DEC)
    475                                              		`uvm_field_int(cube_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    476                                              		`uvm_field_int(address, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    477                                              		`uvm_field_int(tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    478                                              		`uvm_field_int(packet_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    479                                              		`uvm_field_int(duplicate_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    480                                              		`uvm_field_enum(ax_command_encoding, command, UVM_ALL_ON | UVM_NOPACK )
    481                                              		`uvm_field_queue_int(payload, UVM_ALL_ON | UVM_NOPACK)
    482                                              		`uvm_field_int(return_token_count, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    483                                              		`uvm_field_int(source_link_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    484                                              		`uvm_field_int(sequence_number, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    485                                              		`uvm_field_int(forward_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    486                                              		`uvm_field_int(return_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    487                                              		`uvm_field_int(packet_crc, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    488                                              		`uvm_field_int(return_tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    489                                              		`uvm_field_int(error_status, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    490                                              		`uvm_field_int(data_invalid, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    491                                              		`uvm_field_int(poisoned, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    492                                              		`uvm_field_int(crc_error, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    493                                              	`uvm_object_utils_end
    494                                              	constraint c_poisoned { poisoned == 0; }
    495                                              	constraint c_cube_id {cube_ID ==0;}
    496                                              	constraint c_address {
    497                                              		soft address < 80000000;
    498                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> address == 0;	
    499                                              		soft address[3:0]==4'h0;
    500                                              	}
    501                                              	constraint c_source_link_ID {source_link_ID ==0;}
    502                                              	constraint c_crc_error { crc_error == 0; }
    503                                              	constraint c_matching_length { packet_length == duplicate_length; }
    504                                              	constraint c_return_tag { return_tag == 0; }
    505                                              	constraint c_packet_length { (
    506                                              						(packet_length == 2 && command == AX_POSTED_WRITE_16) ||
    507                                              						(packet_length == 3 && command == AX_POSTED_WRITE_32) ||
    508                                              						(packet_length == 4 && command == AX_POSTED_WRITE_48) ||
    509                                              						(packet_length == 5 && command == AX_POSTED_WRITE_64) ||
    510                                              						(packet_length == 6 && command == AX_POSTED_WRITE_80) ||
    511                                              						(packet_length == 7 && command == AX_POSTED_WRITE_96) ||
    512                                              						(packet_length == 8 && command == AX_POSTED_WRITE_112) ||
    513                                              						(packet_length == 9 && command == AX_POSTED_WRITE_128) ||
    514                                              						(packet_length == 2 && command == AX_WRITE_16) ||
    515                                              						(packet_length == 3 && command == AX_WRITE_32) ||
    516                                              						(packet_length == 4 && command == AX_WRITE_48) ||
    517                                              						(packet_length == 5 && command == AX_WRITE_64) ||
    518                                              						(packet_length == 6 && command == AX_WRITE_80) ||
    519                                              						(packet_length == 7 && command == AX_WRITE_96) ||
    520                                              						(packet_length == 8 && command == AX_WRITE_112) ||
    521                                              						(packet_length == 9 && command == AX_WRITE_128) ||
    522                                              						(packet_length > 1 && packet_length <= 9 && command == AX_READ_RESPONSE) ||
    523                                              						(packet_length == 1 && command == AX_WRITE_RESPONSE) ||
    524                                              						(packet_length == 1 && command == AX_MODE_WRITE_RESPONSE) ||
    525                                              						(packet_length == 1 && command == AX_ERROR_RESPONSE) ||
    526                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_MISC_WRITE_TYPE) ||
    527                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_POSTED_MISC_WRITE_TYPE) ||
    528                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_MODE_READ_TYPE) ||
    529                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_READ_TYPE) ||
    530                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_FLOW_TYPE)
    531                                              		); }
    532                                              	constraint c_flit_delay {
    533                                              		soft flit_delay dist{0:/90, [1:8]:/8, [8:200]:/2  };
    534                                              	}
    535                                              	constraint c_error_status {
    536                                              		soft error_status == 0;
    537                                              	}
    538                                              	constraint c_data_invalid {
    539                                              		soft data_invalid == 0;
    540                                              	}
    541                                              	constraint c_pret {
    542                                              		(command == AX_PRET)-> forward_retry_pointer	==0;
    543                                              		(command == AX_PRET)-> sequence_number			==0;
    544                                              	}
    545                                              	constraint c_irtry{
    546                                              		(command == AX_IRTRY) 							-> start_retry 			!= clear_error_abort;
    547                                              		((command == AX_IRTRY)&&(start_retry)) 		->forward_retry_pointer == 1;
    548                                              		((command == AX_IRTRY)&&(clear_error_abort))	->forward_retry_pointer == 2;
    549                                              		(command == AX_IRTRY)							-> sequence_number		== 0;
    550                                              	}
    551                                              	constraint c_flow {
    552                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> tag == 0;
    553                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> cube_ID == 0;
    554                                              	}
    555                                              	function new (string name = "ax_packet");
    556                                              		super.new(name);
    557                                              	endfunction : new
    558                                                  function void post_randomize();
    559                                              		bit [127:0] rand_flit;
    560                                                      super.post_randomize();
    561                                              		if (packet_length > 9)
    562                                              			`uvm_fatal(get_type_name(),$psprintf("post_randomize packet_length = %0d",packet_length))
    563                                              		`uvm_info("AXI Packet queued",$psprintf("%0s packet_length = %0d",command.name(), packet_length), UVM_HIGH)
    564                                              		if (packet_length < 2)
    565                                              			return;
    566                                              		for (int i=0; i<packet_length-1; i++) begin
    567                                              			randomize_flit_successful : assert (std::randomize(rand_flit));
    568                                              			payload.push_back(rand_flit);
    569                                              		end
    570                                              		if ((command == AX_POSTED_DUAL_8B_ADDI)||
    571                                              			(command == AX_DUAL_8B_ADDI)) begin
    572                                              			payload[0] [63:32] = 32'b0;
    573                                              			payload[0][127:96] = 32'b0;
    574                                              		end
    575                                              		if ((command == AX_MODE_WRITE)|| (command == AX_MODE_READ)) begin
    576                                              			payload[0][127:32] = 96'b0;
    577                                              		end
    578                                                  endfunction
    579                                              	function ax_command_type get_command_type();
    580                                              		case(command & AX_TYPE_MASK)
    581                                              			AX_FLOW_TYPE:				return AX_FLOW_TYPE;
    582                                              			AX_READ_TYPE:				return AX_READ_TYPE;
    583                                              			AX_MODE_READ_TYPE:			return AX_MODE_READ_TYPE;
    584                                              			AX_POSTED_WRITE_TYPE:		return AX_POSTED_WRITE_TYPE;
    585                                              			AX_POSTED_MISC_WRITE_TYPE:	return AX_POSTED_MISC_WRITE_TYPE;
    586                                              			AX_WRITE_TYPE:				return AX_WRITE_TYPE;
    587                                              			AX_MISC_WRITE_TYPE:		return AX_MISC_WRITE_TYPE;
    588                                              			AX_RESPONSE_TYPE:			return AX_RESPONSE_TYPE;
    589                                              			default: uvm_report_fatal(get_type_name(), $psprintf("command with an illegal command type='h%0h!", command));
    590                                              		endcase
    591                                              	endfunction : get_command_type
    592                                              /*
    593                                              		The CRC algorithm used on the AX is the Koopman CRC-32K. This algorithm was
    594                                              		chosen for the AX because of its balance of coverage and ease of implementation. The
    595                                              		polynomial for this algorithm is:
    596                                              		x32 + x30 + x29 + x28 + x26 + x20 + x19 + x17 + x16 + x15 + x11 + x10 + x7 + x6 + x4 + x2 + x + 1
    597                                              		bit [31:0] polynomial = 33'b1_0111_0100_0001_1011_1000_1100_1101_0111;	// Normal
    598                                              		The CRC calculation operates on the LSB of the packet first. The packet CRC calculation
    599                                              		must insert 0s in place of the 32-bits representing the CRC field before generating or
    600                                              		checking the CRC. For example, when generating CRC for a packet, bits [63: 32] of the
    601                                              		Tail presented to the CRC generator should be all zeros. The output of the CRC generator
    602                                              		will have a 32-bit CRC value that will then be inserted in bits [63:32] of the Tail before
    603                                              		forwarding that FLIT of the packet. When checking CRC for a packet, the CRC field
    604                                              		should be removed from bits [63:32] of the Tail and replaced with 32-bits of zeros, then
    605                                              		presented to the CRC checker. The output of the CRC checker will have a 32-bit CRC
    606                                              		value that can be compared with the CRC value that was removed from the tail. If the two
    607                                              		compare, the CRC check indicates no bit failures within the packet.
    608                                              */
    609                                              	function bit [31:0] calculate_crc();
    610                                              		bit bitstream[];
    611                                              		packer_succeeded : assert (pack(bitstream) > 0);
    612                                              		return calc_crc(bitstream);
    613                                              	endfunction : calculate_crc
    614                                              	function bit [31:0] calc_crc(bit bitstream[]);
    615                                              		bit [32:0] polynomial = 33'h1741B8CD7; // Normal
    616                                              		bit [32:0] remainder = 33'h0;
    617                                              		for( int i=0; i < bitstream.size()-32; i++ ) begin	// without the CRC
    618                                              			remainder = {remainder[31:0], bitstream[i]};
    619                                              			if( remainder[32] ) begin
    620                                              				remainder = remainder ^ polynomial;
    621                                              			end
    622                                              		end
    623                                              		for( int i=0; i < 64; i++ ) begin	// zeroes for CRC and remainder
    624                                              			remainder = {remainder[31:0], 1'b0};
    625                                              			if( remainder[32] ) begin
    626                                              				remainder = remainder ^ polynomial;
    627                                              			end
    628                                              		end
    629                                              		return remainder[31:0];
    630                                              	endfunction : calc_crc
    631                                              	virtual function void do_pack(uvm_packer packer);
    632                                              		super.do_pack(packer);
    633                                              		packer.big_endian = 0;
    634                                              		// pack header half flit
    635                                              		case(command & AX_TYPE_MASK)
    636                                              			AX_FLOW_TYPE:
    637                                              				case (command)
    638                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    639                                              					AX_PRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    640                                              					AX_TRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    641                                              					AX_IRTRY:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    642                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal FLOW type='h%0h!", command));
    643                                              				endcase
    644                                              			AX_READ_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    645                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {cube_ID[2:0], 3'h0, 34'h0, tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    646                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    647                                              			AX_WRITE_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    648                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    649                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    650                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {22'h0, source_link_ID[2:0], 6'h0, return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    651                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal command type='h%0h!", command));
    652                                              		endcase
    653                                              		// Allow for errors when packet_length != duplicate_length
    654                                              		if ((packet_length == duplicate_length) && payload.size() + 1 != packet_length && command != AX_NULL)
    655                                              			uvm_report_fatal(get_type_name(), $psprintf("pack function size mismatch payload.size=%0d packet_length=%0d!", payload.size(), packet_length));
    656                                              		// pack payload
    657                                              		for( int i=0; i<payload.size(); i++ ) packer.pack_field ( payload[i], 128);
    658                                              		// pack tail half flit
    659                                              		case(command & AX_TYPE_MASK)
    660                                              			AX_FLOW_TYPE:
    661                                              				case (command)
    662                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    663                                              					AX_PRET:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 8'h0, return_retry_pointer[7:0]}, 64);
    664                                              					AX_TRET:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], 3'h0, 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    665                                              					AX_IRTRY:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 6'h0, clear_error_abort, start_retry, return_retry_pointer[7:0]}, 64);
    666                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal FLOW type='h%0h!", command));
    667                                              				endcase
    668                                              			AX_READ_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    669                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    670                                              			AX_WRITE_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    671                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    672                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    673                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    674                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    675                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal command type='h%0h!", command));
    676                                              		endcase
    677                                              	endfunction : do_pack
    678                                              	virtual function void do_unpack(uvm_packer packer);
    679                                              		bit [63:0]	header;
    680                                              		bit [63:0]	tail;
    681                                              		bit [31:0]	calculated_crc;
    682                                              		bit [21:0]	rsvd22;
    683                                              		bit [5:0]	rsvd6;
    684                                              		bit [4:0]	rsvd5;
    685                                              		bit [2:0]	rsvd3;
    686                                              		bit 		rsvd1;
    687                                              		bit bitstream[];
    688                                              		super.do_unpack(packer);
    689                                              		packer.big_endian = 0;
    690                                              		packer.get_bits(bitstream);
    691                                              		for (int i = 0; i <32; i++)begin
    692                                              			packet_crc[i] = bitstream[bitstream.size()-32 +i];
    693                                              		end
    694                                              		calculated_crc = calc_crc(bitstream);
    695                                              		// header
    696                                              		header = packer.unpack_field(64);
    697                                              		command[5:0] = header[5:0];//-- doppelt?
    698                                              		if (get_command_type != AX_RESPONSE_TYPE)
    699                                              			{cube_ID[2:0], rsvd3, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    700                                              		else
    701                                              			{rsvd22[21:0], source_link_ID[2:0], rsvd6[5:0], return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    702                                              		// Unpack should not be called with length errors
    703                                              		if (duplicate_length != packet_length || packet_length == 0)
    704                                              			`uvm_fatal(get_type_name(), $psprintf("do_unpack: length mismatch dln=%0d len=%0d cmd=%0d!", duplicate_length, packet_length, command));
    705                                              		// payload
    706                                              		for (int i = 0; i < packet_length-1; i++)
    707                                              			payload.push_back(packer.unpack_field(128));
    708                                              		// tail
    709                                              		tail = packer.unpack_field(64);
    710                                              		if (get_command_type != AX_RESPONSE_TYPE) 
    711                                              			{packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], rsvd5, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    712                                              		else
    713                                              			{packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    714                                              		start_retry			= (command == AX_IRTRY ? forward_retry_pointer[0] : 1'b0);
    715                                              		clear_error_abort	= (command == AX_IRTRY ? forward_retry_pointer[1] : 1'b0);
    716                                              		crc_error = 0;
    717                                              		poisoned = (packet_crc == ~calculated_crc) ? 1'b1 : 1'b0;
    718                                              		if (packet_crc != calculated_crc &&  !poisoned )
    719                                              		begin
    720                                              			crc_error = 1;
    721                                              		end
    722                                              	endfunction : do_unpack
    723                                              	virtual function bit compare_adaptive_packet(ax_packet rhs, uvm_comparer comparer);
    724                                              		string name_string;
    725                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    726                                              		compare_adaptive_packet &= comparer.compare_field("payload.size()", payload.size(), rhs.payload.size(), 64, UVM_DEC);
    727                                              		for (int i=0; i<packet_length; i++)
    728                                              		begin
    729                                              			if (!compare_adaptive_packet)
    730                                              				return 0;
    731                                              			$sformat(name_string, "payload[%0d]", i);
    732                                              			compare_adaptive_packet &= comparer.compare_field(name_string, payload[i], rhs.payload[i], 128, UVM_HEX);
    733                                              		end
    734                                              		compare_adaptive_packet &= comparer.compare_field("cube_ID", cube_ID, rhs.cube_ID, 64, UVM_DEC);
    735                                              		compare_adaptive_packet &= comparer.compare_field("address", address, rhs.address, 64, UVM_DEC);
    736                                              		compare_adaptive_packet &= comparer.compare_field("tag", tag, rhs.tag, 64, UVM_DEC);
    737                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    738                                              		compare_adaptive_packet &= comparer.compare_field("duplicate_length", duplicate_length, rhs.duplicate_length, 64, UVM_DEC);
    739                                              		compare_adaptive_packet &= comparer.compare_field("command", command, rhs.command, 64, UVM_DEC);
    740                                              		compare_adaptive_packet &= comparer.compare_field("return_token_count", return_token_count, rhs.return_token_count, 64, UVM_DEC);
    741                                              		compare_adaptive_packet &= comparer.compare_field("source_link_ID", source_link_ID, rhs.source_link_ID, 64, UVM_DEC);
    742                                              		compare_adaptive_packet &= comparer.compare_field("sequence_number", sequence_number, rhs.sequence_number, 64, UVM_DEC);
    743                                              		compare_adaptive_packet &= comparer.compare_field("forward_retry_pointer", forward_retry_pointer, rhs.forward_retry_pointer, 64, UVM_DEC);
    744                                              		compare_adaptive_packet &= comparer.compare_field("return_tag", return_tag, rhs.return_tag, 64, UVM_DEC);
    745                                              		compare_adaptive_packet &= comparer.compare_field("error_status", error_status, rhs.error_status, 64, UVM_DEC);
    746                                              		compare_adaptive_packet &= comparer.compare_field("data_invalid", data_invalid, rhs.data_invalid, 64, UVM_DEC);
    747                                              		compare_adaptive_packet &= comparer.compare_field("start_retry", start_retry, rhs.start_retry, 64, UVM_DEC);
    748                                              		compare_adaptive_packet &= comparer.compare_field("clear_error_abort", clear_error_abort, rhs.clear_error_abort, 64, UVM_DEC);
    749                                              	endfunction : compare_adaptive_packet
    750                                              endclass : ax_packet
    751                                              class axi4_stream_master_sequence extends uvm_sequence#(axi4_stream_valid_cycle);
    752                                              	`uvm_object_utils(axi4_stream_master_sequence)
    753                                              	rand int delay;
    754                                              	rand ax_packet response;
    755                                              	rand bit error_response;
    756                                                  event item_available;
    757                                              	constraint delay_c {
    758                                              		delay dist {0:=4, [0:9]:=8, [10:30]:=2, [31:100]:=1};
    759                                              	}
    760                                                  function new(string name = "");
    761                                                      super.new(name);
    762                                                  endfunction: new
    763                                                  task body();
    764                                                      axi4_stream_valid_cycle vc;
    765                                                      repeat(100) begin
    766                                                      vc = axi4_stream_valid_cycle::type_id::create(.name("vc"), .contxt(get_full_name()));
    767                                                      start_item(vc);
    768                                                          assert(vc.randomize());
    769                                                      finish_item(vc);
    770                                                      end
    771                                                  endtask : body
    772                                              endclass : axi4_stream_master_sequence
    773                                              //====================================================================================
    774                                              //------------------------------------------------------------------------------------
    775                                              //--------------------------------- UVM_DRIVERS
    776                                              //------------------------------------------------------------------------------------
    777                                              //====================================================================================
    778                                              // UVM_DRIVER : AXILITE_DRV [AXILITE]
    779                                              class axiLite_driver extends uvm_driver #(axiLite_transaction);
    780                                                  protected virtual axiLite_if axiLiteVif;
    781                                                  protected int     id;
    782                                                  `uvm_component_utils_begin(axiLite_driver)
    783                                                      `uvm_field_int(id, UVM_DEFAULT)
    784                                                  `uvm_component_utils_end
    785                                                  function new (string name, uvm_component parent);
    786                                                      super.new(name, parent);
    787                                                  endfunction
    788                                                  function void build_phase (uvm_phase phase);
    789                                                      super.build_phase(phase);
    790                                                      if (!uvm_config_db#(virtual axiLite_if)::get(this, "", "axiLiteVif", axiLiteVif))
    791                                                      `uvm_fatal("NOVIF", {"virtual interface must be set for: ",
    792                                                      get_full_name(), ".axiLiteVif"});
    793                                                  endfunction
    794                                                  virtual task run_phase (uvm_phase phase);
    795                                                      fork
    796                                                          get_and_drive();
    797                                                          reset_signals();
    798                                                      join
    799                                                  endtask: run_phase
    800                                                  virtual protected task get_and_drive();
    801                                                      forever begin
    802                                                          @(posedge axiLiteVif.ACLK);
    803                                                          if (axiLiteVif.ARESETN == 1'b0) begin
    804                                                              @(posedge axiLiteVif.ARESETN);
    805                                                              @(posedge axiLiteVif.ACLK);
    806                                                          end
    807                                                          seq_item_port.get_next_item(req);
    808                                                          //`uvm_info("DRV", req.convert2string(), UVM_LOW)
    809                                                          repeat(req.cycles) begin
    810                                                              @(posedge axiLiteVif.ACLK);
    811                                                          end
    812                                                          drive_transfer(req);
    813                                                          seq_item_port.item_done();
    814                                                      end
    815                                                  endtask: get_and_drive
    816                                                  virtual protected task reset_signals();
    817                                                      forever begin
    818                                                          @(negedge axiLiteVif.ARESETN);
    819                                                          axiLiteVif.AWADDR  <=  8'h0;
    820                                                          axiLiteVif.AWPROT  <=  3'h0;
    821                                                          axiLiteVif.AWVALID <=  1'b0;
    822                                                          axiLiteVif.WDATA   <= 32'h0;
    823                                                          axiLiteVif.WSTRB   <=  4'h0;
    824                                                          axiLiteVif.WVALID  <=  1'b0;
    825                                                          axiLiteVif.BREADY  <=  1'b1;
    826                                                          axiLiteVif.ARADDR  <=  8'h0;
    827                                                          axiLiteVif.ARPROT  <=  3'h0;
    828                                                          axiLiteVif.ARVALID <=  1'b0;
    829                                                          axiLiteVif.RREADY  <=  1'b1;
    830                                                      end
    831                                                  endtask: reset_signals
    832                                                  virtual protected task drive_transfer (axiLite_transaction aL_txn);
    833                                                      drive_address_phase(aL_txn);
    834                                                      drive_data_phase(aL_txn);
    835                                                  endtask: drive_transfer
    836                                                  virtual protected task drive_address_phase (axiLite_transaction aL_txn);
    837                                                      //`uvm_info("axiLite_master_driver", "drive_address_phase",UVM_HIGH)
    838                                                      case (aL_txn.reqWriteRead)
    839                                                          READ : drive_read_address_channel(aL_txn);
    840                                                          WRITE: drive_write_address_channel(aL_txn);
    841                                                      endcase
    842                                                  endtask: drive_address_phase
    843                                                  virtual protected task drive_data_phase (axiLite_transaction aL_txn);
    844                                                      bit[31:0] rw_data;
    845                                                      bit err;
    846                                                      rw_data = aL_txn.data;
    847                                                      case (aL_txn.reqWriteRead)
    848                                                      READ : drive_read_data_channel(rw_data, err);
    849                                                      WRITE: drive_write_data_channel(rw_data, err);
    850                                                      endcase    
    851                                                  endtask: drive_data_phase
    852                                                  virtual protected task drive_write_address_channel (axiLite_transaction aL_txn);
    853                                                      int axiLite_ctr;
    854                                                      axiLiteVif.AWADDR  <= {8'h0, aL_txn.addr};
    855                                                      axiLiteVif.AWPROT  <= 3'h0;
    856                                                      axiLiteVif.AWVALID <= 1'b1;
    857                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    858                                                          @(posedge axiLiteVif.ACLK);
    859                                                          if (axiLiteVif.AWREADY) break;
    860                                                      end
    861                                                      if (axiLite_ctr == 31) begin
    862                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    863                                                      end    
    864                                                      @(posedge axiLiteVif.ACLK);
    865                                                      // axiLiteVif.AWADDR  <= 8'h0;
    866                                                      // axiLiteVif.AWPROT  <= 3'h0;
    867                                                      // axiLiteVif.AWVALID <= 1'b0;    
    868                                                  endtask: drive_write_address_channel
    869                                                  virtual protected task drive_read_address_channel (axiLite_transaction aL_txn);
    870                                                      int axiLite_ctr;
    871                                                      axiLiteVif.ARADDR  <= {8'h0, aL_txn.addr};
    872                                                      axiLiteVif.ARPROT  <= 3'h0;
    873                                                      axiLiteVif.ARVALID <= 1'b1;
    874                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    875                                                          @(posedge axiLiteVif.ACLK);
    876                                                          if (axiLiteVif.ARREADY) break;
    877                                                      end
    878                                                      if (axiLite_ctr == 31) begin
    879                                                          `uvm_error("axiLite_master_driver","ARVALID timeout");
    880                                                      end
    881                                                      @(posedge axiLiteVif.ACLK);
    882                                                      axiLiteVif.ARADDR  <= 8'h0;
    883                                                      axiLiteVif.ARPROT  <= 3'h0;
    884                                                      axiLiteVif.ARVALID <= 1'b0;    
    885                                                  endtask: drive_read_address_channel
    886                                                  virtual protected task drive_write_data_channel (bit[31:0] data, output bit error);
    887                                                      int axiLite_ctr;
    888                                                      axiLiteVif.WDATA  <= data;
    889                                                      axiLiteVif.WSTRB  <= 4'hf;
    890                                                      axiLiteVif.WVALID <= 1'b1;
    891                                                      @(posedge axiLiteVif.ACLK);
    892                                                          for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    893                                                          @(posedge axiLiteVif.ACLK);
    894                                                          if (axiLiteVif.WREADY) 
    895                                                                  axiLiteVif.AWADDR  <= 8'h0;
    896                                                      axiLiteVif.AWPROT  <= 3'h0;
    897                                                      axiLiteVif.AWVALID <= 1'b0; 
    898                                                          break;
    899                                                      end
    900                                                      if (axiLite_ctr == 31) begin
    901                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    902                                                      end
    903                                                      @(posedge axiLiteVif.ACLK);
    904                                                      axiLiteVif.WDATA  <= 32'h0;
    905                                                      axiLiteVif.WSTRB  <= 4'h0;
    906                                                      axiLiteVif.WVALID <= 1'b0;
    907                                                      //wait for write response
    908                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    909                                                          @(posedge axiLiteVif.ACLK);
    910                                                          if (axiLiteVif.BVALID) break;
    911                                                      end
    912                                                      if (axiLite_ctr == 31) begin
    913                                                          `uvm_error("axiLite_master_driver","BVALID timeout");
    914                                                      end
    915                                                      else begin
    916                                                          if (axiLiteVif.BVALID == 1'b1 && axiLiteVif.BRESP != 2'h0)
    917                                                          `uvm_error("axiLite_master_driver","Received ERROR Write Response");
    918                                                          axiLiteVif.BREADY <= axiLiteVif.BVALID;
    919                                                       @(posedge axiLiteVif.ACLK);
    920                                                      end
    921                                                  endtask: drive_write_data_channel
    922                                                  // drive read data channel
    923                                                  virtual protected task drive_read_data_channel (output bit [31:0] data, output bit error);
    924                                                      int axiLite_ctr;
    925                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    926                                                          @(posedge axiLiteVif.ACLK);
    927                                                          if (axiLiteVif.RVALID) break;
    928                                                      end
    929                                                      data = axiLiteVif.RDATA;
    930                                                      if (axiLite_ctr == 31) begin
    931                                                          `uvm_error("axiLite_master_driver","RVALID timeout");
    932                                                      end
    933                                                      else begin
    934                                                      if (axiLiteVif.RVALID == 1'b1 && axiLiteVif.RRESP != 2'h0)
    935                                                          `uvm_error("axiLite_master_driver","Received ERROR Read Response");
    936                                                          axiLiteVif.RREADY <= axiLiteVif.RVALID;
    937                                                          @(posedge axiLiteVif.ACLK);
    938                                                      end
    939                                                  endtask: drive_read_data_channel
    940                                              endclass: axiLite_driver
    941                                              // UVM_DRIVER : TEMPLATE_DRIVER [TEMPLATE]
    942                                              class template_driver extends uvm_driver#(template_transaction);
    943                                                  `uvm_component_utils(template_driver)
    944                                                  virtual template_if templateVif;
    945                                                  function new(string name, uvm_component parent);
    946                                                      super.new(name, parent);
    947                                                  endfunction: new
    948                                                  function void build_phase(uvm_phase phase);
    949                                                      super.build_phase(phase);
    950                                                      void'(uvm_resource_db#(virtual template_if)::read_by_name(.scope("ifs"), .name("template_if"), .val(templateVif)));
    951                                                  endfunction: build_phase
    952                                                  task run_phase(uvm_phase phase);
    953                                                      drive();
    954                                                  endtask: run_phase
    955                                                  virtual task drive();
    956                                                      template_transaction tx;
    957                                                      integer counter = 0, state = 0;
    958                                                      templateVif.sig_ina = 0'b0;
    959                                                      templateVif.sig_inb = 0'b0;
    960                                                      templateVif.sig_en_i = 1'b0;
    961                                                      forever begin
    962                                                          if(counter==0)
    963                                                          begin
    964                                                              seq_item_port.get_next_item(tx);
    965                                                          end
    966                                                          @(posedge templateVif.sig_clock)
    967                                                          begin
    968                                                              if(counter==0)
    969                                                              begin
    970                                                                  templateVif.sig_en_i = 1'b1;
    971                                                                  state = 1;
    972                                                              end
    973                                                              if(counter==1)
    974                                                              begin
    975                                                                  templateVif.sig_en_i = 1'b0;
    976                                                              end
    977                                                              case(state)
    978                                                                  1: begin
    979                                                                      templateVif.sig_ina = tx.ina[1];
    980                                                                      templateVif.sig_inb = tx.inb[1];
    981                                                                      tx.ina = tx.ina << 1;
    982                                                                      tx.inb = tx.inb << 1;
    983                                                                      counter = counter + 1;
    984                                                                      if(counter==2) state = 2;
    985                                                                  end
    986                                                                  2: begin
    987                                                                      templateVif.sig_ina = 1'b0;
    988                                                                      templateVif.sig_inb = 1'b0;
    989                                                                      counter = counter + 1;
    990                                                                      if(counter==6)
    991                                                                      begin
    992                                                                          counter = 0;
    993                                                                          state = 0;
    994                                                                          seq_item_port.item_done();
    995                                                                      end
    996                                                                  end
    997                                                              endcase
    998                                                          end
    999                                                      end
    1000                                                 endtask: drive
    1001                                             endclass: template_driver
    1002                                             // UVM_DRIVER : RGB_DRIVER [RGB]
    1003                                             class rgb_driver#(parameter set_config cfg = par_1) extends uvm_driver#(rgb_transaction#(cfg));
    1004                                                 `uvm_component_param_utils(rgb_driver#(cfg))
    1005                                                 virtual rgb_if#(cfg) frame_vi;
    1006                                                 function new(string name, uvm_component parent);
    1007                                                     super.new(name, parent);
    1008                                                 endfunction: new
    1009                                                 function void build_phase(uvm_phase phase);
    1010                                                     super.build_phase(phase);
    1011                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name(.scope("ifs"),.name("rgb_if"),.val(frame_vi)));
    1012                                                 endfunction: build_phase
    1013                                                 task run_phase(uvm_phase phase);
    1014                                                     rgb_transaction#(cfg) frame_tx;
    1015                                                     forever begin
    1016                                                         @frame_vi.master_cb;
    1017                                                         seq_item_port.get_next_item(frame_tx);
    1018                                                         @frame_vi.master_cb;
    1019                                                         frame_vi.master_cb.iRed        <= frame_tx.iRed;
    1020                                                         frame_vi.master_cb.iGreen      <= frame_tx.iGreen;
    1021                                                         frame_vi.master_cb.iBlue       <= frame_tx.iBlue;
    1022                                                         frame_vi.master_cb.iX          <= frame_tx.iX;
    1023                                                         frame_vi.master_cb.iY          <= frame_tx.iY;
    1024                                                         frame_vi.master_cb.iPixelEn    <= frame_tx.iPixelEn;
    1025                                                         frame_vi.master_cb.iValid      <= frame_tx.iValid;
    1026                                                         frame_vi.master_cb.iEof        <= frame_tx.iEof;
    1027                                                         seq_item_port.item_done();
    1028                                                     end
    1029                                                 endtask: run_phase
    1030                                             endclass: rgb_driver
    1031                                             class axi4_stream_master_driver  extends uvm_driver #(axi4_stream_valid_cycle);
    1032                                                 `uvm_component_utils(axi4_stream_master_driver)
    1033                                                 	axi4_stream_config axi4_stream_cfg;
    1034                                                 virtual interface axi4_stream_if  vif;
    1035                                                 function new(string name, uvm_component parent);
    1036                                                     super.new(name, parent);
    1037                                                 endfunction: new
    1038                                                 function void build_phase(uvm_phase phase);
    1039                                                     super.build_phase(phase);
    1040                                                 endfunction : build_phase
    1041                                             	task run_phase(uvm_phase phase);
    1042                                             		super.run_phase(phase);
    1043                                             		forever begin
    1044                                             			if(vif.ARESET_N !== 1) begin
    1045                                             				vif.TVALID <= 0;
    1046                                             				//`uvm_info(get_type_name(),$psprintf("reset"), UVM_HIGH)
    1047                                             				@(posedge vif.ARESET_N);
    1048                                             			//	`uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_HIGH)
    1049                                             			end
    1050                                             			fork
    1051                                             				begin //-- Asynchronous reset
    1052                                             					@(negedge vif.ARESET_N);
    1053                                             				end
    1054                                             				begin
    1055                                             					drive_valid_cycles();
    1056                                             				end
    1057                                             			join_any
    1058                                             			disable fork;
    1059                                             		end
    1060                                             	endtask : run_phase
    1061                                             	task drive_valid_cycles();
    1062                                             		@(posedge vif.ACLK);
    1063                                             		forever begin
    1064                                             			axi4_stream_valid_cycle  vc;
    1065                                             			//-- Try next AXI4 item
    1066                                             			seq_item_port.try_next_item(vc);
    1067                                             			if( vc != null) begin
    1068                                             				//`uvm_info(get_type_name(),$psprintf("There is an item to sent"), UVM_MEDIUM)
    1069                                             				//`uvm_info(get_type_name(),$psprintf("send %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1070                                             				//-- Wait until delay
    1071                                             				repeat(vc.delay)
    1072                                             					@(posedge vif.ACLK);
    1073                                             				//-- Send AXI4 cycle
    1074                                             				vif.TDATA  <= vc.tdata;
    1075                                             				vif.TUSER  <= vc.tuser;
    1076                                             				vif.TVALID <= 1;
    1077                                             				@(posedge vif.ACLK)
    1078                                             				while(vif.TREADY == 0)
    1079                                             					@(posedge vif.ACLK);
    1080                                             				vif.TUSER  <= 0;
    1081                                             				vif.TDATA  <= 0;
    1082                                             				vif.TVALID <= 0;
    1083                                             				//`uvm_info(get_type_name(),$psprintf("send done: %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1084                                             				seq_item_port.item_done();
    1085                                             			end else //-- Else wait 1 cycle
    1086                                             				@(posedge vif.ACLK);
    1087                                             		end
    1088                                             	endtask : drive_valid_cycles
    1089                                             endclass : axi4_stream_master_driver
    1090                                             class axi4_stream_slave_driver  extends uvm_driver #(ax_packet);
    1091                                                 `uvm_component_utils(axi4_stream_slave_driver)
    1092                                             	virtual interface axi4_stream_if vif;
    1093                                             	rand int block_cycles;
    1094                                             	constraint c_block_cycles {
    1095                                             		soft block_cycles dist{0:/30,[1:5]:/41, [6:15]:/25, [16:10000]:/4};
    1096                                             	}
    1097                                                 function new(string name, uvm_component parent);
    1098                                                     super.new(name, parent);
    1099                                                 endfunction: new
    1100                                             	function void build_phase(uvm_phase phase);
    1101                                             		super.build_phase(phase);
    1102                                             	endfunction : build_phase
    1103                                                 task run_phase(uvm_phase phase);
    1104                                                     super.run_phase(phase);
    1105                                                     forever begin
    1106                                             			if(vif.ARESET_N !== 1) begin
    1107                                             				vif.TVALID <= 0;
    1108                                             				@(posedge vif.ARESET_N);
    1109                                             			end
    1110                                             			begin //-- Asynchronous reset
    1111                                             				@(negedge vif.ARESET_N);
    1112                                             			end
    1113                                             			begin
    1114                                             			@(posedge vif.ACLK);
    1115                                             			forever begin
    1116                                                             if (vif.TVALID)
    1117                                                                 randcase
    1118                                                                     3 : vif.TREADY <= 1;
    1119                                                                     1 : vif.TREADY <= 0;
    1120                                                                 endcase
    1121                                                             else 
    1122                                                                 randcase
    1123                                                                     1 : vif.TREADY <= 1;
    1124                                                                     1 : vif.TREADY <= 0;
    1125                                                                     1 : begin		//-- hold tready at least until tvalid is set
    1126                                                                     vif.TREADY <= 0;
    1127                                                                     void'(this.randomize());
    1128                                                                     while (vif.TVALID == 0)
    1129                                                                     @(posedge vif.ACLK);
    1130                                                                     repeat(block_cycles) @(posedge vif.ACLK); //-- wait 2 additional cycles
    1131                                                                     end
    1132                                                                 endcase
    1133                                             			end
    1134                                             			end
    1135                                                     end
    1136                                                 endtask : run_phase
    1137                                             endclass : axi4_stream_slave_driver
    1138                                             //====================================================================================
    1139                                             //------------------------------------------------------------------------------------
    1140                                             //--------------------------------- UVM_MONITORS
    1141                                             //------------------------------------------------------------------------------------
    1142                                             //====================================================================================
    1143                                             // UVM_MONITOR : AXILITE_MON [AXILITE]
    1144                                             class axiLite_monitor extends uvm_monitor;
    1145                                                 protected virtual   axiLite_if axiLiteVif;
    1146                                                 protected int       id;
    1147                                                 uvm_analysis_port #(axiLite_transaction) item_collected_port;
    1148                                                 uvm_analysis_port #(axiLite_transaction) dut_inputs_port; // analysis port for DUT inputs
    1149                                                 uvm_analysis_port #(axiLite_transaction) dut_outputs_port; // analysis port for DUT outputs
    1150                                                 protected axiLite_transaction aL_txn;
    1151                                                 `uvm_component_utils_begin(axiLite_monitor)
    1152                                                     `uvm_field_int(id, UVM_DEFAULT)
    1153                                                 `uvm_component_utils_end
    1154                                                 function new (string name, uvm_component parent);
    1155                                                     super.new(name, parent);
    1156                                                     aL_txn = new();
    1157                                                     item_collected_port = new("item_collected_port", this);
    1158                                                    // dut_inputs_port = new("dut_inputs_port", this); // construct the analysis port
    1159                                                     //dut_outputs_port = new("dut_outputs_port", this); // construct the analysis port
    1160                                                 endfunction
    1161                                                 function void build_phase (uvm_phase phase);
    1162                                                     super.build_phase(phase);
    1163                                                     if(!uvm_config_db#(virtual axiLite_if)::get(this, "", "axiLiteVif", axiLiteVif))
    1164                                                     `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(), ".axiLiteVif"});
    1165                                                     dut_inputs_port = new(.name("dut_inputs_port"),.parent(this));
    1166                                                     dut_outputs_port = new(.name("dut_outputs_port"),.parent(this));
    1167                                                 endfunction // build_phase
    1168                                                 virtual task run_phase (uvm_phase phase);
    1169                                                     fork
    1170                                                         collect_transactions();
    1171                                                     join
    1172                                                 endtask: run_phase
    1173                                                 virtual protected task collect_transactions();
    1174                                                     bit valid_txn = 0;
    1175                                                     forever begin
    1176                                                         axiLite_transaction tx_in,tx_out,tx_copy;
    1177                                                         tx_in       = axiLite_transaction::type_id::create("tx_in"); 
    1178                                                         tx_out      = axiLite_transaction::type_id::create("tx_out");
    1179                                                         aL_txn      = new();
    1180                                                         if (axiLiteVif.ARESETN == 'b0)
    1181                                                         @(posedge axiLiteVif.ARESETN);
    1182                                                             if (axiLiteVif.AWVALID == 'b1) begin
    1183                                                                 tx_in.WDATA = axiLiteVif.WDATA; 
    1184                                                                 aL_txn.reqWriteRead = WRITE;    
    1185                                                                 aL_txn.addr  = axiLiteVif.AWADDR[7:0];
    1186                                                                 @(posedge axiLiteVif.WVALID);
    1187                                                                 aL_txn.data  = axiLiteVif.WDATA;
    1188                                                                 @(negedge axiLiteVif.WVALID);
    1189                                                                 valid_txn = 1;
    1190                                                             end
    1191                                                         else if (axiLiteVif.ARVALID == 'b1) begin
    1192                                                             tx_out.RDATA = axiLiteVif.RDATA; 
    1193                                                             aL_txn.reqWriteRead = READ;    
    1194                                                             aL_txn.addr  = axiLiteVif.ARADDR[7:0];
    1195                                                             @(posedge axiLiteVif.RVALID);
    1196                                                             aL_txn.data  = axiLiteVif.RDATA;
    1197                                                             @(negedge axiLiteVif.RVALID);
    1198                                                             valid_txn = 1;
    1199                                                         end
    1200                                                         @(posedge axiLiteVif.ACLK);
    1201                                                         //aL_txn.data = axiLiteVif.data;
    1202                                                         //while (axiLiteVif.valid == 'b1) begin
    1203                                                         //@(posedge axiLiteVif.ACLK);
    1204                                                         //aL_txn.cycles++;
    1205                                                         //end
    1206                                                         //aL_txn.cycles--;
    1207                                                          //`uvm_info("axiLiteVif data", aL_txn.sprint(), UVM_LOW);
    1208                                                             if (valid_txn == 'b1 ) begin
    1209                                                                 //`uvm_info("MON", aL_txn.convert2string(), UVM_LOW) 
    1210                                                                 item_collected_port.write(aL_txn);
    1211                                                                 //item_collected_port.write(aL_txn);
    1212                                                             end
    1213                                                         dut_inputs_port.write(tx_in);  
    1214                                                         $cast(tx_copy, tx_out.clone());
    1215                                                         dut_outputs_port.write(tx_copy);             
    1216                                                         valid_txn = 0;
    1217                                                     end
    1218                                                 endtask: collect_transactions
    1219                                             endclass: axiLite_monitor
    1220                                             // UVM_MONITOR : TEMPLATE_MONITOR_AFTERTODUT [TEMPLATE]
    1221                                             //The second axi4_monitor, monitor_afterToDut, will get both inputs 
    1222                                             //and make a prediction of the expected result. 
    1223                                             //The scoreboard will get this predicted result as well and make a comparison between the two values.
    1224                                             class template_monitor_afterToDut extends uvm_monitor;
    1225                                                 `uvm_component_utils(template_monitor_afterToDut)
    1226                                                 uvm_analysis_port#(template_transaction) mon_ap_afterToDut;
    1227                                                 virtual template_if templateVif;
    1228                                                 template_transaction tx;
    1229                                                 //For coverage
    1230                                                 template_transaction sa_tx_cg;
    1231                                                 //Define coverpoints
    1232                                                 covergroup template_cg;
    1233                                                           ina_cp:     coverpoint sa_tx_cg.ina;
    1234                                                           inb_cp:     coverpoint sa_tx_cg.inb;
    1235                                                     cross ina_cp, inb_cp;
    1236                                                 endgroup: template_cg
    1237                                                 function new(string name, uvm_component parent);
    1238                                                     super.new(name, parent);
    1239                                                     template_cg = new;
    1240                                                 endfunction: new
    1241                                                 function void build_phase(uvm_phase phase);
    1242                                                     super.build_phase(phase);
    1243                                                     void'(uvm_resource_db#(virtual template_if)::read_by_name(.scope("ifs"), .name("template_if"), .val(templateVif)));
    1244                                                     mon_ap_afterToDut= new(.name("mon_ap_afterToDut"), .parent(this));
    1245                                                 endfunction: build_phase
    1246                                                 task run_phase(uvm_phase phase);
    1247                                                     integer counter_mon = 0, state = 0;
    1248                                                     tx = template_transaction::type_id::create
    1249                                                         (.name("tx"), .contxt(get_full_name()));
    1250                                                     forever begin
    1251                                                         @(posedge templateVif.sig_clock)
    1252                                                         begin
    1253                                                             if(templateVif.sig_en_i==1'b1)
    1254                                                             begin
    1255                                                                 state  = 1;
    1256                                                                 tx.ina = 2'b00;
    1257                                                                 tx.inb = 2'b00;
    1258                                                                 tx.out = 3'b000;
    1259                                                             end
    1260                                                             if(state==1)
    1261                                                             begin
    1262                                                                 tx.ina    = tx.ina << 1;
    1263                                                                 tx.inb    = tx.inb << 1;
    1264                                                                 tx.ina[0] = templateVif.sig_ina;
    1265                                                                 tx.inb[0] = templateVif.sig_inb;
    1266                                                                 counter_mon = counter_mon + 1;
    1267                                                                 if(counter_mon==2)
    1268                                                                 begin
    1269                                                                     state = 0;
    1270                                                                     counter_mon = 0;
    1271                                                                     //Predict the result
    1272                                                                     predictor();
    1273                                                                     sa_tx_cg = tx;
    1274                                                                     //Coverage
    1275                                                                     template_cg.sample();
    1276                                                                     //Send the transaction to the analysis port
    1277                                                                     mon_ap_afterToDut.write(tx);
    1278                                                                 end
    1279                                                             end
    1280                                                         end
    1281                                                     end
    1282                                                 endtask: run_phase
    1283                                                 virtual function void predictor();
    1284                                                     tx.out = tx.ina + tx.inb;//Predict out value
    1285                                                 endfunction: predictor
    1286                                             endclass: template_monitor_afterToDut
    1287                                             // UVM_MONITOR : TEMPLATE_MONITOR_BEFOREFROMDUT [TEMPLATE]
    1288                                             //monitor_beforeFromDut, will look solely for the output of the device 
    1289                                             //and it will pass the result to the scoreboard.
    1290                                             class template_monitor_beforeFromDut extends uvm_monitor;
    1291                                                 `uvm_component_utils(template_monitor_beforeFromDut)
    1292                                                 uvm_analysis_port#(template_transaction) mon_ap_beforeFromDut;
    1293                                                 virtual template_if templateVif;
    1294                                                 function new(string name, uvm_component parent);
    1295                                                     super.new(name, parent);
    1296                                                 endfunction: new
    1297                                                 function void build_phase(uvm_phase phase);
    1298                                                     super.build_phase(phase);
    1299                                                     void'(uvm_resource_db#(virtual template_if)::read_by_name
    1300                                                         (.scope("ifs"), .name("template_if"), .val(templateVif)));
    1301                                                     mon_ap_beforeFromDut = new(.name("mon_ap_beforeFromDut"), .parent(this));
    1302                                                 endfunction: build_phase
    1303                                                 task run_phase(uvm_phase phase);
    1304                                                     integer counter_mon = 0, state = 0;
    1305                                                     template_transaction tx;
    1306                                                     tx = template_transaction::type_id::create
    1307                                                         (.name("tx"), .contxt(get_full_name()));
    1308                                                     forever begin
    1309                                                         @(posedge templateVif.sig_clock)
    1310                                                         begin
    1311                                                             if(templateVif.sig_en_o==1'b1)begin
    1312                                                                 state = 3;
    1313                                                             end
    1314                                                             if(state==3)begin
    1315                                                                 tx.out = tx.out << 1;
    1316                                                                 counter_mon = counter_mon + 1;
    1317                                                                 if (counter_mon==3)begin
    1318                                                                     tx.out[0]=templateVif.sig_out;
    1319                                                                 end
    1320                                                                 if(counter_mon==4)begin
    1321                                                                     state       = 0;
    1322                                                                     counter_mon = 0;
    1323                                                                     //Send the transaction to the analysis port
    1324                                                                     mon_ap_beforeFromDut.write(tx);
    1325                                                                 end
    1326                                                             end
    1327                                                         end
    1328                                                     end
    1329                                                 endtask: run_phase
    1330                                             endclass: template_monitor_beforeFromDut
    1331                                             // UVM_MONITOR : RGB_MONITOR [RGB]
    1332                                             class rgb_monitor#(parameter set_config cfg = par_1) extends uvm_monitor;
    1333                                                 `uvm_component_param_utils(rgb_monitor#(cfg))
    1334                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1335                                                 int unsigned agent_id = 1;
    1336                                                 virtual rgb_if#(cfg) frame_vi;
    1337                                                 function new(string name, uvm_component parent);
    1338                                                     super.new(name, parent);
    1339                                                 endfunction: new
    1340                                                 function void build_phase(uvm_phase phase);
    1341                                                     super.build_phase(phase);
    1342                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name
    1343                                                     (.scope("ifs"),.name("rgb_if"),.val(frame_vi)));
    1344                                                     frame_ap = new(.name("frame_ap"),.parent(this));
    1345                                                 endfunction: build_phase
    1346                                                 task run_phase(uvm_phase phase);
    1347                                                 $display("Detected new frame_tx on interface #%d\n", agent_id);
    1348                                                     forever begin
    1349                                                         rgb_transaction#(cfg) frame_tx;
    1350                                                         @frame_vi.slave_cb;
    1351                                                         frame_tx               = rgb_transaction#(cfg)::type_id::create(.name("frame_tx"));
    1352                                                         frame_tx.iRed          = frame_vi.slave_cb.iRed;
    1353                                                         frame_tx.iGreen        = frame_vi.slave_cb.iGreen;
    1354                                                         frame_tx.iBlue         = frame_vi.slave_cb.iBlue;
    1355                                                         frame_tx.iPixelEn      = frame_vi.slave_cb.iPixelEn;
    1356                                                         frame_tx.iValid        = frame_vi.slave_cb.iValid;
    1357                                                         frame_tx.iEof          = frame_vi.slave_cb.iEof;
    1358                                                         frame_tx.iX            = frame_vi.slave_cb.iX;
    1359                                                         frame_tx.iY            = frame_vi.slave_cb.iY;
    1360                                                         frame_ap.write(frame_tx);
    1361                                                     end
    1362                                                 endtask: run_phase
    1363                                             endclass: rgb_monitor
    1364                                                 parameter DATA_BYTES = 16;
    1365                                             class ax_module_mon extends uvm_monitor;
    1366                                             	//-- Basic Module monitor
    1367                                             	ax_packet packet;
    1368                                             	covergroup ax_pkt_cg;
    1369                                             		option.per_instance = 1;
    1370                                             		AX_PACKET_LENGTH : coverpoint packet.packet_length{
    1371                                             			illegal_bins zero_flit_pkt = {0};
    1372                                             			bins pkt_length[] = {[1:9]};
    1373                                             		}
    1374                                             		AX_COMMAND: coverpoint packet.command {
    1375                                             			bins requests[] = {
    1376                                             				AX_WRITE_16,
    1377                                             				AX_WRITE_32,
    1378                                             				AX_WRITE_48,
    1379                                             				AX_WRITE_64,
    1380                                             				AX_WRITE_80,
    1381                                             				AX_WRITE_96,
    1382                                             				AX_WRITE_112,
    1383                                             				AX_WRITE_128,
    1384                                             				AX_MODE_WRITE,
    1385                                             				AX_BIT_WRITE,
    1386                                             				AX_DUAL_8B_ADDI,
    1387                                             				AX_SINGLE_16B_ADDI,
    1388                                             				AX_POSTED_WRITE_16,
    1389                                             				AX_POSTED_WRITE_32,
    1390                                             				AX_POSTED_WRITE_48,
    1391                                             				AX_POSTED_WRITE_64,
    1392                                             				AX_POSTED_WRITE_80,
    1393                                             				AX_POSTED_WRITE_96,
    1394                                             				AX_POSTED_WRITE_112,
    1395                                             				AX_POSTED_WRITE_128,
    1396                                             				AX_POSTED_BIT_WRIT,
    1397                                             				AX_POSTED_BIT_WRIT,
    1398                                             				AX_POSTED_DUAL_8B_ADDI,
    1399                                             				AX_POSTED_SINGLE_16B_ADDI,
    1400                                             				AX_MODE_READ,
    1401                                             				AX_READ_16,
    1402                                             				AX_READ_32,
    1403                                             				AX_READ_48,
    1404                                             				AX_READ_64,
    1405                                             				AX_READ_80,
    1406                                             				AX_READ_96,
    1407                                             				AX_READ_112, 
    1408                                             				AX_READ_128};
    1409                                             			bins response[] = {
    1410                                             				AX_READ_RESPONSE,
    1411                                             				AX_WRITE_RESPONSE,
    1412                                             				AX_MODE_READ_RESPONSE,
    1413                                             				AX_MODE_WRITE_RESPONSE,
    1414                                             				AX_ERROR_RESPONSE
    1415                                             			};
    1416                                             			illegal_bins n_used = default;
    1417                                             		}
    1418                                             		FLIT_DELAY: coverpoint packet.flit_delay{
    1419                                             			bins zero_delay = {0};
    1420                                             			bins small_delay = {[1:3]};
    1421                                             			bins big_delay = {[4:20]};
    1422                                             			bins huge_delay = {[21:$]};
    1423                                             		}
    1424                                             		FLIT_DELAY_COMMAND : cross AX_COMMAND, FLIT_DELAY;
    1425                                             	endgroup
    1426                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1427                                             	int req_rcvd = 0;
    1428                                             	int rsp_rcvd = 0;
    1429                                             	`uvm_component_utils(ax_module_mon)
    1430                                             	function new ( string name = "ax_module_mon", uvm_component parent );
    1431                                             		super.new(name, parent);
    1432                                             		item_collected_port = new("item_collected_port", this);
    1433                                             	endfunction : new
    1434                                             	function void build_phase(uvm_phase phase);
    1435                                             		super.build_phase(phase);
    1436                                             	endfunction : build_phase
    1437                                             endclass
    1438                                             class axi4_stream_monitor extends uvm_monitor;
    1439                                                 `uvm_component_utils(axi4_stream_monitor)
    1440                                                 virtual interface axi4_stream_if vif;
    1441                                                 uvm_analysis_port #(axi4_stream_valid_cycle)    item_collected_port;
    1442                                                 function new(string name, uvm_component parent);
    1443                                                     super.new(name, parent);
    1444                                                     item_collected_port = new("item_collected_port", this);
    1445                                                 endfunction: new
    1446                                                 function void build_phase(uvm_phase phase);
    1447                                                     super.build_phase(phase);
    1448                                                 endfunction : build_phase
    1449                                                 task run();
    1450                                                     axi4_stream_valid_cycle  vc;
    1451                                                     forever begin
    1452                                                         if (vif.ARESET_N !== 1)
    1453                                                         begin
    1454                                                             @(posedge vif.ARESET_N);
    1455                                                             `uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_LOW)
    1456                                                         end
    1457                                                         //fork
    1458                                                             begin //-- Asynchronous reset
    1459                                                                 @(negedge vif.ARESET_N);
    1460                                                             end
    1461                                                             forever begin
    1462                                                                 //-- At the positive edge of ACLK
    1463                                                                 @(posedge vif.ACLK);
    1464                                                                 //-- Capture valid bus cycles
    1465                                                                 vc = new();
    1466                                                                 if (vif.TVALID == 1 && vif.TREADY == 1) begin
    1467                                                                     vc.tuser     = vif.TUSER;
    1468                                                                     vc.tdata     = vif.TDATA;
    1469                                                                     item_collected_port.write(vc);
    1470                                                                     `uvm_info(get_type_name(),$psprintf("valid cycle tuser %0x tdata %0x", vc.tuser, vc.tdata), UVM_HIGH)
    1471                                                                 end
    1472                                                                 //-- used to detect the ax_pkt_delay between packets
    1473                                                                 if (vif.TVALID == 0) begin
    1474                                                                     vc.tuser    = 0;
    1475                                                                     vc.tdata    = {DATA_BYTES{16'b0}};;
    1476                                                                     item_collected_port.write(vc);
    1477                                                                 end
    1478                                                             end
    1479                                                         //join_any
    1480                                                         //disable fork;
    1481                                                     end
    1482                                                 endtask : run
    1483                                             endclass : axi4_stream_monitor
    1484                                             class axi4_stream_ax_monitor extends  ax_module_mon ;
    1485                                                 `uvm_component_utils(axi4_stream_ax_monitor)
    1486                                             	int FPW ;
    1487                                             	int HEADERS ;
    1488                                             	int TAILS ;
    1489                                             	int VALIDS ;
    1490                                             	int valids_per_cycle 		= 0;
    1491                                             	int current_packet_length 	= 0;
    1492                                             	bit request = 1;
    1493                                             	int flit_delay [$];
    1494                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1495                                             	uvm_analysis_imp #(axi4_stream_valid_cycle,axi4_stream_ax_monitor) axi4_port;
    1496                                             	int n_valids 				= 0;
    1497                                             	int headers_seen 	= 0;
    1498                                             	int tails_seen 	 	= 0;
    1499                                             	typedef bit [127:0] flit_t;
    1500                                             	flit_t flit_queue[$];
    1501                                             	int packets_per_cycle = 0;
    1502                                             	ax_packet packet_queue[$];
    1503                                             	//-- covergroup definition
    1504                                                 function new(string name, uvm_component parent);
    1505                                                     super.new(name, parent);
    1506                                                     axi4_port = new("axi4_port",this);
    1507                                                 endfunction: new
    1508                                             	function void build_phase(uvm_phase phase);
    1509                                             		super.build_phase(phase);
    1510                                             		FPW 	= DATA_BYTES/16;//-- convert to variables!
    1511                                             		HEADERS = FPW;
    1512                                             		TAILS 	= 2*FPW;
    1513                                             		VALIDS 	= 0;
    1514                                             	endfunction : build_phase
    1515                                             	//-- Stuff FLITs into a FIFO, separate control signals
    1516                                             	function void collect_flits(input axi4_stream_valid_cycle vc);
    1517                                             		//-- read tuser flags for valid flags
    1518                                             		flit_t tmp_flit;
    1519                                             		flit_t current_flit;
    1520                                             		packets_per_cycle = 0;
    1521                                             		valids_per_cycle =0;
    1522                                             		for (int i = 0; i<FPW; i++) begin //-- Check bitvector
    1523                                             		//-- Check if valid
    1524                                             			if (vc.tuser == 1) begin
    1525                                             				valids_per_cycle ++;
    1526                                             				//-- Write 2 flit queue
    1527                                             				for (int b=0; b<16; b++)
    1528                                             					tmp_flit[b] = vc.tdata[16*i+b];
    1529                                             				flit_queue.push_back(tmp_flit);
    1530                                             				if (vc.tuser == 1'b1) begin
    1531                                             					headers_seen++; //-- Complete ax_packets to assemble
    1532                                             					packets_per_cycle++;
    1533                                             					flit_delay.push_back(n_valids);
    1534                                             					n_valids = 0;
    1535                                             				end
    1536                                             				//-- Check if tail for complete ax packet
    1537                                             				if (vc.tuser == 1'b1) begin
    1538                                             					tails_seen++; //-- Complete ax_packets to assemble
    1539                                             					assert (n_valids == 0)
    1540                                             					else `uvm_fatal(get_type_name(), $psprintf("Non valid flits in pkt detected!"))
    1541                                             				end
    1542                                             				//-- Check complete ax packets
    1543                                             				assert (tails_seen<= headers_seen) 
    1544                                             				else  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1545                                             				assert (headers_seen <= tails_seen+1)
    1546                                             				else  `uvm_fatal(get_type_name(), $psprintf("Packet without Tail detected"))
    1547                                             			end
    1548                                             			else begin
    1549                                             				n_valids ++;
    1550                                             			end
    1551                                             		end
    1552                                             		if(|vc.tuser)
    1553                                             			`uvm_info(get_type_name(),$psprintf("%d header and %d tails available", headers_seen, tails_seen)  ,UVM_HIGH)
    1554                                             	endfunction : collect_flits
    1555                                             	//-- Use FLITs to form packets
    1556                                             	function void collect_packet();
    1557                                             		flit_t current_flit;
    1558                                             		bit bitstream[];
    1559                                             		//-- Assemble 1 ax packet
    1560                                             		flit_queue_underflow : assert (flit_queue.size() > 0);
    1561                                             		//-- First flit is always header
    1562                                             		current_flit = flit_queue.pop_front();
    1563                                             		no_length_mismatches_allowed : assert (current_flit[14:11] == current_flit[10:7]); 	//--check internal ax_packet length
    1564                                             		current_packet_length = current_flit[10:7];
    1565                                             		`uvm_info(get_type_name(),$psprintf("packet length %0d ", current_packet_length), UVM_HIGH)
    1566                                             		`uvm_info(get_type_name(),$psprintf("queue size %0d ", flit_queue.size()), UVM_HIGH)
    1567                                             		flit_queue_underflow2 : assert (flit_queue.size() >= current_packet_length - 1);		//--check check ax_packet complete received
    1568                                             		//-- pack flits 2 bitstream
    1569                                             		bitstream = new[current_packet_length*16];
    1570                                             		//-- Pack first flit
    1571                                             		for (int i=0; i<16; i=i+1)
    1572                                             			bitstream[i] = current_flit[i];
    1573                                             		//-- Get and pack the remaining flits
    1574                                             		for (int flit=1; flit < current_packet_length; flit ++) begin
    1575                                             			current_flit = flit_queue.pop_front();
    1576                                             			`uvm_info(get_type_name(),$psprintf("pop flit %0d (%0x)", flit, current_flit), UVM_HIGH)
    1577                                             			for (int i=0; i<16; i=i+1) begin
    1578                                             				bitstream[flit*16+i] = current_flit[i];
    1579                                             			end
    1580                                             		end
    1581                                             		packet = ax_packet::type_id::create("packet", this);
    1582                                             		void'(packet.unpack(bitstream));
    1583                                             		packet.flit_delay = flit_delay.pop_front();
    1584                                             		ax_pkt_cg.sample(); 
    1585                                             		//-- assembled a packet
    1586                                             		headers_seen--;
    1587                                             		tails_seen--; 
    1588                                             		if (packet == null) begin
    1589                                             		  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1590                                             		end
    1591                                             		packet_queue.push_back(packet);
    1592                                             		if(packet.get_command_type() == AX_RESPONSE_TYPE)begin
    1593                                             		`uvm_info("RESPONSE collected",$psprintf("Rsp %0d : %s",rsp_rcvd, packet.command.name()), UVM_LOW)
    1594                                             		rsp_rcvd++;
    1595                                             		end else begin
    1596                                             		`uvm_info("REQUEST collected",$psprintf("Req %0d : %s",req_rcvd, packet.command.name()), UVM_LOW)
    1597                                             		req_rcvd++;
    1598                                             		end
    1599                                             		`uvm_info("AXI4 to AX Monitor",$psprintf("\n%s", packet.sprint()), UVM_HIGH)
    1600                                             	endfunction : collect_packet
    1601                                             	function void write(input axi4_stream_valid_cycle vc);
    1602                                             		ax_packet packet;
    1603                                             		collect_flits(vc);
    1604                                             		//`uvm_info(get_type_name(),$psprintf("got %0d tails and %0d flits",tails_seen, flit_queue.size() ), UVM_HIGH)
    1605                                             		//-- Convert flit_queue to ax_packets
    1606                                             		while (tails_seen >0) begin
    1607                                             			collect_packet();		
    1608                                             		end
    1609                                             		//-- If flit queue is not empty -> ax packet striped over 2 axi cycles
    1610                                             		while (packet_queue.size()>0) begin
    1611                                             			packet = packet_queue.pop_front();
    1612                                             			//if (packet.command != AX_ERROR_RESPONSE)
    1613                                             				item_collected_port.write(packet);
    1614                                             		end
    1615                                             	endfunction
    1616                                             	function void check_phase(uvm_phase phase);
    1617                                             		if (flit_queue.size() >0)
    1618                                             			`uvm_fatal(get_type_name(),$psprintf("flit_queue is not empty: %0d", flit_queue.size()))
    1619                                             	endfunction : check_phase
    1620                                             endclass : axi4_stream_ax_monitor
    1621                                             //====================================================================================
    1622                                             //------------------------------------------------------------------------------------
    1623                                             //--------------------------------- UVM_AGENTS
    1624                                             //------------------------------------------------------------------------------------
    1625                                             //====================================================================================
    1626                                             // UVM_AGENT : AXILITE_AGT [AXILITE]
    1627                                             class axiLite_agent extends uvm_agent;
    1628                                                 `uvm_component_utils(axiLite_agent)
    1629                                                 uvm_analysis_port#(axiLite_transaction) item_collected_port;
    1630                                                 axiLite_sequencer       aL_sqr;
    1631                                                 axiLite_driver          aL_drv;
    1632                                                 axiLite_monitor         aL_mon;
    1633                                                 function new (string name, uvm_component parent);
    1634                                                     super.new(name, parent);
    1635                                                 endfunction
    1636                                                 function void build_phase(uvm_phase phase);
    1637                                                     super.build_phase(phase);
    1638                                                     item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1639                                                     aL_mon                 = axiLite_monitor::type_id::create("aL_mon", this);
    1640                                                     if (get_is_active() == UVM_ACTIVE) begin
    1641                                                         aL_sqr = axiLite_sequencer::type_id::create("aL_sqr", this);
    1642                                                         aL_drv = axiLite_driver::type_id::create("aL_drv", this);
    1643                                                     end
    1644                                                 endfunction
    1645                                                 function void connect_phase(uvm_phase phase);
    1646                                                     if (get_is_active() == UVM_ACTIVE) begin
    1647                                                         aL_drv.seq_item_port.connect(aL_sqr.seq_item_export);
    1648                                                         aL_mon.item_collected_port.connect(item_collected_port);
    1649                                                     end
    1650                                                 endfunction
    1651                                             endclass: axiLite_agent
    1652                                             // UVM_AGENT : RGB_AGENT [RGB]
    1653                                             class rgb_agent#(parameter set_config cfg = par_1) extends uvm_agent;
    1654                                                 `uvm_component_param_utils(rgb_agent#(cfg))
    1655                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1656                                                 rgb_sequencer   #(cfg)               frame_seqr;
    1657                                                 rgb_driver      #(cfg)               frame_drvr;
    1658                                                 rgb_monitor     #(cfg)               frame_mon;
    1659                                                 function new(string name, uvm_component parent);
    1660                                                     super.new(name, parent);
    1661                                                 endfunction: new
    1662                                                 function void build_phase(uvm_phase phase);
    1663                                                     super.build_phase(phase);
    1664                                                     frame_ap    = new(.name("frame_ap"),.parent(this));
    1665                                                     frame_seqr = rgb_sequencer#(cfg)  ::type_id::create(.name("frame_seqr"),.parent(this));
    1666                                                     frame_drvr = rgb_driver   #(cfg)  ::type_id::create(.name("frame_drvr"),.parent(this));
    1667                                                     frame_mon  = rgb_monitor  #(cfg)  ::type_id::create(.name("frame_mon"),.parent(this));
    1668                                                 endfunction: build_phase
    1669                                                 function void connect_phase(uvm_phase phase);
    1670                                                     super.connect_phase(phase);
    1671                                                     frame_drvr.seq_item_port.connect(frame_seqr.seq_item_export);
    1672                                                     frame_mon.frame_ap.connect(frame_ap);
    1673                                                 endfunction: connect_phase
    1674                                             endclass: rgb_agent
    1675                                             // UVM_AGENT : TEMPLATE_AGENT [TEMPLATE]
    1676                                             class template_agent extends uvm_agent;
    1677                                                 `uvm_component_utils(template_agent)
    1678                                                 uvm_analysis_port#(template_transaction) agent_ap_beforeFromDut;
    1679                                                 uvm_analysis_port#(template_transaction) agent_ap_afterToDut;
    1680                                                 template_sequencer                       sa_seqr;
    1681                                                 template_driver                          sa_drvr;
    1682                                                 template_monitor_beforeFromDut           sa_mon_beforeFromDut;
    1683                                                 template_monitor_afterToDut              sa_mon_afterToDut;
    1684                                                 function new(string name, uvm_component parent);
    1685                                                     super.new(name, parent);
    1686                                                 endfunction: new
    1687                                                 function void build_phase(uvm_phase phase);
    1688                                                     super.build_phase(phase);
    1689                                                     agent_ap_beforeFromDut      = new(.name("agent_ap_beforeFromDut"), .parent(this));
    1690                                                     agent_ap_afterToDut         = new(.name("agent_ap_afterToDut"), .parent(this));
    1691                                                     sa_seqr                     = template_sequencer::type_id::create(.name("sa_seqr"), .parent(this));
    1692                                                     sa_drvr                     = template_driver::type_id::create(.name("sa_drvr"), .parent(this));
    1693                                                     sa_mon_beforeFromDut        = template_monitor_beforeFromDut::type_id::create(.name("sa_mon_beforeFromDut"), .parent(this));
    1694                                                     sa_mon_afterToDut           = template_monitor_afterToDut::type_id::create(.name("sa_mon_afterToDut"), .parent(this));
    1695                                                 endfunction: build_phase
    1696                                                 function void connect_phase(uvm_phase phase);
    1697                                                     super.connect_phase(phase);
    1698                                                     sa_drvr.seq_item_port.connect(sa_seqr.seq_item_export);
    1699                                                     sa_mon_beforeFromDut.mon_ap_beforeFromDut.connect(agent_ap_beforeFromDut);
    1700                                                     sa_mon_afterToDut.mon_ap_afterToDut.connect(agent_ap_afterToDut);
    1701                                                 endfunction: connect_phase
    1702                                             endclass: template_agent
    1703                                             class axi4_stream_master_agent extends uvm_agent;
    1704                                                 `uvm_component_utils(axi4_stream_master_agent)
    1705                                                 axi4_stream_config                  axi4_stream_master_cfg;
    1706                                                 axi4_stream_master_driver           axi4_master_driver;
    1707                                                 axi4_stream_master_sequencer        axi_sequencer;
    1708                                                 //axi4_stream_monitor                 axi4_monitor;
    1709                                                 function new(string name, uvm_component parent);
    1710                                                     super.new(name, parent);
    1711                                                 endfunction: new
    1712                                                 function void build_phase(uvm_phase phase);
    1713                                                     super.build_phase(phase);
    1714                                                     if (! uvm_config_db#(axi4_stream_config)::get(
    1715                                                     .cntxt(this),.inst_name (""),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_master_cfg))) begin
    1716                                                     `uvm_error("axi4_stream_master_agent", "axi4_stream_master_cfg not found")
    1717                                                     end
    1718                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1719                                                         axi_sequencer = axi4_stream_master_sequencer    ::type_id::create(.name("axi_sequencer"),.parent(this));
    1720                                                         axi4_master_driver = axi4_stream_master_driver  ::type_id::create(.name("axi4_master_driver"),.parent(this));
    1721                                                     end
    1722                                                     //axi4_monitor = axi4_stream_monitor::type_id::create(.name("axi4_monitor"),.parent(this));
    1723                                                         endfunction: build_phase
    1724                                                 function void connect_phase(uvm_phase phase);
    1725                                                     super.connect_phase(phase);
    1726                                                     //axi4_monitor.vif    = axi4_stream_master_cfg.vif;
    1727                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1728                                                         axi4_master_driver.seq_item_port.connect(axi_sequencer.seq_item_export);
    1729                                                         axi4_master_driver.vif = axi4_stream_master_cfg.vif;
    1730                                                     end
    1731                                                 endfunction: connect_phase
    1732                                             endclass : axi4_stream_master_agent
    1733                                             class axi4_stream_slave_agent extends uvm_agent;
    1734                                                 `uvm_component_utils(axi4_stream_slave_agent)
    1735                                                 axi4_stream_config                  axi4_stream_slave_cfg;
    1736                                                 axi4_stream_slave_driver            axi4_slave_driver;
    1737                                                 function new(string name, uvm_component parent);
    1738                                                     super.new(name, parent);
    1739                                                 endfunction: new
    1740                                                 function void build_phase(uvm_phase phase);
    1741                                                     super.build_phase(phase);
    1742                                                     if (! uvm_config_db#(axi4_stream_config)::get(.cntxt(this),.inst_name (""),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_slave_cfg))) begin
    1743                                                     `uvm_error("axi4_stream_slave_agent", "axi4_stream_slave_cfg not found")
    1744                                                     end
    1745                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1746                                                         axi4_slave_driver = axi4_stream_slave_driver         ::type_id::create(.name("axi4_slave_driver"),.parent(this));
    1747                                                     end
    1748                                                 endfunction: build_phase
    1749                                                 function void connect_phase(uvm_phase phase);
    1750                                                     super.connect_phase(phase);
    1751                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1752                                                         axi4_slave_driver.vif = axi4_stream_slave_cfg.vif;
    1753                                                     end
    1754                                                 endfunction: connect_phase
    1755                                             endclass : axi4_stream_slave_agent
    1756                                             //====================================================================================
    1757                                             //------------------------------------------------------------------------------------
    1758                                             //--------------------------------- UVM_SUBSCRIBERS
    1759                                             //------------------------------------------------------------------------------------
    1760                                             //====================================================================================
    1761                                             // UVM_SUBSCRIBER : AXILITE_FC_SUBSCRIBER [AXILITE]
    1762                                             class axiLite_fc_subscriber extends uvm_subscriber#(axiLite_transaction);
    1763                                                 `uvm_component_utils(axiLite_fc_subscriber)
    1764                                                 axiLite_transaction aL_txn;
    1765                                                 covergroup aL_cg;
    1766                                                     WDATA_cp:            coverpoint aL_txn.WDATA;
    1767                                                     AWADDR_cp:           coverpoint aL_txn.RDATA;
    1768                                                     // cross WDATA_cp, AWADDR_cp;
    1769                                                 endgroup: aL_cg
    1770                                                 function new(string name, uvm_component parent);
    1771                                                     super.new(name, parent);
    1772                                                     aL_cg = new;
    1773                                                 endfunction: new
    1774                                                 function void write(axiLite_transaction t);
    1775                                                     aL_txn = t;
    1776                                                     aL_cg.sample();
    1777                                                 endfunction: write
    1778                                             endclass: axiLite_fc_subscriber
    1779                                             // UVM_SUBSCRIBER : RGB_FC_SUBSCRIBER [RGB]
    1780                                             //The functional coverage subscriber (fc_sucbscriber) identifies 
    1781                                             //the generated frame_tx. 
    1782                                             //The rgb_transaction sent from the axi4_monitor is sampled by the write function.
    1783                                             class rgb_fc_subscriber extends uvm_subscriber#(rgb_transaction);
    1784                                                 `uvm_component_utils(rgb_fc_subscriber)
    1785                                                 rgb_transaction frame_tx;
    1786                                                 covergroup rgb_cg;
    1787                                                     iRed_cp:            coverpoint frame_tx.iRed;
    1788                                                     iGreen_cp:          coverpoint frame_tx.iGreen;
    1789                                                     iBlue_cp:           coverpoint frame_tx.iBlue;
    1790                                                     iPixelEn_cp:        coverpoint frame_tx.iPixelEn;
    1791                                                     iValid_cp:          coverpoint frame_tx.iValid;
    1792                                                     iEof_cp:            coverpoint frame_tx.iEof;
    1793                                                     iX_cp:              coverpoint frame_tx.iX;
    1794                                                     iY_cp:              coverpoint frame_tx.iY;
    1795                                                     cross iRed_cp, iEof_cp;
    1796                                                 endgroup: rgb_cg
    1797                                                 function new(string name, uvm_component parent);
    1798                                                     super.new(name, parent);
    1799                                                     rgb_cg = new;
    1800                                                 endfunction: new
    1801                                                 function void write(rgb_transaction t);
    1802                                                     frame_tx = t;
    1803                                                     rgb_cg.sample();
    1804                                                 endfunction: write
    1805                                             endclass: rgb_fc_subscriber
    1806                                             typedef class rgb_scoreboard;
    1807                                             // UVM_SUBSCRIBER : RGB_SB_SUBSCRIBER [RGB]
    1808                                             class rgb_sb_subscriber extends uvm_subscriber#(rgb_transaction);
    1809                                                 `uvm_component_utils(rgb_sb_subscriber)
    1810                                                 function new(string name, uvm_component parent);
    1811                                                     super.new(name, parent);
    1812                                                 endfunction: new
    1813                                                 function void write(rgb_transaction t);
    1814                                                     rgb_scoreboard frame_sb;
    1815                                                     $cast(frame_sb, m_parent);
    1816                                                     frame_sb.check_rgb_taste(t);
    1817                                                 endfunction: write
    1818                                             endclass: rgb_sb_subscriber
    1819                                             //====================================================================================
    1820                                             //------------------------------------------------------------------------------------
    1821                                             //--------------------------------- UVM_SCORECARDS
    1822                                             //------------------------------------------------------------------------------------
    1823                                             //====================================================================================
    1824                                             // UVM_SCORECARD : RGB_SCOREBOARD [RGB]
    1825                                             class rgb_scoreboard extends uvm_scoreboard;
    1826                                                 `uvm_component_utils(rgb_scoreboard)
    1827                                                 uvm_analysis_export#(rgb_transaction)    frame_analysis_export;
    1828                                                 local rgb_sb_subscriber                  frame_sb_sub;
    1829                                                 function new(string name, uvm_component parent);
    1830                                                     super.new(name, parent);
    1831                                                 endfunction: new
    1832                                                 function void build_phase(uvm_phase phase);
    1833                                                     super.build_phase(phase);
    1834                                                     frame_analysis_export = new(.name("frame_analysis_export"),.parent(this));
    1835                                                     frame_sb_sub = rgb_sb_subscriber::type_id::create(.name("frame_sb_sub"),.parent(this));
    1836                                                 endfunction: build_phase
    1837                                                 function void connect_phase(uvm_phase phase);
    1838                                                     super.connect_phase(phase);
    1839                                                     frame_analysis_export.connect(frame_sb_sub.analysis_export);
    1840                                                 endfunction: connect_phase
    1841                                                 virtual function void check_rgb_taste(rgb_transaction frame_tx);
    1842                                                     uvm_table_printer p = new;
    1843                                                 endfunction: check_rgb_taste
    1844                                             endclass: rgb_scoreboard
    1845                                             // UVM_SCORECARD : TEMPLATE_SCOREBOARD [TEMPLATE]
    1846                                             class template_scoreboard extends uvm_scoreboard;
    1847                                                 `uvm_component_utils(template_scoreboard)
    1848                                                 uvm_analysis_export #(template_transaction)     sb_export_beforeFromDut;
    1849                                                 uvm_analysis_export #(template_transaction)     sb_export_afterToDut;
    1850                                                 uvm_tlm_analysis_fifo #(template_transaction)   before_fifo;
    1851                                                 uvm_tlm_analysis_fifo #(template_transaction)   after_fifo;
    1852                                                 template_transaction transaction_beforeFromDut;
    1853                                                 template_transaction transaction_afterToDut;
    1854                                                 function new(string name, uvm_component parent);
    1855                                                     super.new(name, parent);
    1856                                                     transaction_beforeFromDut       = new("transaction_beforeFromDut");
    1857                                                     transaction_afterToDut          = new("transaction_afterToDut");
    1858                                                 endfunction: new
    1859                                                 function void build_phase(uvm_phase phase);
    1860                                                     super.build_phase(phase);
    1861                                                     sb_export_beforeFromDut         = new("sb_export_beforeFromDut", this);
    1862                                                     sb_export_afterToDut            = new("sb_export_afterToDut", this);
    1863                                                        before_fifo                  = new("before_fifo", this);
    1864                                                     after_fifo                      = new("after_fifo", this);
    1865                                                 endfunction: build_phase
    1866                                                 function void connect_phase(uvm_phase phase);
    1867                                                     sb_export_beforeFromDut.connect(before_fifo.analysis_export);
    1868                                                     sb_export_afterToDut.connect(after_fifo.analysis_export);
    1869                                                 endfunction: connect_phase
    1870                                                 task run();
    1871                                                     forever begin
    1872                                                         before_fifo.get(transaction_beforeFromDut);
    1873                                                         after_fifo.get(transaction_afterToDut);
    1874                                                         compare();
    1875                                                     end
    1876                                                 endtask: run
    1877                                                 // function string convert2string();
    1878                                                     // return $sformatf("addr");
    1879                                                 // endfunction
    1880                                                 virtual function void compare();
    1881                                                 //`uvm_info("FROMDUT", transaction_beforeFromDut.sprint(), UVM_LOW);
    1882                                                 //`uvm_info("TODUT", transaction_afterToDut.sprint(), UVM_LOW);
    1883                                                     if(transaction_beforeFromDut.out == transaction_afterToDut.out) begin
    1884                                                         `uvm_info("compare", {"Test: OK!"}, UVM_LOW);
    1885                                                     end else begin
    1886                                                         `uvm_info("compare", {"Test: Fail!"}, UVM_LOW);
    1887                                                     end
    1888                                                 endfunction: compare
    1889                                             endclass: template_scoreboard
    1890                                             `uvm_analysis_imp_decl(_beforeFromDut)
    1891                                             `uvm_analysis_imp_decl(_afterToDut)
    1892                                             parameter OPEN_RSP_MODE = 1;
    1893                                             //====================================================================================
    1894                                             //------------------------------------------------------------------------------------
    1895                                             //--------------------------------- UVM_ENVS
    1896                                             //------------------------------------------------------------------------------------
    1897                                             //====================================================================================
    1898                                             // UVM_ENV : TEMPLATE_ENV
    1899                                             class template_env extends uvm_env;
    1900                                                 `uvm_component_utils(template_env)
    1901                                                 protected virtual interface axiLite_if axiLiteVif;
    1902                                                 template_agent              sa_agent;       //[TEMPLATE]
    1903                                                 template_scoreboard         sa_sb;          //[TEMPLATE]
    1904                                                 axiLite_agent               aL_agt;         //[AXILITE]
    1905                                                 axiLite_fc_subscriber       aL_fc_sub;      //[AXILITE]
    1906                                                 rgb_agent#(par_1)           frame_agent;
    1907                                                 rgb_fc_subscriber           frame_fc_sub;   //[RGB]
    1908                                                 rgb_scoreboard              frame_sb;       //[RGB]
    1909                                                 function new(string name, uvm_component parent);
    1910                                                     super.new(name, parent);
    1911                                                 endfunction: new
    1912                                                 function void build_phase(uvm_phase phase);
    1913                                                     super.build_phase(phase);
    1914                                                     sa_agent        = template_agent            ::type_id::create(.name("sa_agent"), .parent(this));
    1915                                                     sa_sb           = template_scoreboard       ::type_id::create(.name("sa_sb"), .parent(this));
    1916                                                     frame_agent     = rgb_agent#(par_1)         ::type_id::create(.name("frame_agent"),.parent(this));
    1917                                                     frame_fc_sub    = rgb_fc_subscriber         ::type_id::create(.name("frame_fc_sub"),.parent(this));
    1918                                                     frame_sb        = rgb_scoreboard            ::type_id::create(.name("frame_sb"),.parent(this));
    1919                                                     if (!uvm_config_db#(virtual axiLite_if)::get(this, "", "axiLiteVif", axiLiteVif))
    1920                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axiLiteVif"});
    1921                                                     aL_agt          = axiLite_agent::type_id::create("aL_agt", this);
    1922                                                     if (!uvm_config_db#(virtual axiLite_if)::get(this, "", "axiLiteVif", axiLiteVif))
    1923                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axiLiteVif"});
    1924                                                     aL_fc_sub       = axiLite_fc_subscriber::type_id::create("aL_fc_sub", this);
    1925                                                 endfunction: build_phase
    1926                                                 function void connect_phase(uvm_phase phase);
    1927                                                     super.connect_phase(phase);
    1928                                                     sa_agent.agent_ap_beforeFromDut.connect(sa_sb.sb_export_beforeFromDut);
    1929                                                     sa_agent.agent_ap_afterToDut.connect(sa_sb.sb_export_afterToDut);
    1930                                                     aL_agt.item_collected_port.connect(aL_fc_sub.analysis_export);
    1931                                                     frame_agent.frame_ap.connect(frame_fc_sub.analysis_export);
    1932                                                     frame_agent.frame_ap.connect(frame_sb.frame_analysis_export);
    1933                                                 endfunction: connect_phase
    1934                                             endclass: template_env
    1935                                             class axi4_stream_env extends uvm_env;
    1936                                                 axi4_stream_agents_config   axi4_stream_cfg;
    1937                                             	axi4_stream_config          axi4_stream_slave_cfg;
    1938                                                 axi4_stream_config          axi4_stream_master_cfg;
    1939                                                 axi4_stream_config          axi4_stream_monitor_cfg;
    1940                                                 axi4_stream_master_agent    axi4_stream_master_agt;
    1941                                                 axi4_stream_slave_agent     axi4_stream_slave_agt;
    1942                                             	axi4_stream_monitor 		monitor;
    1943                                             	axi4_stream_ax_monitor 		axi4_req;
    1944                                                 int id;
    1945                                                 `uvm_component_utils_begin(axi4_stream_env)
    1946                                                     `uvm_field_int(id, UVM_DEFAULT)
    1947                                             		`uvm_field_object(axi4_stream_cfg, UVM_DEFAULT)
    1948                                             		`uvm_field_object(axi4_stream_master_agt, UVM_DEFAULT)
    1949                                             		`uvm_field_object(axi4_stream_slave_agt, UVM_DEFAULT)
    1950                                             		`uvm_field_object(monitor, UVM_DEFAULT)
    1951                                             		`uvm_field_object(axi4_req, UVM_DEFAULT)
    1952                                                 `uvm_component_utils_end
    1953                                                     uvm_analysis_port#(axi4_stream_ax_monitor) item_collected_port;
    1954                                                 function new(string name, uvm_component parent);
    1955                                                     super.new(name, parent);
    1956                                                 endfunction: new
    1957                                                 function void build_phase(uvm_phase phase);
    1958                                                     super.build_phase(phase);
    1959                                                             item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1960                                                     if (!uvm_config_db#(axi4_stream_agents_config)::get(.cntxt(this),.inst_name(""),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg)))begin
    1961                                                         `uvm_error("axi4_stream_agents_config", "axi4_stream_cfg not found")
    1962                                                     end
    1963                                                     if (axi4_stream_cfg.has_axi4_agent1) begin
    1964                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_master_agt"),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1965                                                         axi4_stream_master_agt=axi4_stream_master_agent::type_id::create(.name("axi4_stream_master_agt"),.parent(this));
    1966                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_slave_agt"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1967                                                         axi4_stream_slave_agt=axi4_stream_slave_agent::type_id::create(.name("axi4_stream_slave_agt"),.parent(this));
    1968                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1969                                                         monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1970                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_req"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1971                                                         axi4_req=axi4_stream_ax_monitor::type_id::create(.name("axi4_req"),.parent(this));
    1972                                                         //uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1973                                                         //monitor=axi4_stream_slave_agent::type_id::create(.name("monitor"),.parent(this));
    1974                                                        // uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1975                                                         //monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1976                                                        // uvm_config_db#(axi4_stream_config)::set(this, "monitor",.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1977                                                     end
    1978                                                 endfunction: build_phase
    1979                                                 function void connect_phase(uvm_phase phase);
    1980                                                    // axi4_stream_ax_monitor	 axi4_ax_req_mon;
    1981                                                     super.connect_phase(phase);
    1982                                                     monitor.vif    = axi4_stream_cfg.axi4_agent_handler1.vif;
    1983                                                     //axi4_req    = axi4_stream_cfg.axi4_agent_handler1.vif;
    1984                                                     //monitor.item_collected_port.connect(item_collected_port);
    1985                                                     //axi4_req.item_collected_port.connect(axi4_ax_req_mon.axi4_port);	
    1986                                                     //axi4_req.item_collected_port.connect(axi4_stream_cfg.axi4_agent_handler1.vif);
    1987                                                     //monitor.vif    = axi4_stream_master_agt.vif;
    1988                                                 endfunction: connect_phase
    1989                                             endclass: axi4_stream_env
    1990                                             //====================================================================================
    1991                                             //------------------------------------------------------------------------------------
    1992                                             //--------------------------------- UVM_TESTS
    1993                                             //------------------------------------------------------------------------------------
    1994                                             //====================================================================================
    1995                                             // UVM_TEST : TEMPLATE_TEST [TEMPLATE]
    1996                                             class template_test extends uvm_test;
    1997                                                 `uvm_component_utils(template_test)
    1998                                                 template_env sa_env;
    1999                                                 function new(string name, uvm_component parent);
    2000                                                     super.new(name, parent);
    2001                                                 endfunction: new
    2002                                                 function void build_phase(uvm_phase phase);
    2003                                                     super.build_phase(phase);
    2004                                                     sa_env = template_env::type_id::create(.name("sa_env"), .parent(this));
    2005                                                 endfunction: build_phase
    2006                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2007                                                     super.end_of_elaboration_phase(phase);
    2008                                                     this.print();
    2009                                                     factory.print();
    2010                                                 endfunction
    2011                                                 task run_phase(uvm_phase phase);
    2012                                                     template_sequence sa_seq;
    2013                                                     phase.raise_objection(.obj(this));
    2014                                                         sa_seq = template_sequence::type_id::create(.name("sa_seq"), .contxt(get_full_name()));
    2015                                                         assert(sa_seq.randomize());
    2016                                                     sa_seq.start(sa_env.sa_agent.sa_seqr);
    2017                                                     phase.drop_objection(.obj(this));
    2018                                                 endtask: run_phase
    2019                                             endclass: template_test
    2020                                             // UVM_TEST : AXILITE_TEST [AXILITE]
    2021                                             class axiLite_test extends uvm_test;
    2022                                                 `uvm_component_utils(axiLite_test)
    2023                                                 template_env aL_env;
    2024                                                 function new(string name, uvm_component parent);
    2025                                                     super.new(name, parent);
    2026                                                 endfunction: new
    2027                                                 function void build_phase(uvm_phase phase);
    2028                                                     super.build_phase(phase);
    2029                                                     begin
    2030                                                         axiLite_configuration axiLite_cfg;
    2031                                                         axiLite_cfg = new;
    2032                                                         assert(axiLite_cfg.randomize());
    2033                                                         uvm_config_db#(axiLite_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(axiLite_cfg));
    2034                                                         aL_env = template_env::type_id::create(.name("aL_env"),.parent(this));
    2035                                                     end
    2036                                                 endfunction: build_phase
    2037                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2038                                                     super.end_of_elaboration_phase(phase);
    2039                                                     this.print();
    2040                                                     factory.print();
    2041                                                 endfunction
    2042                                                 task run_phase(uvm_phase phase);
    2043                                                     axiLite_directed_sequence    axiLite_seq;
    2044                                                     phase.raise_objection(.obj(this));
    2045                                                     axiLite_seq = axiLite_directed_sequence::type_id::create(.name("axiLite_seq"));
    2046                                                     assert(axiLite_seq.randomize());
    2047                                                     `uvm_info("aL_env", { "\n", axiLite_seq.sprint() }, UVM_LOW)
    2048                                                     axiLite_seq.start(aL_env.aL_agt.aL_sqr);
    2049                                                     phase.drop_objection(.obj(this));
    2050                                                 endtask: run_phase
    2051                                             endclass: axiLite_test
    2052                                             // UVM_TEST : RGB_TEST1 [RGB]
    2053                                             class rgb_test1 extends uvm_test;
    2054                                                 `uvm_component_utils(rgb_test1)
    2055                                                 template_env frame_env;
    2056                                                 function new(string name, uvm_component parent);
    2057                                                     super.new(name, parent);
    2058                                                 endfunction
    2059                                                 function void build_phase(uvm_phase phase);
    2060                                                     super.build_phase(phase);
    2061                                                     begin
    2062                                                         rgb_configuration frame_cfg;
    2063                                                         frame_cfg = new;
    2064                                                         assert(frame_cfg.randomize());
    2065                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2066                                                         frame_env = template_env::type_id::create(.name("frame_env"),.parent(this));
    2067                                                     end
    2068                                                 endfunction: build_phase
    2069                                                 task run_phase(uvm_phase phase);
    2070                                                     top_sequence        random_sqr;
    2071                                                     uvm_component       component;
    2072                                                     rgb_sequencer       sequencer;
    2073                                                     random_sqr = top_sequence::type_id::create("random_sqr");
    2074                                                     if( !random_sqr.randomize() ) 
    2075                                                         `uvm_error("", "Randomize failed")
    2076                                                     random_sqr.starting_phase = phase;
    2077                                                     component = uvm_top.find("*.frame_seqr");
    2078                                                     if ($cast(sequencer, component))
    2079                                                         random_sqr.start(sequencer);
    2080                                                 endtask: run_phase
    2081                                             endclass: rgb_test1
    2082                                             // UVM_TEST : RGB_TEST2 [RGB]
    2083                                             class rgb_test2 extends rgb_test1;
    2084                                                 `uvm_component_utils(rgb_test2)
    2085                                                 function new (string name, uvm_component parent);
    2086                                                     super.new(name, parent);
    2087                                                 endfunction : new
    2088                                                 function void start_of_simulation_phase(uvm_phase phase);
    2089                                                     super.start_of_simulation_phase(phase);
    2090                                                     random_sequence_r1#(par_1)::type_id::set_type_override(random_sequence_r2::get_type());
    2091                                                 endfunction : start_of_simulation_phase
    2092                                             endclass: rgb_test2
    2093                                             class rgb_test extends uvm_test;
    2094                                                 `uvm_component_utils(rgb_test)
    2095                                                 template_env frame_env;
    2096                                                 rgb_agent#(par_1) frame_agent;
    2097                                                 rgb_agent#(par_2) frame_agent_b;
    2098                                                 rgb_agent#(par_3) frame_agent_cs[4];
    2099                                                 function new(string name, uvm_component parent);
    2100                                                     super.new(name, parent);
    2101                                                 endfunction
    2102                                                 function void build_phase(uvm_phase phase);
    2103                                                     super.build_phase(phase);
    2104                                                     begin
    2105                                                         rgb_configuration frame_cfg;
    2106                                                         frame_cfg = new;
    2107                                                         assert(frame_cfg.randomize());
    2108                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2109                                                         frame_env       = template_env::type_id::create(.name("frame_env"),.parent(this));
    2110                                                         frame_agent     = rgb_agent#(par_1)::type_id::create("frame_agent", this);
    2111                                                         frame_agent_b   = rgb_agent#(par_2)::type_id::create("frame_agent_b", this);
    2112                                                         foreach (frame_agent_cs[i])
    2113                                                             frame_agent_cs[i] = rgb_agent#(par_3)::type_id::create($sformatf("frame_agent_cs_%0d", i), this);
    2114                                                     end
    2115                                                 endfunction: build_phase
    2116                                                function void end_of_elaboration_phase(uvm_phase phase);
    2117                                                   uvm_phase run_phase = uvm_run_phase::get();
    2118                                                   run_phase.phase_done.set_drain_time(this, 100us);
    2119                                                   frame_agent.frame_mon.agent_id = 0;
    2120                                                   frame_agent_b.frame_mon.agent_id = 1;
    2121                                                   foreach (frame_agent_cs[i])
    2122                                                     frame_agent_cs[i].frame_mon.agent_id = i + 2;
    2123                                                     this.print();
    2124                                                     factory.print();
    2125                                                endfunction
    2126                                                task run_phase(uvm_phase phase);
    2127                                                   super.run_phase(phase);
    2128                                                   phase.raise_objection(this);
    2129                                                   fork
    2130                                                      repeat (3) begin
    2131                                                         rgb_random_sequence#(par_1) rgb_seq_a = rgb_random_sequence#(par_1)::type_id::create("rgb_seq_a");
    2132                                                         rgb_seq_a.start(frame_env.frame_agent.frame_seqr);
    2133                                                      end
    2134                                                      repeat (3) begin
    2135                                                         rgb_random_sequence#(par_2) rgb_seq_b = rgb_random_sequence#(par_2)::type_id::create("rgb_seq_b");
    2136                                                         rgb_seq_b.start(frame_agent_b.frame_seqr);
    2137                                                      end
    2138                                                      begin
    2139                                                         foreach (frame_agent_cs[i])
    2140                                                            fork
    2141                                                               automatic int unsigned agent_id = i;
    2142                                                               repeat (3) begin
    2143                                                                  rgb_random_sequence#(par_3) rgb_seq_c = rgb_random_sequence#(par_3)::type_id::create("rgb_seq_c");
    2144                                                                  rgb_seq_c.start(frame_agent_cs[agent_id].frame_seqr);
    2145                                                               end
    2146                                                            join_none
    2147                                                         wait fork;
    2148                                                      end
    2149                                                   join
    2150                                                   phase.drop_objection(this);
    2151                                                endtask
    2152                                             // task run_phase(uvm_phase phase);
    2153                                                 // rgb_random_sequence#(par_1)    random_sqr;
    2154                                                 // phase.raise_objection(.obj(this));
    2155                                                 // random_sqr = rgb_random_sequence#(par_1)::type_id::create(.name("random_sqr"));
    2156                                                 // assert(random_sqr.randomize());
    2157                                                 // `uvm_info("aL_env", { "\n", random_sqr.sprint() }, UVM_LOW)
    2158                                                 // random_sqr.start(frame_env.frame_agent.frame_seqr);
    2159                                                 // phase.drop_objection(.obj(this));
    2160                                             // endtask: run_phase
    2161                                             endclass: rgb_test
    2162                                             class axi4_stream_test extends uvm_test;
    2163                                                 `uvm_component_utils(axi4_stream_test)
    2164                                                 axi4_stream_env             axi4_env;
    2165                                                 axi4_stream_agents_config   axi4_stream_cfg;
    2166                                                 axi4_stream_config          axi4_agent_handler1;
    2167                                                 function new(string name, uvm_component parent);
    2168                                                     super.new(name, parent);
    2169                                                 endfunction: new
    2170                                                 function void build_phase(uvm_phase phase);
    2171                                                     super.build_phase(phase);
    2172                                                     axi4_env        = axi4_stream_env            ::type_id::create(.name("axi4_env"), .parent(this));
    2173                                                     axi4_stream_cfg        = axi4_stream_agents_config  ::type_id::create("axi4_stream_cfg");
    2174                                                     axi4_agent_handler1 = axi4_stream_config         ::type_id::create("axi4_agent_handler1");
    2175                                                     if (! uvm_config_db#(virtual axi4_stream_if) ::get(.cntxt(this),.inst_name(""),.field_name("vif"),.value(axi4_agent_handler1.vif))) begin
    2176                                                         `uvm_error("axi4_stream_if", "vif not found")
    2177                                                     end
    2178                                                     axi4_stream_cfg.axi4_agent_handler1 = axi4_agent_handler1;
    2179                                                     uvm_config_db#(axi4_stream_agents_config)::set(.cntxt(this),.inst_name("*"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg));
    2180                                                 endfunction: build_phase
    2181                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2182                                                     super.end_of_elaboration_phase(phase);
    2183                                                     this.print();
    2184                                                     factory.print();
    2185                                                 endfunction
    2186                                                 task run_phase(uvm_phase phase);
    2187                                                     axi4_stream_master_sequence axi4_sequencer;
    2188                                                     phase.raise_objection(.obj(this));
    2189                                                         axi4_sequencer = axi4_stream_master_sequence::type_id::create(.name("axi4_sequencer"), .contxt(get_full_name()));
    2190                                                         assert(axi4_sequencer.randomize());
    2191                                                     axi4_sequencer.start(axi4_env.axi4_stream_master_agt.axi_sequencer);
    2192                                                     phase.drop_objection(.obj(this));
    2193                                                 endtask: run_phase
    2194                                             endclass: axi4_stream_test
    2195                                             endpackage: socTest_pkg
    2196                                             //====================================================================================
    2197                                             //------------------------------------------------------------------------------------
    2198                                             //--------------------------------- INTERFACES
    2199                                             //------------------------------------------------------------------------------------
    2200                                             //====================================================================================
    2201                                             // INTERFACE : TEMPLATE_IF [TEMPLATE]
    2202                                             interface template_if;
    2203                                                 logic        sig_clock;
    2204                                                 logic        sig_ina;
    2205                                                 logic        sig_inb;
    2206                                                 logic        sig_en_i;
    2207                                                 logic        sig_en_o;
    2208                                                 logic        sig_out;
    2209                                                 modport      templateSlave (input sig_clock,sig_ina,sig_inb,sig_en_i,output sig_en_o,sig_out);
    2210                                             endinterface: template_if
    2211                                             // INTERFACE : AXILITE_IF [AXILITE]
    2212                                             interface axiLite_if(input bit ACLK,ARESETN);
    2213                                                 logic [7:0]     AWADDR;
    2214                                                 logic [ 2:0]    AWPROT;
    2215                                                 logic           AWVALID;
    2216                                                 logic           AWREADY;
    2217                                                 logic [31:0]    WDATA;
    2218                                                 logic [ 3:0]    WSTRB;
    2219                                                 logic           WVALID;
    2220                                                 logic           WREADY;
    2221                                                 logic [1:0]     BRESP;
    2222                                                 logic           BVALID;
    2223                                                 logic           BREADY;
    2224                                                 logic [7:0]     ARADDR;
    2225                                                 logic [ 2:0]    ARPROT;
    2226                                                 logic           ARVALID;
    2227                                                 logic           ARREADY;
    2228                                                 logic [31:0]    RDATA;
    2229                                                 logic [ 1:0]    RRESP;
    2230                                                 logic           RVALID;
    2231                                                 logic           RREADY;
    2232                                                 modport         ConfigMaster(input ACLK,ARESETN,AWADDR,AWPROT,AWVALID,WDATA,WSTRB,WVALID,BREADY,ARADDR,ARPROT,ARVALID,RREADY, output  AWREADY,ARREADY,RDATA,RRESP,RVALID,WREADY,BRESP,BVALID);
    2233                                             endinterface: axiLite_if
    2234                                             // INTERFACE : RGB_IF [RGB]
    2235                                             interface rgb_if(input bit clk);
    2236                                                 logic [7:0]  iRed;
    2237                                                 logic [7:0]  iGreen;
    2238                                                 logic [7:0]  iBlue;
    2239                                                 logic        iValid;
    2240                                                 logic        iPixelEn;
    2241                                                 logic        iEof;
    2242                                                 int unsigned iX;
    2243                                                 int unsigned iY;
    2244                                                 logic [7:0]  oRed;
    2245                                                 logic [7:0]  oGreen;
    2246                                                 logic [7:0]  oBlue;
    2247                                                 logic        oValid;
    2248            1                          1         clocking master_cb @ (posedge clk);
    2249                                                     default input #1step output #1ns;
    2250                                                     output iPixelEn,iX,iY,iRed,iGreen,iBlue,iValid,iEof;
    2251            1                          1             input  oRed;
    2252                                                 endclocking: master_cb
    2253            1                          1         clocking slave_cb @ (posedge clk);
    2254                                                     default input #1step output #1ns;
    2255            1                          1             input  iX,iY,iRed,iGreen,iBlue,iPixelEn,iValid,iEof;
    2256                                                     output oRed;
    2257                                                 endclocking: slave_cb
    2258                                                 modport master_mp(input clk, output  oRed,oGreen,oBlue,oValid);
    2259                                                 modport slave_mp (input clk,iRed,iGreen,iBlue,iValid,iPixelEn,iEof,iX,iY,output oRed,oGreen,oBlue,oValid);
    2260                                                 modport master_sync_mp(clocking master_cb);
    2261                                                 modport slave_sync_mp (clocking slave_cb);
    2262                                             endinterface: rgb_if
    2263                                             interface axi4_stream_if(input bit ACLK,ARESET_N);
    2264                                                 parameter DATA_BYTES = 16;
    2265                                             	logic TVALID;	// Master valid
    2266                                             	logic TLAST;	// Master TLAST
    2267                                                 
    2268                                             	logic TREADY;	// Slave ready
    2269                                             	logic [DATA_BYTES-1:0] TDATA;	//-- Master data
    2270                                             	logic TUSER;	//-- Master sideband signals
    2271                                             	//--
    2272                                                 //--DEBUG signals
    2273                                                 //--
    2274                                             	//logic [DATA_BYTES/16-1:0] DEBUG_VALIDS;		//-- contains the AX-VALID Flags
    2275                                             	//logic [DATA_BYTES/16-1:0] DEBUG_HEADERS;	//-- contains the AX-HEADER Flags
    2276                                             	//logic [DATA_BYTES/16-1:0] DEBUG_TAILS;		//-- contains the AX-TAIL Flags
    2277                                             	////-- assigning the debug signals to TUSER
    2278                                             	//assign DEBUG_VALIDS     = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2279                                             	//assign DEBUG_HEADERS    = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2280                                             	//assign DEBUG_TAILS      = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2281                                             	//--
    2282                                             	//-- Interface Coverage
    2283                                             	//--
    2284                                             	covergroup axi4_cg @ (posedge ACLK);
    2285                                             		option.per_instance = 1;
    2286                                             		T_VALID : coverpoint TVALID;
    2287                                             		T_READY : coverpoint TREADY;
    2288                                             		//-- cover the amount of consecutive AXI4 transactions
    2289                                             		CONSECUTIVE_TRANSACTIONS: coverpoint {TVALID , TREADY}{
    2290                                             			bins transactions_single	= (0,1,2 =>3			=> 0,1,2);
    2291                                             			bins transactions_1_5[] 	= (0,1,2 =>3[*2:10] 	=> 0,1,2);
    2292                                             			bins transactions_11_50[] 	= (0,1,2 =>3[*11:50]	=> 0,1,2);
    2293                                             			bins transactions_huge 		= (0,1,2 =>3[*51:100000]=> 0,1,2);
    2294                                             		}
    2295                                             		//-- cover the waiting time after TVALID is set until TREADY in clock cycles
    2296                                             		TRANSACTION_WAITING: coverpoint {TVALID , TREADY}{
    2297                                             			bins zero_waiting_time		= (0,1				=> 3);
    2298                                             			bins low_waiting_time[]		= (2[*1:5]			=> 3);
    2299                                             			bins medium_waiting_time[]	= (2[*6:15] 		=> 3);
    2300                                             			bins high_waiting_time		= (2[*16:100000] 	=> 3);
    2301                                             			illegal_bins illegal		= (2				=> 0);
    2302                                             		}
    2303                                             		//-- Pause between Transactions
    2304                                             		TRANSACTION_PAUSE: coverpoint {TVALID , TREADY}{
    2305                                             			bins low_waiting_time[]		= (3 => 0[*1:5]		=> 2,3);
    2306                                             			bins medium_waiting_time[]	= (3 => 0[*6:15] 	=> 2,3);
    2307                                             			bins high_waiting_time		= (3 => 0[*16:100] 	=> 2,3);
    2308                                             		}
    2309                                             		//-- cover the time TREADY is active until deassertion or TVALID in clock cycles
    2310                                             		READY_WITHOUT_VALID: coverpoint {TVALID , TREADY}{
    2311                                             			bins short_ready_time[]		= (1[*1:5]  	=> 3,0);
    2312                                             			bins medium_ready_time[]	= (1[*6:15] 	=> 3,0);
    2313                                             			bins high_ready_time		= (1[*16:100000]=> 3,0);
    2314                                             		}
    2315                                             		//--cover all available transitions of TVALID/TREADY
    2316                                             		CASES_VALID_READY : cross T_VALID, T_READY;
    2317                                             		TRANSITIONS: coverpoint {TVALID, TREADY}{
    2318                                             			bins transition[] = ( 0,1,3 => [0:3]), (2 => 2,3) ;
    2319                                             		}
    2320                                             		//-- cover active VALID Flags
    2321                                             		//VALID_FLAGS : coverpoint DEBUG_VALIDS;
    2322                                             		//VALID_TRANSITIONS : coverpoint DEBUG_VALIDS {
    2323                                             		//	bins transition [] = ( [1:(1<<($size(DEBUG_VALIDS))) -1] => [1:(1<<($size(DEBUG_VALIDS))) -1] );
    2324                                             		//}
    2325                                             		//-- cover active HEADER Flags
    2326                                             		//HDR_FLAGS   : coverpoint DEBUG_HEADERS;
    2327                                             		//HDR_TRANSITIONS : coverpoint DEBUG_HEADERS {
    2328                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_HEADERS)) -1] => [1:1<<($size(DEBUG_HEADERS)) -1] );
    2329                                             		//}
    2330                                             		////-- cover active TAIL Flags
    2331                                             		//TAIL_FLAGS  : coverpoint DEBUG_TAILS;
    2332                                             		//TAIL_TRANSITIONS : coverpoint DEBUG_TAILS {
    2333                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_TAILS)) -1] => [1:1<<($size(DEBUG_TAILS)) -1] );
    2334                                             		//}
    2335                                             		//CROSS_HDR_TAILS : cross HDR_FLAGS, TAIL_FLAGS;
    2336                                             		//HDR_TAILS : coverpoint { DEBUG_HEADERS != {$size(DEBUG_HEADERS){1'b0}} ,DEBUG_TAILS != {$size(DEBUG_TAILS){1'b0}}   };
    2337                                             	endgroup
    2338                                             	//-- creating an instance of the covergroup
    2339            1                          1     	axi4_cg axi4 = new();
    2340                                             
    2341                                             	property reset_synchronous_deassert_p;
    2342                                             		@(edge ACLK)
    2343                                             		!ARESET_N |-> ARESET_N[->1];
    2344                                             	endproperty
    2345                                             	// chk_reset_tvalid	: assert property (
    2346                                             //	 	//-- TVALID must be inactive during Reset
    2347                                             //	 	@(posedge ACLK)
    2348                                             //	 	!ARESET_N |-> TVALID == 1'b0
    2349                                             //	 );
    2350                                             	chk_valid_hold 		: assert property (
    2351                                             		//-- if TVALID is set it must be active until TREADY
    2352                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2353                                             		(TVALID == 1 && TREADY == 0) |=> (TVALID==1)
    2354                                             	);
    2355                                             	//chk_valid_headers 	: assert property (
    2356                                             	//	//-- check if HEADER Flags are a subset of VALID Flags
    2357                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2358                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_HEADERS
    2359                                             	//						  == DEBUG_VALIDS)
    2360                                             	//);
    2361                                             	//chk_valid_tails 	: assert property (
    2362                                             	//	//-- check if TAIL Flags are a subset of VALID Flags
    2363                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2364                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_TAILS
    2365                                             	//						  == DEBUG_VALIDS)
    2366                                             	//);
    2367                                             	//check_spanning_ax_pkts	: assert property (
    2368                                             	//	//-- check that TVALID stays high if a ax_packet ranges over multiple axi cycles
    2369                                             	//	//-- starts if more header than tails
    2370                                             	//	//-- completes if more tails than header
    2371                                             	//	@(posedge ACLK  )  disable iff (!ARESET_N)
    2372                                             	//		(TVALID &&						( $countones(DEBUG_HEADERS) > $countones(DEBUG_TAILS) ))
    2373                                             	//		|=>	(TVALID == 1) throughout 	( $countones(DEBUG_HEADERS) < $countones(DEBUG_TAILS) )[->1]
    2374                                             	//);
    2375                                             	time clk_rise;
    2376                                             	time reset_rise;
    2377            1                        100     	always @(posedge ACLK) begin	
    2378                                             		if(ARESET_N == 0)
    2379            1                         99     			clk_rise <= $time();
    2380                                             	end
    2381            1                          1     	always @(posedge ARESET_N) begin
    2382            1                          1     		reset_rise <= $time();
    2383                                             	end
    2384                                             	//TODO TODO ADD
    2385                                             	// check_sync_reset : assert property (
    2386                                             	// 	@(posedge ACLK)
    2387                                             	// 	$rose(ARESET_N) |=> (reset_rise == clk_rise)
    2388                                             	// 	);
    2389                                             	property data_hold_p;
    2390                                             		//-- if TVALID is set TDATA must not be changed until TREADY
    2391                                             		logic [DATA_BYTES-1:0] m_data;
    2392                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2393                                             			(TVALID == 1 && TREADY == 0,m_data = TDATA) |=> (TDATA == m_data);
    2394                                             	endproperty : data_hold_p
    2395                                             	property user_hold_p;
    2396                                             		//-- if TVALID is set TUSER must not be changed until TREADY
    2397                                             		logic  m_user;
    2398                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2399                                             			(TVALID == 1 && TREADY == 0,m_user = TUSER) |=> (TUSER == m_user);
    2400                                             	endproperty : user_hold_p
    2401                                             	chk_data_hold 		: assert property(   data_hold_p);
    2402                                             	chk_user_hold		: assert property(   user_hold_p);
    2403                                                 modport      rx_channel (input ACLK,ARESET_N,TVALID,TUSER,TLAST,TDATA,output TREADY);
    2404                                             endinterface : axi4_stream_if
    2405                                             //====================================================================================
    2406                                             //------------------------------------------------------------------------------------
    2407                                             //--------------------------------- MODULES
    2408                                             //------------------------------------------------------------------------------------
    2409                                             //====================================================================================
    2410                                             // MODULE : ADDER [TEMPLATE]
    2411                                             module adder(template_if.templateSlave templateVif);
    2412                                                 import socTest_pkg::*;
    2413                                                 template dut (
    2414                                                .clk         (templateVif.sig_clock),
    2415                                                .en_i        (templateVif.sig_en_i),
    2416                                                .ina         (templateVif.sig_ina),
    2417                                                .inb         (templateVif.sig_inb),
    2418                                                .en_o        (templateVif.sig_en_o),
    2419                                                .out         (templateVif.sig_out));
    2420                                             endmodule: adder
    2421                                             // MODULE : VFPCONFIGDUT [AXILITE] 
    2422                                             module vfpConfigDut(axiLite_if.ConfigMaster axiLiteVif,axi4_stream_if.rx_channel vif);
    2423                                                 import socTest_pkg::*;
    2424                                                 VFP_v1_0 dutVFP_v1Inst (
    2425                                                 //d5m input
    2426                                                 .pixclk                (),//(axiLiteVif.ACLK   ),
    2427                                                 .ifval                 (),//(axiLiteVif.ARESETN),
    2428                                                 .ilval                 (),//(axiLiteVif.AWADDR ),
    2429                                                 .idata                 (),//(axiLiteVif.AWPROT ),
    2430                                                 //tx channel           (),//
    2431                                                 .rgb_m_axis_aclk       (),//(axiLiteVif.ACLK   ),
    2432                                                 .rgb_m_axis_aresetn    (),//(axiLiteVif.ARESETN),
    2433                                                 .rgb_m_axis_tready     (),//(axiLiteVif.AWADDR ),
    2434                                                 .rgb_m_axis_tvalid     (),//(axiLiteVif.AWPROT ),
    2435                                                 .rgb_m_axis_tlast      (),//(axiLiteVif.AWVALID),
    2436                                                 .rgb_m_axis_tuser      (),//(axiLiteVif.AWREADY),
    2437                                                 .rgb_m_axis_tdata      (),//(axiLiteVif.WDATA  ),
    2438                                                 //rx channel
    2439                                                 .rgb_s_axis_aclk       (vif.ACLK     ),
    2440                                                 .rgb_s_axis_aresetn    (vif.ARESET_N ),
    2441                                                 .rgb_s_axis_tready     (vif.TREADY   ),
    2442                                                 .rgb_s_axis_tvalid     (vif.TVALID   ),
    2443                                                 .rgb_s_axis_tlast      (vif.TLAST    ),
    2444                                                 .rgb_s_axis_tuser      (vif.TUSER    ),
    2445                                                 .rgb_s_axis_tdata      (vif.TDATA    ),
    2446                                                 //destination channel  (),//
    2447                                                 .m_axis_mm2s_aclk      (),//(axiLiteVif.ACLK   ),
    2448                                                 .m_axis_mm2s_aresetn   (),//(axiLiteVif.ARESETN),
    2449                                                 .m_axis_mm2s_tready    (),//(axiLiteVif.AWADDR ),
    2450                                                 .m_axis_mm2s_tvalid    (),//(axiLiteVif.AWPROT ),
    2451                                                 .m_axis_mm2s_tuser     (),//(axiLiteVif.AWVALID),
    2452                                                 .m_axis_mm2s_tlast     (),//(axiLiteVif.AWREADY),
    2453                                                 .m_axis_mm2s_tdata     (),//(axiLiteVif.WDATA  ),
    2454                                                 .m_axis_mm2s_tkeep     (),//(axiLiteVif.AWPROT ),
    2455                                                 .m_axis_mm2s_tstrb     (),//(axiLiteVif.AWVALID),
    2456                                                 .m_axis_mm2s_tid       (),//(axiLiteVif.AWREADY),
    2457                                                 .m_axis_mm2s_tdest     (),//(axiLiteVif.WDATA  ),
    2458                                                 //video configuration  
    2459                                                 .vfpconfig_aclk        (axiLiteVif.ACLK   ),
    2460                                                 .vfpconfig_aresetn     (axiLiteVif.ARESETN),
    2461                                                 .vfpconfig_awaddr      (axiLiteVif.AWADDR ),
    2462                                                 .vfpconfig_awprot      (axiLiteVif.AWPROT ),
    2463                                                 .vfpconfig_awvalid     (axiLiteVif.AWVALID),
    2464                                                 .vfpconfig_awready     (axiLiteVif.AWREADY),
    2465                                                 .vfpconfig_wdata       (axiLiteVif.WDATA  ),
    2466                                                 .vfpconfig_wstrb       (axiLiteVif.WSTRB  ),
    2467                                                 .vfpconfig_wvalid      (axiLiteVif.WVALID ),
    2468                                                 .vfpconfig_wready      (axiLiteVif.WREADY ),
    2469                                                 .vfpconfig_bresp       (axiLiteVif.BRESP  ),
    2470                                                 .vfpconfig_bvalid      (axiLiteVif.BVALID ),
    2471                                                 .vfpconfig_bready      (axiLiteVif.BREADY ),
    2472                                                 .vfpconfig_araddr      (axiLiteVif.ARADDR ),
    2473                                                 .vfpconfig_arprot      (axiLiteVif.ARPROT ),
    2474                                                 .vfpconfig_arvalid     (axiLiteVif.ARVALID),
    2475                                                 .vfpconfig_arready     (axiLiteVif.ARREADY),
    2476                                                 .vfpconfig_rdata       (axiLiteVif.RDATA  ),
    2477                                                 .vfpconfig_rresp       (axiLiteVif.RRESP  ),
    2478                                                 .vfpconfig_rvalid      (axiLiteVif.RVALID ),
    2479                                                 .vfpconfig_rready      (axiLiteVif.RREADY ));
    2480                                             endmodule: vfpConfigDut
    2481                                             
    2482                                             // MODULE : RGB_COLOR [RGB]
    2483                                             module rgb_color(rgb_if.slave_mp frame_slave_if);
    2484                                                 import socTest_pkg::*;
    2485                                                 pixelCord dutModule2Inst (
    2486                                                .clk         (frame_slave_if.clk),
    2487                                                .iRed        (frame_slave_if.iRed),
    2488                                                .iGreen      (frame_slave_if.iGreen),
    2489                                                .iBlue       (frame_slave_if.iBlue),
    2490                                                .iValid      (frame_slave_if.iValid),
    2491                                                .iPixelEn    (frame_slave_if.iPixelEn),
    2492                                                .iEof        (frame_slave_if.iEof),
    2493                                                .iX          (frame_slave_if.iX),
    2494                                                .iY          (frame_slave_if.iY),
    2495                                                .oRed        (frame_slave_if.oRed),
    2496                                                .oGreen      (frame_slave_if.oGreen),
    2497                                                .oBlue       (frame_slave_if.oBlue),
    2498                                                .oValid      (frame_slave_if.oValid));
    2499                                             endmodule: rgb_color
    2500                                             //====================================================================================
    2501                                             //------------------------------------------------------------------------------------
    2502                                             //--------------------------------- TOP
    2503                                             //------------------------------------------------------------------------------------
    2504                                             //====================================================================================
    2505                                             module top;
    2506                                                 import uvm_pkg::*;
    2507                                                 import socTest_pkg::*;
    2508                                                 reg ACLK;
    2509                                                 reg ARESETN;
    2510                                                 reg ARESET_N;
    2511                                                 reg clk;
    2512                                                 //INTERFACE
    2513                                                 axiLite_if          axiLiteVif(ACLK,ARESETN);   // AXILITE-INTERFACE
    2514                                                 axi4_stream_if      vif(ACLK,ARESET_N);    
    2515                                                 rgb_if              frame_slave_if(clk);        // RGB-INTERFACE
    2516                                                 template_if         templateVif();              // TEMPLATE-INTERFACE
    2517                                                 //MODULE
    2518                                                 adder               templateDut(templateVif);   // [TEMPLATE]
    2519                                                 vfpConfigDut        vfpConfig_test(axiLiteVif,vif); // [AXILITE]
    2520                                                 rgb_color           frame_color(frame_slave_if);// [RGB]
    2521                                                 
    2522                                                 initial begin
    2523            1                          1             ARESETN  = 1'b0;
    2524            1                          1             ARESET_N = 1'b0;
    2525            1                          1         #1000;
    2526            1                          1             ARESETN  = 1'b1;
    2527            1                          1             ARESET_N = 1'b1;
    2528                                                 end
    2529                                                 initial begin
    2530            1                          1             ACLK = 0;
    2531            1                          1         #5ns ;
    2532            1                          1         forever #5ns ACLK = ! ACLK;
    2532            2                       2262     
    2532            3                       2261     
    2533                                                 end
    2534                                                 initial begin
    2535            1                          1             templateVif.sig_clock = 0;
    2536            1                          1         #5ns ;
    2537            1                          1         forever #5ns templateVif.sig_clock = ! templateVif.sig_clock;
    2537            2                       2262     
    2537            3                       2261     
    2538                                                 end
    2539                                                 initial begin
    2540            1                          1             clk = 0;
    2541            1                          1             #5ns ;
    2542            1                          1             forever #5ns clk = ! clk;
    2542            2                       2262     
    2542            3                       2261     
    2543                                                 end
    2544                                                 initial begin
    2545            1                          1         uvm_config_db #(virtual axiLite_if)::set(null, "*", "axiLiteVif", axiLiteVif);
    2546            1                          1         uvm_resource_db#(virtual template_if)::set(.scope("ifs"), .name("template_if"), .val(templateVif));
    2547            1                          1         uvm_resource_db#(virtual rgb_if)::set(.scope("ifs"),.name("rgb_if"),.val(frame_slave_if));
    2548            1                          1         uvm_config_db#(virtual axi4_stream_if)::set(.cntxt(null),.inst_name("uvm_test_top"),.field_name("vif"),.value(vif));
    2549            1                          1         run_test();
    2550                                                 end
    2551                                             endmodule: top
    2552                                             //====================================================================================
    2553                                             //------------------------------------------------------------------------------------
    2554                                             //---------------------------------
    2555                                             //------------------------------------------------------------------------------------
    2556                                             //====================================================================================

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         2         2         0     100.0

================================Branch Details================================

Branch Coverage for file ../modules/top.sv --

------------------------------------IF Branch------------------------------------
    2378                                     100     Count coming in to IF
    2378            1                         99     		if(ARESET_N == 0)
                                               1     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

COVERGROUP COVERAGE:
-----------------------------------------------------------------------------------------------
Covergroup                                             Metric       Goal    Status               
                                                                                              
-----------------------------------------------------------------------------------------------
 TYPE /top/vif/axi4_cg                                  46.9%        100    Uncovered            
    covered/total bins:                                    32        544                      
    missing/total bins:                                   512        544                      
    % Hit:                                               5.8%        100                      
    type_option.weight=1
    type_option.goal=100
    type_option.comment=
    type_option.strobe=0
    type_option.merge_instances=auto(0)
    Coverpoint axi4_cg::T_VALID                        100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::T_READY                        100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::CONSECUTIVE_TRANSACTIONS         0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_WAITING              5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_PAUSE                0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::READY_WITHOUT_VALID             51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSITIONS                     42.8%        100    Uncovered            
        covered/total bins:                                 6         14                      
        missing/total bins:                                 8         14                      
        % Hit:                                          42.8%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Cross axi4_cg::CASES_VALID_READY                    75.0%        100    Uncovered            
        covered/total bins:                                 3          4                      
        missing/total bins:                                 1          4                      
        % Hit:                                          75.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
 Covergroup instance \/top/vif/axi4                     46.9%        100    Uncovered            
    covered/total bins:                                    32        544                      
    missing/total bins:                                   512        544                      
    % Hit:                                               5.8%        100                      
    option.name=\/top/vif/axi4 
    option.weight=1
    option.goal=100
    option.comment=
    option.at_least=1
    option.auto_bin_max=64
    option.cross_num_print_missing=0
    option.detect_overlap=0
    option.per_instance=1
    option.get_inst_coverage=0
    Coverpoint T_VALID                                 100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                      1031          1    Covered              
        bin auto[1]                                       100          1    Covered              
    Coverpoint T_READY                                 100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                        99          1    Covered              
        bin auto[1]                                      1031          1    Covered              
    Coverpoint CONSECUTIVE_TRANSACTIONS                  0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transactions_single                            89          1    Covered              
        bin transactions_1_5[2=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>1]                   5          1    Covered              
        bin transactions_1_5[1=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_huge                               0          1    ZERO                 
    Coverpoint TRANSACTION_WAITING                       5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        illegal_bin illegal                                 0               ZERO                 
        bin zero_waiting_time                              95          1    Covered              
        bin low_waiting_time[2[*1]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*2]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*3]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*4]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*5]=>3]                      0          1    ZERO                 
        bin medium_waiting_time[2[*6]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*7]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*8]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*9]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*10]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*11]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*12]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*13]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*14]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*15]=>3]                  0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint TRANSACTION_PAUSE                         0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin low_waiting_time[3=>0[*1]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*1]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>2]                   0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>2]               0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint READY_WITHOUT_VALID                      51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin short_ready_time[1[*1]=>3]                     95          1    Covered              
        bin short_ready_time[1[*1]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*2]=>3]                     92          1    Covered              
        bin short_ready_time[1[*2]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*3]=>3]                     87          1    Covered              
        bin short_ready_time[1[*3]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*4]=>3]                     80          1    Covered              
        bin short_ready_time[1[*4]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*5]=>3]                     76          1    Covered              
        bin short_ready_time[1[*5]=>0]                      0          1    ZERO                 
        bin medium_ready_time[1[*6]=>3]                    72          1    Covered              
        bin medium_ready_time[1[*6]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*7]=>3]                    67          1    Covered              
        bin medium_ready_time[1[*7]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*8]=>3]                    61          1    Covered              
        bin medium_ready_time[1[*8]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*9]=>3]                    55          1    Covered              
        bin medium_ready_time[1[*9]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*10]=>3]                   52          1    Covered              
        bin medium_ready_time[1[*10]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*11]=>3]                   46          1    Covered              
        bin medium_ready_time[1[*11]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*12]=>3]                   38          1    Covered              
        bin medium_ready_time[1[*12]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*13]=>3]                   32          1    Covered              
        bin medium_ready_time[1[*13]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*14]=>3]                   24          1    Covered              
        bin medium_ready_time[1[*14]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*15]=>3]                   18          1    Covered              
        bin medium_ready_time[1[*15]=>0]                    0          1    ZERO                 
        bin high_ready_time                                14          1    Covered              
    Coverpoint TRANSITIONS                              42.8%        100    Uncovered            
        covered/total bins:                                 6         14                      
        missing/total bins:                                 8         14                      
        % Hit:                                          42.8%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transition[3=>3]                                5          1    Covered              
        bin transition[3=>2]                                0          1    ZERO                 
        bin transition[3=>1]                               94          1    Covered              
        bin transition[3=>0]                                0          1    ZERO                 
        bin transition[1=>3]                               95          1    Covered              
        bin transition[1=>2]                                0          1    ZERO                 
        bin transition[1=>1]                              836          1    Covered              
        bin transition[1=>0]                                0          1    ZERO                 
        bin transition[0=>3]                                0          1    ZERO                 
        bin transition[0=>2]                                0          1    ZERO                 
        bin transition[0=>1]                                1          1    Covered              
        bin transition[0=>0]                               98          1    Covered              
        bin transition[2=>3]                                0          1    ZERO                 
        bin transition[2=>2]                                0          1    ZERO                 
    Cross CASES_VALID_READY                             75.0%        100    Uncovered            
        covered/total bins:                                 3          4                      
        missing/total bins:                                 1          4                      
        % Hit:                                          75.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.cross_num_print_missing=0
        bin <auto[0],auto[0]>                              99          1    Covered              
        bin <auto[0],auto[1]>                             931          1    Covered              
        bin <auto[1],auto[1]>                             100          1    Covered              
        bin <auto[1],auto[0]>                               0          1    ZERO                 

TOTAL COVERGROUP COVERAGE: 46.9%  COVERGROUP TYPES: 1

ASSERTION RESULTS:
-------------------------------------------------------
Name                 File(Line)           Failure Pass 
                                          Count   Count 
-------------------------------------------------------
/top/vif/chk_valid_hold
                     ../modules/top.sv(2354)       0     0
/top/vif/chk_data_hold
                     ../modules/top.sv(2401)       0     0
/top/vif/chk_user_hold
                     ../modules/top.sv(2402)       0     0
/socTest_pkg/axi4_stream_master_sequence/body/#ublk#215236535#765/immed__768
                     ../modules/top.sv(768)       0     1
/socTest_pkg/axi4_stream_test/run_phase/immed__2190
                     ../modules/top.sv(2190)       0     1

Total Coverage By File (code coverage only, filtered view): 17.9%

