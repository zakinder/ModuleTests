Coverage Report by file with details

=================================================================================
=== File: ../modules/dut/CameraRawData.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           49        29        20      59.1

================================Statement Details================================

Statement Coverage for file ../modules/dut/CameraRawData.vhd --

    1                                                --01062019 [01-06-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity CameraRawData is
    9                                                generic (
    10                                                   img_width         : integer := 8);
    11                                               port (
    12                                                   m_axis_aclk       : in std_logic;
    13                                                   m_axis_aresetn    : in std_logic;
    14                                                   pixclk            : in std_logic;
    15                                                   ifval             : in std_logic;
    16                                                   ilval             : in std_logic;
    17                                                   idata             : in std_logic_vector(11 downto 0);
    18                                                   oRawData          : out rData);
    19                                               end CameraRawData;
    20                                               architecture arch_imp of CameraRawData is
    21                                                   --PIXCLK SIDE
    22                                                   signal pLine          : std_logic :=lo;
    23                                                   signal pFrame         : std_logic :=lo;
    24                                                   signal pLineSyn       : std_logic :=lo;
    25                                                   signal pDataWrAddress : integer   := zero;
    26                                                   signal pSof           : std_logic :=lo;
    27                                                   signal pSol           : std_logic :=lo;
    28                                                   signal pEof           : std_logic :=lo;
    29                                                   signal pEol           : std_logic :=lo;
    30                                                   --M_AXIS_ACLK SIDE
    31                                                   signal ilvalSync1     : std_logic :=lo;
    32                                                   signal ilvalSync2     : std_logic :=lo;
    33                                                   signal ilvalSync3     : std_logic :=lo;
    34                                                   signal ilvalSync4     : std_logic :=lo;
    35                                                   signal ifvalSync1     : std_logic :=lo;
    36                                                   signal ifvalSync2     : std_logic :=lo;
    37                                                   signal endOfLine      : std_logic :=lo;
    38                                                   ----
    39                                                   signal rVdata         : std_logic_vector(11 downto 0):= (others => lo);
    40                                                   signal rLine          : std_logic :=lo;
    41                                                   type d5mSt is (readLineState,eolState,eofState,sofState);
    42                                                   signal d5mStates : d5mSt; 
    43                                                   signal cordx          : integer :=zero;
    44                                                   signal cordy          : integer :=zero;
    45                                               	signal imgWidth       : integer := 3071;
    46                                                   type plineRam is array (0 to img_width) of std_logic_vector (11 downto 0);
    47                                                   signal d5mLine        : plineRam := (others => (others => lo));
    48                                               begin
    49                                               -----------------------------------------------------------------------------------------
    50                                               --pixclk
    51                                               -----------------------------------------------------------------------------------------
    52              1                          2     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
    53                                               d5mDataSyncP: process(pixclk) begin
    54                                                   if rising_edge(pixclk) then
    55              1                          2             pLine       <= ilval;
    56              1                          2     		pLineSyn    <= pLine;
    57              1                          2             pFrame      <= ifval;
    58                                                       if (pFrame = hi and pLine = hi) then
    59              1                    ***0***                 pDataWrAddress  <= pDataWrAddress + one;
    60                                                       else
    61              1                          2                 pDataWrAddress <= zero;
    62                                                       end if;
    63                                                       if (endOfLine = hi) then
    64              1                    ***0***                 imgWidth  <= pDataWrAddress;
    65                                                       else
    66              1                          2                 imgWidth  <= imgWidth;
    67                                                       end if;
    68              1                          2             d5mLine(pDataWrAddress) <= idata;
    69                                                   end if;
    70                                               end process d5mDataSyncP;
    71                                               -----------------------------------------------------------------------------------------
    72                                               cdcSignals: process (m_axis_aclk) begin
    73                                                   if rising_edge(m_axis_aclk) then
    74              1                       1131             ilvalSync1  <= ilval;
    75              1                       1131             ilvalSync2  <= ilvalSync1;
    76              1                       1131     		ifvalSync1  <= ifval;
    77              1                       1131             ifvalSync2  <= ifvalSync1;
    78                                                   end if;
    79                                               end process cdcSignals;
    80                                               edgeDetect: process (m_axis_aclk) begin
    81                                                   if rising_edge(m_axis_aclk) then
    82              1                       1131             ilvalSync3  <= ilvalSync2;
    83              1                       1131             ilvalSync4  <= ilvalSync3;
    84                                                   end if;
    85                                               end process edgeDetect;
    86              1                          3     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
    87              1                          3     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
    88                                               readLineP: process (m_axis_aclk) begin
    89                                                   if (rising_edge (m_axis_aclk)) then
    90                                                       if (m_axis_aresetn = lo) then
    91              1                          3                 d5mStates <= sofState;
    92              1                          3     			pSof      <= lo;
    93              1                          3     			pEof      <= lo;
    94              1                          3     			rLine     <= lo;
    95              1                          3     			cordx     <= zero;
    96              1                          3     			cordy     <= zero;
    97                                                       else
    98                                                       case (d5mStates) is
    99                                                       when sofState =>
    100             1                          1                 pEof      <= lo;
    101                                                          if (ifvalSync2 = hi) and (pEol = hi) then --endOfLine and Sof
    102             1                    ***0***                     pSof      <= hi;
    103             1                    ***0***                     d5mStates <= readLineState;
    104                                                          end if;
    105                                                      when readLineState =>
    106                                                          if (cordx = imgWidth) then
    107             1                    ***0***                     rLine         <= lo;
    108             1                    ***0***                     d5mStates     <= eolState;
    109             1                    ***0***                     cordx         <= zero;
    110                                              			else
    111             1                    ***0***                     cordx         <= cordx + one;--start reading
    112             1                    ***0***     				rLine         <= hi;
    113             1                    ***0***     				pSof          <= lo;
    114             1                    ***0***     				d5mStates     <= readLineState;
    115                                                          end if;
    116                                                      when eolState =>
    117                                                          if (ifvalSync2 = lo)  then --endOfLine and Sof
    118             1                    ***0***                     cordy     <= zero;
    119             1                    ***0***                     d5mStates <= eofState;
    120                                              		    elsif(pEol = hi) then
    121             1                    ***0***                     d5mStates <= readLineState;
    122             1                    ***0***                     cordy     <= cordy + one;
    123                                              			else
    124             1                    ***0***                     d5mStates <= eolState;
    125                                                          end if;
    126                                                      when eofState =>	
    127             1                    ***0***     			d5mStates <= sofState;
    128             1                    ***0***                 pEof      <= hi;
    129                                                      when others =>
    130             1                    ***0***                 d5mStates <= sofState;
    131                                                      end case;
    132                                                      end if;
    133                                                  end if;
    134                                              end process readLineP;
    135                                              d5mLineRamP: process (m_axis_aclk) begin
    136                                                  if rising_edge(m_axis_aclk) then
    137             1                       1131             rVdata <= d5mLine(cordx);
    138                                                  end if;
    139                                              end process d5mLineRamP;
    140                                              d5mP: process (m_axis_aclk) begin
    141                                                  if rising_edge(m_axis_aclk) then
    142             1                          2             oRawData.valid  <= rLine;
    143             1                          2             oRawData.pEof   <= pEof;
    144             1                          2             oRawData.pSof   <= pSof;
    145             1                          2             oRawData.cord.x <= std_logic_vector(to_unsigned(cordx, 16)); 
    146             1                          2             oRawData.cord.y <= std_logic_vector(to_unsigned(cordy, 16)); 
    147                                                      if (rLine = hi) then
    148             1                    ***0***                 oRawData.data <= rVdata;
    149                                                      else
    150             1                          2                 oRawData.data <= (others =>lo);
    151                                                      end if;
    152                                                  end if;
    153                                              end process d5mP;
    154                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        32        16        16      50.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/CameraRawData.vhd --

------------------------------------IF Branch------------------------------------
    52                                         2     Count coming in to IF
    52              1                    ***0***     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
    52              2                          2     endOfLine <= hi when (pLineSyn = hi and ilval = lo) else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    54                                         2     Count coming in to IF
    54              1                          2         if rising_edge(pixclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    58                                         2     Count coming in to IF
    58              1                    ***0***             if (pFrame = hi and pLine = hi) then
    60              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    63                                         2     Count coming in to IF
    63              1                    ***0***             if (endOfLine = hi) then
    65              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    73                                      1131     Count coming in to IF
    73              1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    81                                      1131     Count coming in to IF
    81              1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    86                                         3     Count coming in to IF
    86              1                    ***0***     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
    86              2                          3     pSol <= hi when (ilvalSync4 = lo and ilvalSync2 = hi) else lo;--risingEdge Detect
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    87                                         3     Count coming in to IF
    87              1                    ***0***     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
    87              2                          3     pEol <= hi when (ilvalSync4 = hi and ilvalSync2 = lo) else lo;--fallingEdge Detect
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    89                                         4     Count coming in to IF
    89              1                          4         if (rising_edge (m_axis_aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    90                                         4     Count coming in to IF
    90              1                          3             if (m_axis_aresetn = lo) then
    97              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    98                                         1     Count coming in to CASE
    99              1                          1             when sofState =>
    105             1                    ***0***             when readLineState =>
    116             1                    ***0***             when eolState =>
    126             1                    ***0***             when eofState =>	
    129             1                    ***0***             when others =>
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    101                                        1     Count coming in to IF
    101             1                    ***0***                 if (ifvalSync2 = hi) and (pEol = hi) then --endOfLine and Sof
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    106                                  ***0***     Count coming in to IF
    106             1                    ***0***                 if (cordx = imgWidth) then
    110             1                    ***0***     			else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    117                                  ***0***     Count coming in to IF
    117             1                    ***0***                 if (ifvalSync2 = lo)  then --endOfLine and Sof
    120             1                    ***0***     		    elsif(pEol = hi) then
    123             1                    ***0***     			else
Branch totals: 0 hits of 3 branches = 0.0%

------------------------------------IF Branch------------------------------------
    136                                     1131     Count coming in to IF
    136             1                       1131         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    141                                        2     Count coming in to IF
    141             1                          2         if rising_edge(m_axis_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    147                                        2     Count coming in to IF
    147             1                    ***0***             if (rLine = hi) then
    149             1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             10         0        10       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/CameraRawData.vhd --

----------------Focused Condition View-------------------
Line       52 Item    1  ((pLineSyn = hi) and (ilval = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
  (pLineSyn = hi)         N  '_1' not hit             Hit '_1'
     (ilval = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (pLineSyn = hi)_0     -                             
  Row   2:    ***0***  (pLineSyn = hi)_1     (ilval = lo)                  
  Row   3:    ***0***  (ilval = lo)_0        (pLineSyn = hi)               
  Row   4:    ***0***  (ilval = lo)_1        (pLineSyn = hi)               

----------------Focused Condition View-------------------
Line       58 Item    1  ((pFrame = hi) and (pLine = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
  (pFrame = hi)         N  '_1' not hit             Hit '_1'
   (pLine = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (pFrame = hi)_0       -                             
  Row   2:    ***0***  (pFrame = hi)_1       (pLine = hi)                  
  Row   3:    ***0***  (pLine = hi)_0        (pFrame = hi)                 
  Row   4:    ***0***  (pLine = hi)_1        (pFrame = hi)                 

----------------Focused Condition View-------------------
Line       86 Item    1  ((ilvalSync4 = lo) and (ilvalSync2 = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ilvalSync4 = lo)         N  '_1' not hit             Hit '_1'
  (ilvalSync2 = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ilvalSync4 = lo)_0   -                             
  Row   2:    ***0***  (ilvalSync4 = lo)_1   (ilvalSync2 = hi)             
  Row   3:          1  (ilvalSync2 = hi)_0   (ilvalSync4 = lo)             
  Row   4:    ***0***  (ilvalSync2 = hi)_1   (ilvalSync4 = lo)             

----------------Focused Condition View-------------------
Line       87 Item    1  ((ilvalSync4 = hi) and (ilvalSync2 = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ilvalSync4 = hi)         N  '_1' not hit             Hit '_1'
  (ilvalSync2 = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ilvalSync4 = hi)_0   -                             
  Row   2:    ***0***  (ilvalSync4 = hi)_1   (ilvalSync2 = lo)             
  Row   3:    ***0***  (ilvalSync2 = lo)_0   (ilvalSync4 = hi)             
  Row   4:    ***0***  (ilvalSync2 = lo)_1   (ilvalSync4 = hi)             

----------------Focused Condition View-------------------
Line       101 Item    1  ((ifvalSync2 = hi) and (pEol = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  (ifvalSync2 = hi)         N  '_1' not hit             Hit '_1'
        (pEol = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (ifvalSync2 = hi)_0   -                             
  Row   2:    ***0***  (ifvalSync2 = hi)_1   (pEol = hi)                   
  Row   3:    ***0***  (pEol = hi)_0         (ifvalSync2 = hi)             
  Row   4:    ***0***  (pEol = hi)_1         (ifvalSync2 = hi)             


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                        19.6
        States                       4         1         3      25.0
        Transitions                  7         1         6      14.2

================================FSM Details================================

FSM Coverage for file ../modules/dut/CameraRawData.vhd --

FSM_ID: d5mStates
    Current State Object : d5mStates
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  99            sofState                   3
 105       readLineState                   0
 116            eolState                   1
 126            eofState                   2
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                sofState                   3
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  91                   2                   1          readLineState -> sofState
    Uncovered States :
    ------------------
                   State
                   -----
           readLineState
                eolState
                eofState
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
 103                   0          sofState -> readLineState
 108                   1          readLineState -> eolState
 119                   3          eolState -> eofState
 121                   4          eolState -> readLineState
  91                   5          eolState -> sofState
 127                   6          eofState -> sofState


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       4         1         3      25.0
        Transitions                  7         1         6      14.2

=================================================================================
=== File: ../modules/dut/blurFilter.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           20        16         4      80.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/blurFilter.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity blurFilter is
    9                                                generic (
    10                                                   iMSB          : integer := 11;
    11                                                   iLSB          : integer := 4;
    12                                                   i_data_width  : integer := 8;
    13                                                   img_width     : integer := 256;
    14                                                   adwrWidth     : integer := 16;
    15                                                   addrWidth     : integer := 12);
    16                                               port (
    17                                                   clk            : in std_logic;
    18                                                   rst_l          : in std_logic;
    19                                                   iRgb           : in channel;
    20                                                   oRgb           : out channel);
    21                                               end entity;
    22                                               architecture arch of blurFilter is
    23                                               ---------------------------------------------------------------------------------
    24                                                   signal vTapRGB0x        : std_logic_vector(23 downto 0);
    25                                                   signal vTapRGB1x        : std_logic_vector(23 downto 0);
    26                                                   signal vTapRGB2x        : std_logic_vector(23 downto 0);
    27                                                   signal v1TapRGB0x       : std_logic_vector(23 downto 0);
    28                                                   signal v1TapRGB1x       : std_logic_vector(23 downto 0);
    29                                                   signal v1TapRGB2x       : std_logic_vector(23 downto 0);
    30                                                   signal enable           : std_logic;
    31                                                   signal d1en             : std_logic;
    32                                                   signal d2en             : std_logic;
    33                                                   signal d3RGB            : std_logic_vector(23 downto 0);
    34                                                   signal rCountAddress    : integer;
    35                                                   signal rAddress         : std_logic_vector(15 downto 0);
    36                                                   signal rgb1x            : channel;
    37                                                   signal rgb2x            : channel;
    38                                                   signal rgb3x            : channel;
    39                                                   signal blurRgb          : blurchannel;
    40                                               ---------------------------------------------------------------------------------
    41                                               begin
    42              1                          8         oRgb.red   <= blurRgb.red(iMSB downto iLSB);
    43              1                          8         oRgb.green <= blurRgb.green(iMSB downto iLSB);
    44              1                          8         oRgb.blue  <= blurRgb.blue(iMSB downto iLSB);
    45              1                          8         oRgb.valid <= blurRgb.valid;
    46                                               tapValidAdressP: process(clk)begin
    47                                                   if rising_edge(clk) then
    48                                                       if (iRgb.valid = '1') then
    49              1                    ***0***                 rCountAddress  <= rCountAddress + 1;
    50                                                       else
    51              1                         11                 rCountAddress  <= 0;
    52                                                       end if;
    53                                                   end if;
    54                                               end process tapValidAdressP;
    55              1                          8     rAddress  <= std_logic_vector(to_unsigned(rCountAddress, 16));
    56                                               RGB_inst: buffer_controller
    57                                               generic map(
    58                                                   img_width       => img_width,
    59                                                   adwrWidth       => adwrWidth,
    60                                                   dataWidth       => 24,
    61                                                   addrWidth       => addrWidth)
    62                                               port map(
    63                                                   aclk            => clk,
    64                                                   i_enable        => rgb2x.valid,
    65                                                   i_data          => d3RGB,
    66                                                   i_wadd          => rAddress,
    67                                                   i_radd          => rAddress,
    68                                                   en_datao        => enable,
    69                                                   taps0x          => v1TapRGB0x,
    70                                                   taps1x          => v1TapRGB1x,
    71                                                   taps2x          => v1TapRGB2x);
    72                                               MAC_R_inst: blurMac
    73                                               port map(
    74                                                   clk             => clk,
    75                                                   rst_l           => rst_l,
    76                                                   vTap0x          => vTapRGB0x(23 downto 16),
    77                                                   vTap1x          => vTapRGB1x(23 downto 16),
    78                                                   vTap2x          => vTapRGB2x(23 downto 16),
    79                                                   DataO           => blurRgb.red);
    80                                               MAC_G_inst: blurMac
    81                                               port map(
    82                                                   clk             => clk,
    83                                                   rst_l           => rst_l,
    84                                                   vTap0x          => vTapRGB0x(15 downto 8),
    85                                                   vTap1x          => vTapRGB1x(15 downto 8),
    86                                                   vTap2x          => vTapRGB2x(15 downto 8),
    87                                                   DataO           => blurRgb.green);
    88                                               MAC_B_inst: blurMac
    89                                               port map(
    90                                                   clk             => clk,
    91                                                   rst_l           => rst_l,
    92                                                   vTap0x          => vTapRGB0x(i_data_width-1 downto 0),
    93                                                   vTap1x          => vTapRGB1x(i_data_width-1 downto 0),
    94                                                   vTap2x          => vTapRGB2x(i_data_width-1 downto 0),
    95                                                   DataO           => blurRgb.blue);
    96                                               tapSignedP : process (clk) begin
    97                                                   if rising_edge(clk) then
    98              1                         26             rgb1x         <= iRgb;  
    99              1                         26             rgb2x         <= rgb1x;
    100             1                         26             rgb3x         <= rgb2x;
    101             1                         26             d3RGB         <= rgb3x.red & rgb3x.green & rgb3x.blue;
    102             1                         26             d1en          <= enable;
    103             1                         26             d2en          <= d1en;
    104             1                         26             blurRgb.valid <= d2en;
    105                                                      if(rgb3x.valid = '1') then
    106             1                    ***0***                 vTapRGB0x <= v1TapRGB0x;
    107             1                    ***0***                 vTapRGB1x <= v1TapRGB1x;
    108             1                    ***0***                 vTapRGB2x <= v1TapRGB2x;
    109                                                      else
    110             1                         26                 vTapRGB0x <= (others => '0');
    111             1                         26                 vTapRGB1x <= (others => '0');
    112             1                         26                 vTapRGB2x <= (others => '0');
    113                                                      end if;
    114                                                  end if;
    115                                              end process tapSignedP;
    116                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         4         2      66.6

================================Branch Details================================

Branch Coverage for file ../modules/dut/blurFilter.vhd --

------------------------------------IF Branch------------------------------------
    47                                        11     Count coming in to IF
    47              1                         11         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    48                                        11     Count coming in to IF
    48              1                    ***0***             if (iRgb.valid = '1') then
    50              1                         11             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    97                                        26     Count coming in to IF
    97              1                         26         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    105                                       26     Count coming in to IF
    105             1                    ***0***             if(rgb3x.valid = '1') then
    109             1                         26             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/blurMac.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           33        33         0     100.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/blurMac.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity blurMac is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   rst_l          : in std_logic;
    12                                                   vTap0x         : in std_logic_vector(7 downto 0);
    13                                                   vTap1x         : in std_logic_vector(7 downto 0);
    14                                                   vTap2x         : in std_logic_vector(7 downto 0);
    15                                                   DataO          : out std_logic_vector(11 downto 0));
    16                                               end entity;
    17                                               architecture arch of blurMac is
    18                                               ---------------------------------------------------------------------------------
    19                                                   constant i_data_width : integer := 8;
    20                                                   type detap is record
    21                                                       vTap0x  : unsigned(i_data_width downto 0);
    22                                                       vTap1x  : unsigned(i_data_width downto 0);
    23                                                       vTap2x  : unsigned(i_data_width downto 0);
    24                                                   end record;
    25                                                   type s_pixel is record
    26                                                       m1      : unsigned (16 downto 0);
    27                                                       m2      : unsigned (16 downto 0);
    28                                                       m3      : unsigned (16 downto 0);
    29                                                       mac     : unsigned (i_data_width+3 downto 0);
    30                                                   end record;
    31                                               ---------------------------------------------------------------------------------
    32                                                   signal mac1X       : s_pixel;
    33                                                   signal mac2X       : s_pixel;
    34                                                   signal mac3X       : s_pixel;
    35                                                   signal tpd1        : detap;
    36                                                   signal tpd2        : detap;
    37                                                   signal tpd3        : detap;
    38                                                   signal Data        : unsigned(i_data_width+3 downto 0);
    39                                               ---------------------------------------------------------------------------------
    40                                               begin
    41                                                 TAP_DELAY : process (clk) begin
    42                                               
    43                                                   if rising_edge(clk) then
    44                                                   if rst_l = '0' then
    45              1                         24             tpd1.vTap0x    <= (others => '0');
    46              1                         24             tpd1.vTap1x    <= (others => '0');
    47              1                         24             tpd1.vTap2x    <= (others => '0');
    48              1                         24             tpd2.vTap0x    <= (others => '0');
    49              1                         24             tpd2.vTap1x    <= (others => '0');
    50              1                         24             tpd2.vTap2x    <= (others => '0'); 
    51              1                         24             tpd3.vTap0x    <= (others => '0');
    52              1                         24             tpd3.vTap1x    <= (others => '0');
    53              1                         24             tpd3.vTap2x    <= (others => '0');
    54                                                   else
    55              1                         12            tpd1.vTap0x     <= unsigned('0' & vTap0x);
    56              1                         12            tpd1.vTap1x     <= unsigned('0' & vTap1x);
    57              1                         12            tpd1.vTap2x     <= unsigned('0' & vTap2x);
    58              1                         12            tpd2.vTap0x     <= tpd1.vTap0x;
    59              1                         12            tpd2.vTap1x     <= tpd1.vTap1x;
    60              1                         12            tpd2.vTap2x     <= tpd1.vTap2x;
    61              1                         12            tpd3.vTap0x     <= tpd2.vTap0x;
    62              1                         12            tpd3.vTap1x     <= tpd2.vTap1x;
    63              1                         12            tpd3.vTap2x     <= tpd2.vTap2x;
    64                                                   end if;
    65                                                   end if;
    66                                                 end process TAP_DELAY;
    67                                                 --1st Row Pixels
    68                                                 MAC_X_A : process (clk) begin
    69                                                   if rising_edge(clk) then
    70              1                         36     		mac1X.m1    <= (tpd1.vTap0x * blurMacKernel_9);--1st Row 1st pixel
    71              1                         36     		mac1X.m2    <= (tpd2.vTap0x * blurMacKernel_8);--1st Row 2nd pixel
    72              1                         36     		mac1X.m3    <= (tpd3.vTap0x * blurMacKernel_7);--1st Row 3rd pixel
    73              1                         36     		mac1X.mac   <= mac1X.m1(i_data_width+3 downto 0) + mac1X.m2(i_data_width+3 downto 0) + mac1X.m3(i_data_width+3 downto 0);
    74                                                   end if;
    75                                                 end process MAC_X_A;
    76                                                 MAC_X_B : process (clk) begin
    77                                                   if rising_edge(clk) then
    78              1                         36     		mac2X.m1    <= (tpd1.vTap1x * blurMacKernel_6);--2nd Row 1st pixel
    79              1                         36     		mac2X.m2    <= (tpd2.vTap1x * blurMacKernel_5);--2nd Row 2nd pixel
    80              1                         36     		mac2X.m3    <= (tpd3.vTap1x * blurMacKernel_4);--2nd Row 3rd pixel
    81              1                         36     		mac2X.mac   <= mac2X.m1(i_data_width+3 downto 0) + mac2X.m2(i_data_width+3 downto 0) + mac2X.m3(i_data_width+3 downto 0);
    82                                                   end if;
    83                                                 end process MAC_X_B;
    84                                                 MAC_X_C : process (clk) begin
    85                                                   if rising_edge(clk) then
    86              1                         36     		mac3X.m1    <= (tpd1.vTap2x * blurMacKernel_3);--3rd Row 1st pixel
    87              1                         36     		mac3X.m2    <= (tpd2.vTap2x * blurMacKernel_2);--3rd Row 2nd pixel
    88              1                         36     		mac3X.m3    <= (tpd3.vTap2x * blurMacKernel_1);--3rd Row 3rd pixel
    89              1                         36     		mac3X.mac   <= mac3X.m1(i_data_width+3 downto 0) + mac3X.m2(i_data_width+3 downto 0) + mac3X.m3(i_data_width+3 downto 0);
    90                                                   end if;
    91                                                 end process MAC_X_C;
    92                                                 PA_X : process (clk, rst_l) begin
    93                                                   if rst_l = '0' then
    94              1                       1200     		Data <= (others => '0');
    95                                                   elsif rising_edge(clk) then
    96              1                         24     		Data <= mac1X.mac + mac2X.mac + mac3X.mac;
    97                                                   end if;
    98                                                 end process PA_X;
    99              1                         24       DataO <= std_logic_vector(Data(11 downto 0));
    100                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         8         8         0     100.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/blurMac.vhd --

------------------------------------IF Branch------------------------------------
    43                                        36     Count coming in to IF
    43              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    44                                        36     Count coming in to IF
    44              1                         24         if rst_l = '0' then
    54              1                         12         else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    69                                        36     Count coming in to IF
    69              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    77                                        36     Count coming in to IF
    77              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    85                                        36     Count coming in to IF
    85              1                         36         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    93                                      1224     Count coming in to IF
    93              1                       1200         if rst_l = '0' then
    95              1                         24         elsif rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/buffer_controller.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           36        22        14      61.1

================================Statement Details================================

Statement Coverage for file ../modules/dut/buffer_controller.vhd --

    1                                                --01062019 [01-06-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity buffer_controller is
    9                                                generic (
    10                                                   img_width     : integer := 4096;
    11                                                   adwrWidth     : integer := 16;
    12                                                   dataWidth     : integer := 12;
    13                                                   addrWidth     : integer := 12);
    14                                               port (
    15                                                   aclk        : in std_logic;
    16                                                   i_enable    : in std_logic;
    17                                                   i_data      : in std_logic_vector(dataWidth - 1 downto 0);
    18                                                   i_wadd      : in std_logic_vector(adwrWidth - 1 downto 0);
    19                                                   i_radd      : in std_logic_vector(adwrWidth - 1 downto 0);
    20                                               	en_datao    : out std_logic;
    21                                                   taps0x      : out std_logic_vector(dataWidth - 1 downto 0);
    22                                                   taps1x      : out std_logic_vector(dataWidth - 1 downto 0);
    23                                                   taps2x      : out std_logic_vector(dataWidth - 1 downto 0));
    24                                               end entity;
    25                                               architecture arch of buffer_controller is
    26                                                   signal wrchx0_io   : std_logic :='0';
    27                                                   signal wrchx1_io   : std_logic :='0';
    28                                                   signal wrchx2_io   : std_logic :='0';
    29                                                   signal wrchx3_io   : std_logic :='0';
    30                                                   signal w1rchx0_io  : std_logic :='0';
    31                                                   signal w1rchx1_io  : std_logic :='0';
    32                                                   signal w1rchx2_io  : std_logic :='0';
    33                                                   signal w1rchx3_io  : std_logic :='0';
    34                                                   signal w2rchx0_io  : std_logic :='0';
    35                                                   signal w2rchx1_io  : std_logic :='0';
    36                                                   signal w2rchx2_io  : std_logic :='0';
    37                                                   signal w2rchx3_io  : std_logic :='0';
    38                                                   signal w3rchx0_io  : std_logic :='0';
    39                                                   signal w3rchx1_io  : std_logic :='0';
    40                                                   signal w3rchx2_io  : std_logic :='0';
    41                                                   signal w3rchx3_io  : std_logic :='0';
    42                                                   signal write_chs   : integer range 0 to 3;
    43                                                   signal write_s     : std_logic;
    44                                                   signal write_p     : std_logic;
    45                                                   signal tap0_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    46                                                   signal tap1_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    47                                                   signal tap2_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    48                                                   signal tap3_data   : std_logic_vector(dataWidth - 1 downto 0) := (others => '0');
    49                                               begin
    50                                                   process (aclk) begin
    51                                                       if (rising_edge(aclk)) then
    52              1                       5655                 write_s <=i_enable;
    53                                                       end if;
    54                                                   end process;
    55                                                   process (aclk) begin
    56                                                   if (rising_edge(aclk) ) then
    57                                                       if (write_p = '1') then
    58                                                           if (write_chs = 3) then
    59              1                    ***0***                     write_chs <= 0;
    60                                                           else
    61              1                    ***0***                     write_chs <= write_chs + 1;
    62                                                           end if;
    63                                                       end if;
    64                                                   end if;
    65                                                   end process;
    66              1                         15         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
    67              1                         10         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
    68              1                         10         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
    69              1                         10         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
    70              1                         10         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
    71                                                   process (aclk) begin
    72                                                       if (rising_edge(aclk) ) then
    73              1                       5655                 w1rchx0_io<=wrchx0_io;
    74              1                       5655                 w1rchx1_io<=wrchx1_io;
    75              1                       5655                 w1rchx2_io<=wrchx2_io;
    76              1                       5655                 w1rchx3_io<=wrchx3_io;
    77              1                       5655                 w2rchx0_io<=w1rchx0_io;
    78              1                       5655                 w2rchx1_io<=w1rchx1_io;
    79              1                       5655                 w2rchx2_io<=w1rchx2_io;
    80              1                       5655                 w2rchx3_io<=w1rchx3_io;
    81              1                       5655                 w3rchx0_io<=w2rchx0_io;
    82              1                       5655                 w3rchx1_io<=w2rchx1_io;
    83              1                       5655                 w3rchx2_io<=w2rchx2_io;
    84              1                       5655                 w3rchx3_io<=w2rchx3_io;
    85                                                       end if;
    86                                                   end process;
    87              1                          5         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
    88                                                   tap1_readout: process(aclk) begin
    89                                                   if (rising_edge(aclk) ) then
    90                                                       if(wrchx0_io ='1' or w1rchx0_io ='1'     or w2rchx0_io ='1' or w3rchx0_io ='1') then
    91              1                    ***0***                 taps0x <= tap1_data;
    92              1                    ***0***                 taps1x <= tap2_data;
    93              1                    ***0***                 taps2x <= tap3_data;
    94                                                       elsif(wrchx1_io ='1' or w1rchx1_io ='1'  or w2rchx1_io ='1' or w3rchx1_io ='1') then
    95              1                    ***0***                 taps0x <= tap2_data;
    96              1                    ***0***                 taps1x <= tap3_data;
    97              1                    ***0***                 taps2x <= tap0_data;
    98                                                       elsif(wrchx2_io ='1' or w1rchx2_io ='1'  or w2rchx2_io ='1' or w3rchx2_io ='1') then
    99              1                    ***0***                 taps0x <= tap3_data;
    100             1                    ***0***                 taps1x <= tap0_data;
    101             1                    ***0***                 taps2x <= tap1_data;
    102                                                      elsif(wrchx3_io ='1' or w1rchx3_io ='1'  or w2rchx3_io ='1' or w3rchx3_io ='1') then
    103             1                    ***0***                 taps0x <= tap0_data; 
    104             1                    ***0***                 taps1x <= tap1_data; 
    105             1                    ***0***                 taps2x <= tap2_data;		
    106                                                      else
    107             1                         10                 taps0x <= (others => '0');
    108             1                         10                 taps1x <= (others => '0');
    109             1                         10                 taps2x <= (others => '0');
    110                                                      end if;
    111                                                  end if;
    112                                                  end process tap1_readout;
    113                                              int_line_d0: tap_buffer
    114                                              generic map(
    115                                                  img_width    => img_width,
    116                                                  dataWidth    => dataWidth,
    117                                                  addrWidth    => addrWidth)
    118                                              port map(
    119                                                  write_clk => aclk, 
    120                                                  write_enb => wrchx0_io,
    121                                                  w_address => i_wadd(addrWidth - 1 downto 0),
    122                                                  idata     => i_data,
    123                                                  read_clk  => aclk, 
    124                                                  r_address => i_radd(addrWidth - 1 downto 0),
    125                                                  odata     => tap0_data);
    126                                              int_line_d1: tap_buffer
    127                                              generic map(
    128                                                  img_width    => img_width,
    129                                                  dataWidth    => dataWidth,
    130                                                  addrWidth    => addrWidth)
    131                                              port map(
    132                                                  write_clk => aclk, 
    133                                                  write_enb => wrchx1_io,
    134                                                  w_address => i_wadd(addrWidth - 1 downto 0),
    135                                                  idata     => i_data,
    136                                                  read_clk  => aclk, 
    137                                                  r_address => i_radd(addrWidth - 1 downto 0),
    138                                                  odata     => tap1_data);    
    139                                              int_line_d2: tap_buffer
    140                                              generic map(
    141                                                  img_width    => img_width,
    142                                                  dataWidth    => dataWidth,
    143                                                  addrWidth    => addrWidth)
    144                                              port map(
    145                                                  write_clk  => aclk, 
    146                                                  write_enb  => wrchx2_io,
    147                                                  w_address  => i_wadd(addrWidth - 1 downto 0),
    148                                                  idata      => i_data,
    149                                                  read_clk   => aclk, 
    150                                                  r_address  => i_radd(addrWidth - 1 downto 0),
    151                                                  odata      => tap2_data);
    152                                              int_line_d3: tap_buffer
    153                                              generic map(
    154                                                  img_width    => img_width,
    155                                                  dataWidth    => dataWidth,
    156                                                  addrWidth    => addrWidth)
    157                                              port map(
    158                                                  write_clk  => aclk,
    159                                                  write_enb  => wrchx3_io,
    160                                                  w_address  => i_wadd(addrWidth - 1 downto 0),
    161                                                  idata      => i_data,
    162                                                  read_clk   => aclk, 
    163                                                  r_address  => i_radd(addrWidth - 1 downto 0),
    164                                                  odata      => tap3_data);
    165                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        25        12        13      48.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/buffer_controller.vhd --

------------------------------------IF Branch------------------------------------
    51                                      5655     Count coming in to IF
    51              1                       5655             if (rising_edge(aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    56                                         5     Count coming in to IF
    56              1                          5         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         5     Count coming in to IF
    57              1                    ***0***             if (write_p = '1') then
                                               5     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    58                                   ***0***     Count coming in to IF
    58              1                    ***0***                 if (write_chs = 3) then
    60              1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    66                                        15     Count coming in to IF
    66              1                    ***0***         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
    66              2                         15         write_p   <= '1' when (write_s ='1' and i_enable ='0') else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    67                                        10     Count coming in to IF
    67              1                    ***0***         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
    67              2                         10         wrchx0_io <= '1' when (write_chs = 0 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    68                                        10     Count coming in to IF
    68              1                    ***0***         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
    68              2                         10         wrchx1_io <= '1' when (write_chs = 1 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    69                                        10     Count coming in to IF
    69              1                    ***0***         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
    69              2                         10         wrchx2_io <= '1' when (write_chs = 2 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    70                                        10     Count coming in to IF
    70              1                    ***0***         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
    70              2                         10         wrchx3_io <= '1' when (write_chs = 3 and i_enable ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    72                                      5655     Count coming in to IF
    72              1                       5655             if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    87                                         5     Count coming in to IF
    87              1                    ***0***         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
    87              2                          5         en_datao <= '1' when (w3rchx0_io ='1' or w3rchx1_io ='1' or w3rchx2_io ='1' or w3rchx3_io ='1')  else '0';
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    89                                        10     Count coming in to IF
    89              1                         10         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    90                                        10     Count coming in to IF
    90              1                    ***0***             if(wrchx0_io ='1' or w1rchx0_io ='1'     or w2rchx0_io ='1' or w3rchx0_io ='1') then
    94              1                    ***0***             elsif(wrchx1_io ='1' or w1rchx1_io ='1'  or w2rchx1_io ='1' or w3rchx1_io ='1') then
    98              1                    ***0***             elsif(wrchx2_io ='1' or w1rchx2_io ='1'  or w2rchx2_io ='1' or w3rchx2_io ='1') then
    102             1                    ***0***             elsif(wrchx3_io ='1' or w1rchx3_io ='1'  or w2rchx3_io ='1' or w3rchx3_io ='1') then
    106             1                         10             else
Branch totals: 1 hit of 5 branches = 20.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             30         0        30       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/buffer_controller.vhd --

----------------Focused Condition View-------------------
Line       66 Item    1  ((write_s = '1') and (i_enable = '0'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_s = '1')         N  '_1' not hit             Hit '_1'
  (i_enable = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_s = '1')_0     -                             
  Row   2:    ***0***  (write_s = '1')_1     (i_enable = '0')              
  Row   3:    ***0***  (i_enable = '0')_0    (write_s = '1')               
  Row   4:    ***0***  (i_enable = '0')_1    (write_s = '1')               

----------------Focused Condition View-------------------
Line       67 Item    1  ((write_chs = 0) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 0)         N  No hits                  Hit '_0' and '_1'
  (i_enable = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (write_chs = 0)_0     -                             
  Row   2:    ***0***  (write_chs = 0)_1     (i_enable = '1')              
  Row   3:          5  (i_enable = '1')_0    (write_chs = 0)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 0)               

----------------Focused Condition View-------------------
Line       68 Item    1  ((write_chs = 1) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 1)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 1)_0     -                             
  Row   2:    ***0***  (write_chs = 1)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 1)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 1)               

----------------Focused Condition View-------------------
Line       69 Item    1  ((write_chs = 2) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 2)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 2)_0     -                             
  Row   2:    ***0***  (write_chs = 2)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 2)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 2)               

----------------Focused Condition View-------------------
Line       70 Item    1  ((write_chs = 3) and (i_enable = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

        Input Term   Covered  Reason for no coverage   Hint
       -----------  --------  -----------------------  --------------
   (write_chs = 3)         N  '_1' not hit             Hit '_1'
  (i_enable = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (write_chs = 3)_0     -                             
  Row   2:    ***0***  (write_chs = 3)_1     (i_enable = '1')              
  Row   3:    ***0***  (i_enable = '1')_0    (write_chs = 3)               
  Row   4:    ***0***  (i_enable = '1')_1    (write_chs = 3)               

----------------Focused Condition View-------------------
Line       87 Item    1  ((((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1')) or (w3rchx3_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
  (w3rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx3_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (w3rchx0_io = '1')_0  not (w3rchx3_io = '1') && not (w3rchx2_io = '1') && not (w3rchx1_io = '1')
  Row   2:    ***0***  (w3rchx0_io = '1')_1  -                             
  Row   3:          5  (w3rchx1_io = '1')_0  not (w3rchx3_io = '1') && not (w3rchx2_io = '1') && not (w3rchx0_io = '1')
  Row   4:    ***0***  (w3rchx1_io = '1')_1  not (w3rchx0_io = '1')        
  Row   5:          5  (w3rchx2_io = '1')_0  not (w3rchx3_io = '1') && not ((w3rchx0_io = '1') or (w3rchx1_io = '1'))
  Row   6:    ***0***  (w3rchx2_io = '1')_1  not ((w3rchx0_io = '1') or (w3rchx1_io = '1'))
  Row   7:          5  (w3rchx3_io = '1')_0  not (((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1'))
  Row   8:    ***0***  (w3rchx3_io = '1')_1  not (((w3rchx0_io = '1') or (w3rchx1_io = '1')) or (w3rchx2_io = '1'))

----------------Focused Condition View-------------------
Line       90 Item    1  ((((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1')) or (w3rchx0_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx0_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx0_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx0_io = '1')_0   not (w3rchx0_io = '1') && not (w2rchx0_io = '1') && not (w1rchx0_io = '1')
  Row   2:    ***0***  (wrchx0_io = '1')_1   -                             
  Row   3:          5  (w1rchx0_io = '1')_0  not (w3rchx0_io = '1') && not (w2rchx0_io = '1') && not (wrchx0_io = '1')
  Row   4:    ***0***  (w1rchx0_io = '1')_1  not (wrchx0_io = '1')         
  Row   5:          5  (w2rchx0_io = '1')_0  not (w3rchx0_io = '1') && not ((wrchx0_io = '1') or (w1rchx0_io = '1'))
  Row   6:    ***0***  (w2rchx0_io = '1')_1  not ((wrchx0_io = '1') or (w1rchx0_io = '1'))
  Row   7:          5  (w3rchx0_io = '1')_0  not (((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1'))
  Row   8:    ***0***  (w3rchx0_io = '1')_1  not (((wrchx0_io = '1') or (w1rchx0_io = '1')) or (w2rchx0_io = '1'))

----------------Focused Condition View-------------------
Line       94 Item    1  ((((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1')) or (w3rchx1_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx1_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx1_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx1_io = '1')_0   not (w3rchx1_io = '1') && not (w2rchx1_io = '1') && not (w1rchx1_io = '1')
  Row   2:    ***0***  (wrchx1_io = '1')_1   -                             
  Row   3:          5  (w1rchx1_io = '1')_0  not (w3rchx1_io = '1') && not (w2rchx1_io = '1') && not (wrchx1_io = '1')
  Row   4:    ***0***  (w1rchx1_io = '1')_1  not (wrchx1_io = '1')         
  Row   5:          5  (w2rchx1_io = '1')_0  not (w3rchx1_io = '1') && not ((wrchx1_io = '1') or (w1rchx1_io = '1'))
  Row   6:    ***0***  (w2rchx1_io = '1')_1  not ((wrchx1_io = '1') or (w1rchx1_io = '1'))
  Row   7:          5  (w3rchx1_io = '1')_0  not (((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1'))
  Row   8:    ***0***  (w3rchx1_io = '1')_1  not (((wrchx1_io = '1') or (w1rchx1_io = '1')) or (w2rchx1_io = '1'))

----------------Focused Condition View-------------------
Line       98 Item    1  ((((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1')) or (w3rchx2_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx2_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx2_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx2_io = '1')_0   not (w3rchx2_io = '1') && not (w2rchx2_io = '1') && not (w1rchx2_io = '1')
  Row   2:    ***0***  (wrchx2_io = '1')_1   -                             
  Row   3:          5  (w1rchx2_io = '1')_0  not (w3rchx2_io = '1') && not (w2rchx2_io = '1') && not (wrchx2_io = '1')
  Row   4:    ***0***  (w1rchx2_io = '1')_1  not (wrchx2_io = '1')         
  Row   5:          5  (w2rchx2_io = '1')_0  not (w3rchx2_io = '1') && not ((wrchx2_io = '1') or (w1rchx2_io = '1'))
  Row   6:    ***0***  (w2rchx2_io = '1')_1  not ((wrchx2_io = '1') or (w1rchx2_io = '1'))
  Row   7:          5  (w3rchx2_io = '1')_0  not (((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1'))
  Row   8:    ***0***  (w3rchx2_io = '1')_1  not (((wrchx2_io = '1') or (w1rchx2_io = '1')) or (w2rchx2_io = '1'))

----------------Focused Condition View-------------------
Line       102 Item    1  ((((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1')) or (w3rchx3_io = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

          Input Term   Covered  Reason for no coverage   Hint
         -----------  --------  -----------------------  --------------
   (wrchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w1rchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w2rchx3_io = '1')         N  '_1' not hit             Hit '_1'
  (w3rchx3_io = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          5  (wrchx3_io = '1')_0   not (w3rchx3_io = '1') && not (w2rchx3_io = '1') && not (w1rchx3_io = '1')
  Row   2:    ***0***  (wrchx3_io = '1')_1   -                             
  Row   3:          5  (w1rchx3_io = '1')_0  not (w3rchx3_io = '1') && not (w2rchx3_io = '1') && not (wrchx3_io = '1')
  Row   4:    ***0***  (w1rchx3_io = '1')_1  not (wrchx3_io = '1')         
  Row   5:          5  (w2rchx3_io = '1')_0  not (w3rchx3_io = '1') && not ((wrchx3_io = '1') or (w1rchx3_io = '1'))
  Row   6:    ***0***  (w2rchx3_io = '1')_1  not ((wrchx3_io = '1') or (w1rchx3_io = '1'))
  Row   7:          5  (w3rchx3_io = '1')_0  not (((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1'))
  Row   8:    ***0***  (w3rchx3_io = '1')_1  not (((wrchx3_io = '1') or (w1rchx3_io = '1')) or (w2rchx3_io = '1'))


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/dataTaps.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           32        18        14      56.2

================================Statement Details================================

Statement Coverage for file ../modules/dut/dataTaps.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity dataTaps is
    9                                                generic (
    10                                                   img_width     : integer := 4096;
    11                                                   dataWidth     : integer := 12;
    12                                                   addrWidth     : integer := 12);
    13                                               port (
    14                                                   aclk          : in std_logic;
    15                                                   iRawData      : in rData;
    16                                                   oTpData       : out rTp);
    17                                               end entity;
    18                                               architecture arch of dataTaps is
    19                                                   signal d1RawData    :  rData;
    20                                                   signal d2RawData    :  rData;
    21                                               	signal wChx0Valid   : std_logic_vector(3 downto 0) := (others => lo);
    22                                               	signal wChx1Valid   : std_logic_vector(3 downto 0) := (others => lo);
    23                                               	signal wChx2Valid   : std_logic_vector(3 downto 0) := (others => lo);
    24                                               	signal wChx3Valid   : std_logic_vector(3 downto 0) := (others => lo);
    25                                                   signal write_chs    : integer range 0 to 3;
    26                                                   signal write_s      : std_logic;
    27                                                   signal write_p      : std_logic;
    28                                                   signal tap0_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    29                                                   signal tap1_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    30                                                   signal tap2_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    31                                                   signal tap3_data    : std_logic_vector(dataWidth - 1 downto 0) := (others => lo);
    32                                                   
    33                                               begin
    34                                               
    35              1                          3     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
    36              1                          2     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
    37              1                          2     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
    38              1                          2     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
    39              1                          2     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
    40              1                          1     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
    41                                               
    42                                               pipValidP: process (aclk) begin
    43                                                   if (rising_edge(aclk)) then
    44              1                       1131             write_s <= iRawData.valid;
    45                                                   end if;
    46                                               end process pipValidP;
    47                                               selChP: process (aclk) begin
    48                                                   if (rising_edge(aclk) ) then
    49                                                       if (write_p = hi) then
    50                                                           if (write_chs = ch3) then
    51              1                    ***0***                     write_chs <= ch0;
    52                                                           else
    53              1                    ***0***                     write_chs <= write_chs + 1;
    54                                                           end if;
    55                                                       end if;
    56                                                   end if;
    57                                               end process selChP;
    58                                               pipValidChP: process (aclk) begin
    59                                                   if (rising_edge(aclk) ) then
    60              1                          4             d1RawData     <= iRawData;
    61              1                          4             d2RawData     <= d1RawData;
    62              1                          4             oTpData.pEof  <= d2RawData.pEof;
    63              1                          4             oTpData.pSof  <= d2RawData.pSof;
    64              1                          4             oTpData.cord  <= d2RawData.cord;
    65              1                          4             wChx1Valid    <= wChx0Valid;
    66              1                          4             wChx2Valid    <= wChx1Valid;
    67              1                          4             wChx3Valid    <= wChx2Valid;
    68                                                   end if;
    69                                               end process pipValidChP;
    70                                               
    71                                               tap1ReadOutP: process(aclk) begin
    72                                                   if (rising_edge(aclk) ) then
    73                                                       if(wChx0Valid(ch0) = hi or wChx1Valid(ch0) = hi or wChx2Valid(ch0) = hi or wChx3Valid(ch0) = hi) then
    74              1                    ***0***                 oTpData.taps.tp1 <= tap1_data;
    75              1                    ***0***                 oTpData.taps.tp2 <= tap2_data;
    76              1                    ***0***                 oTpData.taps.tp3 <= tap3_data;
    77                                                       elsif(wChx0Valid(ch1) = hi or wChx1Valid(ch1) = hi or wChx2Valid(ch1) = hi or wChx3Valid(ch1) = hi) then
    78              1                    ***0***                 oTpData.taps.tp1 <= tap2_data;
    79              1                    ***0***                 oTpData.taps.tp2 <= tap3_data;
    80              1                    ***0***                 oTpData.taps.tp3 <= tap0_data;
    81                                                       elsif(wChx0Valid(ch2) = hi or wChx1Valid(ch2) = hi or wChx2Valid(ch2) = hi or wChx3Valid(ch2) = hi) then
    82              1                    ***0***                 oTpData.taps.tp1 <= tap3_data;
    83              1                    ***0***                 oTpData.taps.tp2 <= tap0_data;
    84              1                    ***0***                 oTpData.taps.tp3 <= tap1_data;
    85                                                       elsif(wChx0Valid(ch3) = hi or wChx1Valid(ch3) = hi or wChx2Valid(ch3) = hi or wChx3Valid(ch3) = hi) then
    86              1                    ***0***                 oTpData.taps.tp1 <= tap0_data; 
    87              1                    ***0***                 oTpData.taps.tp2 <= tap1_data; 
    88              1                    ***0***                 oTpData.taps.tp3 <= tap2_data;		
    89                                                       else
    90              1                          2                 oTpData.taps.tp1 <= (others => lo);
    91              1                          2                 oTpData.taps.tp2 <= (others => lo);
    92              1                          2                 oTpData.taps.tp3 <= (others => lo);
    93                                                       end if;
    94                                                   end if;
    95                                               end process tap1ReadOutP;
    96                                               lineD0Inst: tap_buffer
    97                                               generic map(
    98                                                   img_width    => img_width,
    99                                                   dataWidth    => dataWidth,
    100                                                  addrWidth    => addrWidth)
    101                                              port map(
    102                                                  write_clk => aclk, 
    103                                                  write_enb => wChx0Valid(ch0),
    104                                                  w_address => iRawData.cord.x(addrWidth -1 downto 0),
    105                                                  idata     => iRawData.data,
    106                                                  read_clk  => aclk, 
    107                                                  r_address => iRawData.cord.x(addrWidth -1 downto 0),
    108                                                  odata     => tap0_data);
    109                                              lineD1Inst: tap_buffer
    110                                              generic map(
    111                                                  img_width    => img_width,
    112                                                  dataWidth    => dataWidth,
    113                                                  addrWidth    => addrWidth)
    114                                              port map(
    115                                                  write_clk => aclk, 
    116                                                  write_enb => wChx0Valid(ch1),
    117                                                  w_address => iRawData.cord.x(addrWidth -1 downto 0),
    118                                                  idata     => iRawData.data,
    119                                                  read_clk  => aclk, 
    120                                                  r_address => iRawData.cord.x(addrWidth -1 downto 0),
    121                                                  odata     => tap1_data);    
    122                                              lineD2Inst: tap_buffer
    123                                              generic map(
    124                                                  img_width    => img_width,
    125                                                  dataWidth    => dataWidth,
    126                                                  addrWidth    => addrWidth)
    127                                              port map(
    128                                                  write_clk  => aclk, 
    129                                                  write_enb  => wChx0Valid(ch2),
    130                                                  w_address  => iRawData.cord.x(addrWidth -1 downto 0),
    131                                                  idata      => iRawData.data,
    132                                                  read_clk   => aclk, 
    133                                                  r_address  => iRawData.cord.x(addrWidth -1 downto 0),
    134                                                  odata      => tap2_data);
    135                                              lineD3Inst: tap_buffer
    136                                              generic map(
    137                                                  img_width    => img_width,
    138                                                  dataWidth    => dataWidth,
    139                                                  addrWidth    => addrWidth)
    140                                              port map(
    141                                                  write_clk  => aclk,
    142                                                  write_enb  => wChx0Valid(ch3),
    143                                                  w_address  => iRawData.cord.x(addrWidth -1 downto 0),
    144                                                  idata      => iRawData.data,
    145                                                  read_clk   => aclk, 
    146                                                  r_address  => iRawData.cord.x(addrWidth -1 downto 0),
    147                                                  odata      => tap3_data);
    148                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        25        12        13      48.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/dataTaps.vhd --

------------------------------------IF Branch------------------------------------
    35                                         3     Count coming in to IF
    35              1                    ***0***     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
    35              2                          3     write_p         <= hi when (write_s = hi and iRawData.valid = lo) else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    36                                         2     Count coming in to IF
    36              1                    ***0***     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
    36              2                          2     wChx0Valid(ch0) <= hi when (write_chs = ch0 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    37                                         2     Count coming in to IF
    37              1                    ***0***     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
    37              2                          2     wChx0Valid(ch1) <= hi when (write_chs = ch1 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    38                                         2     Count coming in to IF
    38              1                    ***0***     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
    38              2                          2     wChx0Valid(ch2) <= hi when (write_chs = ch2 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    39                                         2     Count coming in to IF
    39              1                    ***0***     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
    39              2                          2     wChx0Valid(ch3) <= hi when (write_chs = ch3 and iRawData.valid = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    40                                         1     Count coming in to IF
    40              1                    ***0***     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
    40              2                          1     oTpData.valid <= hi when (wChx3Valid(ch0) = hi or wChx3Valid(ch1) = hi or wChx3Valid(ch2) = hi or wChx3Valid(ch3) = hi)  else lo;
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    43                                      1131     Count coming in to IF
    43              1                       1131         if (rising_edge(aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    48                                         1     Count coming in to IF
    48              1                          1         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    49                                         1     Count coming in to IF
    49              1                    ***0***             if (write_p = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    50                                   ***0***     Count coming in to IF
    50              1                    ***0***                 if (write_chs = ch3) then
    52              1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    59                                         4     Count coming in to IF
    59              1                          4         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    72                                         2     Count coming in to IF
    72              1                          2         if (rising_edge(aclk) ) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    73                                         2     Count coming in to IF
    73              1                    ***0***             if(wChx0Valid(ch0) = hi or wChx1Valid(ch0) = hi or wChx2Valid(ch0) = hi or wChx3Valid(ch0) = hi) then
    77              1                    ***0***             elsif(wChx0Valid(ch1) = hi or wChx1Valid(ch1) = hi or wChx2Valid(ch1) = hi or wChx3Valid(ch1) = hi) then
    81              1                    ***0***             elsif(wChx0Valid(ch2) = hi or wChx1Valid(ch2) = hi or wChx2Valid(ch2) = hi or wChx3Valid(ch2) = hi) then
    85              1                    ***0***             elsif(wChx0Valid(ch3) = hi or wChx1Valid(ch3) = hi or wChx2Valid(ch3) = hi or wChx3Valid(ch3) = hi) then
    89              1                          2             else
Branch totals: 1 hit of 5 branches = 20.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             30         0        30       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/dataTaps.vhd --

----------------Focused Condition View-------------------
Line       35 Item    1  ((write_s = hi) and (iRawData.valid = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
         (write_s = hi)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_s = hi)_0         -                             
  Row   2:    ***0***  (write_s = hi)_1         (iRawData.valid = lo)         
  Row   3:    ***0***  (iRawData.valid = lo)_0  (write_s = hi)                
  Row   4:    ***0***  (iRawData.valid = lo)_1  (write_s = hi)                

----------------Focused Condition View-------------------
Line       36 Item    1  ((write_chs = ch0) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch0)         N  No hits                  Hit '_0' and '_1'
  (iRawData.valid = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (write_chs = ch0)_0      -                             
  Row   2:    ***0***  (write_chs = ch0)_1      (iRawData.valid = hi)         
  Row   3:          1  (iRawData.valid = hi)_0  (write_chs = ch0)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch0)             

----------------Focused Condition View-------------------
Line       37 Item    1  ((write_chs = ch1) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch1)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch1)_0      -                             
  Row   2:    ***0***  (write_chs = ch1)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch1)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch1)             

----------------Focused Condition View-------------------
Line       38 Item    1  ((write_chs = ch2) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch2)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch2)_0      -                             
  Row   2:    ***0***  (write_chs = ch2)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch2)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch2)             

----------------Focused Condition View-------------------
Line       39 Item    1  ((write_chs = ch3) and (iRawData.valid = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
      (write_chs = ch3)         N  '_1' not hit             Hit '_1'
  (iRawData.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (write_chs = ch3)_0      -                             
  Row   2:    ***0***  (write_chs = ch3)_1      (iRawData.valid = hi)         
  Row   3:    ***0***  (iRawData.valid = hi)_0  (write_chs = ch3)             
  Row   4:    ***0***  (iRawData.valid = hi)_1  (write_chs = ch3)             

----------------Focused Condition View-------------------
Line       40 Item    1  ((((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi)) or (wChx3Valid(3) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx3Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(3) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx3Valid(0) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx3Valid(2) = hi) && not (wChx3Valid(1) = hi)
  Row   2:    ***0***  (wChx3Valid(0) = hi)_1  -                             
  Row   3:          1  (wChx3Valid(1) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx3Valid(2) = hi) && not (wChx3Valid(0) = hi)
  Row   4:    ***0***  (wChx3Valid(1) = hi)_1  not (wChx3Valid(0) = hi)      
  Row   5:          1  (wChx3Valid(2) = hi)_0  not (wChx3Valid(3) = hi) && not ((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi))
  Row   6:    ***0***  (wChx3Valid(2) = hi)_1  not ((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi))
  Row   7:          1  (wChx3Valid(3) = hi)_0  not (((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi))
  Row   8:    ***0***  (wChx3Valid(3) = hi)_1  not (((wChx3Valid(0) = hi) or (wChx3Valid(1) = hi)) or (wChx3Valid(2) = hi))

----------------Focused Condition View-------------------
Line       73 Item    1  ((((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi)) or (wChx3Valid(0) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(0) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(0) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not (wChx2Valid(0) = hi) && not (wChx1Valid(0) = hi)
  Row   2:    ***0***  (wChx0Valid(0) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not (wChx2Valid(0) = hi) && not (wChx0Valid(0) = hi)
  Row   4:    ***0***  (wChx1Valid(0) = hi)_1  not (wChx0Valid(0) = hi)      
  Row   5:          1  (wChx2Valid(0) = hi)_0  not (wChx3Valid(0) = hi) && not ((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi))
  Row   6:    ***0***  (wChx2Valid(0) = hi)_1  not ((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi))
  Row   7:          1  (wChx3Valid(0) = hi)_0  not (((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi))
  Row   8:    ***0***  (wChx3Valid(0) = hi)_1  not (((wChx0Valid(0) = hi) or (wChx1Valid(0) = hi)) or (wChx2Valid(0) = hi))

----------------Focused Condition View-------------------
Line       77 Item    1  ((((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi)) or (wChx3Valid(1) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(1) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(1) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not (wChx2Valid(1) = hi) && not (wChx1Valid(1) = hi)
  Row   2:    ***0***  (wChx0Valid(1) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not (wChx2Valid(1) = hi) && not (wChx0Valid(1) = hi)
  Row   4:    ***0***  (wChx1Valid(1) = hi)_1  not (wChx0Valid(1) = hi)      
  Row   5:          1  (wChx2Valid(1) = hi)_0  not (wChx3Valid(1) = hi) && not ((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi))
  Row   6:    ***0***  (wChx2Valid(1) = hi)_1  not ((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi))
  Row   7:          1  (wChx3Valid(1) = hi)_0  not (((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi))
  Row   8:    ***0***  (wChx3Valid(1) = hi)_1  not (((wChx0Valid(1) = hi) or (wChx1Valid(1) = hi)) or (wChx2Valid(1) = hi))

----------------Focused Condition View-------------------
Line       81 Item    1  ((((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi)) or (wChx3Valid(2) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(2) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(2) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not (wChx2Valid(2) = hi) && not (wChx1Valid(2) = hi)
  Row   2:    ***0***  (wChx0Valid(2) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not (wChx2Valid(2) = hi) && not (wChx0Valid(2) = hi)
  Row   4:    ***0***  (wChx1Valid(2) = hi)_1  not (wChx0Valid(2) = hi)      
  Row   5:          1  (wChx2Valid(2) = hi)_0  not (wChx3Valid(2) = hi) && not ((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi))
  Row   6:    ***0***  (wChx2Valid(2) = hi)_1  not ((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi))
  Row   7:          1  (wChx3Valid(2) = hi)_0  not (((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi))
  Row   8:    ***0***  (wChx3Valid(2) = hi)_1  not (((wChx0Valid(2) = hi) or (wChx1Valid(2) = hi)) or (wChx2Valid(2) = hi))

----------------Focused Condition View-------------------
Line       85 Item    1  ((((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi)) or (wChx3Valid(3) = hi))
Condition totals: 0 of 4 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (wChx0Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx1Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx2Valid(3) = hi)         N  '_1' not hit             Hit '_1'
  (wChx3Valid(3) = hi)         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (wChx0Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx2Valid(3) = hi) && not (wChx1Valid(3) = hi)
  Row   2:    ***0***  (wChx0Valid(3) = hi)_1  -                             
  Row   3:          1  (wChx1Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not (wChx2Valid(3) = hi) && not (wChx0Valid(3) = hi)
  Row   4:    ***0***  (wChx1Valid(3) = hi)_1  not (wChx0Valid(3) = hi)      
  Row   5:          1  (wChx2Valid(3) = hi)_0  not (wChx3Valid(3) = hi) && not ((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi))
  Row   6:    ***0***  (wChx2Valid(3) = hi)_1  not ((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi))
  Row   7:          1  (wChx3Valid(3) = hi)_0  not (((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi))
  Row   8:    ***0***  (wChx3Valid(3) = hi)_1  not (((wChx0Valid(3) = hi) or (wChx1Valid(3) = hi)) or (wChx2Valid(3) = hi))


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/detect.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            5         4         1      80.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/detect.vhd --

    1                                                --05022019 [05-02-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity detect is
    9                                                generic (
    10                                                   i_data_width   : integer := 8);
    11                                               port (
    12                                                   clk            : in std_logic;
    13                                                   rst_l          : in std_logic;
    14                                                   iRgb           : in channel;
    15                                                   oRgb           : out channel;
    16                                                   rgbCoord       : in region;
    17                                                   iCord          : in coord;
    18                                                   endOfFrame     : in std_logic;
    19                                                   pDetect        : out std_logic);
    20                                               end entity;
    21                                               architecture arch of detect is
    22                                                   signal pEnable         : std_logic;
    23                                                   signal pCont           : cord;
    24                                               begin
    25              1                          2     pDetect        <= pEnable;
    26                                               pixelRangeP: process (clk)begin
    27                                               if rising_edge(clk) then
    28                                                   if((iRgb.red>rgbCoord.rl and iRgb.red<rgbCoord.rh) and (iRgb.green>rgbCoord.gl and iRgb.green<rgbCoord.gh) and (iRgb.blue>rgbCoord.bl and iRgb.blue<rgbCoord.bh))then
    29              1                    ***0***             pEnable <= hi;
    30                                                   else
    31              1                          3             pEnable <= lo;
    32                                                   end if;
    33                                               end if;
    34                                               end process pixelRangeP;
    35                                               pipCordP: process (clk)begin
    36                                                   if rising_edge(clk) then
    37              1                          2             pCont.x      <= to_integer((unsigned(iCord.x)));
    38              1                          2             pCont.y      <= to_integer((unsigned(iCord.y)));
    39                                                   end if;
    40                                               end process pipCordP;
    41                                               --pixelCordInt : pixelCord
    42                                               --port map(
    43                                               --    clk      => clk,
    44                                               --    iRgb     => iRgb,
    45                                               --    iPixelEn => pEnable,
    46                                               --    iEof     => endOfFrame,
    47                                               --    iCord    => pCont,
    48                                               --    oRgb     => oRgb);
    49                                               end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         4         3         1      75.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/detect.vhd --

------------------------------------IF Branch------------------------------------
    27                                         3     Count coming in to IF
    27              1                          3     if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    28                                         3     Count coming in to IF
    28              1                    ***0***         if((iRgb.red>rgbCoord.rl and iRgb.red<rgbCoord.rh) and (iRgb.green>rgbCoord.gl and iRgb.green<rgbCoord.gh) and (iRgb.blue>rgbCoord.bl and iRgb.blue<rgbCoord.bh))then
    30              1                          3         else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    36                                         2     Count coming in to IF
    36              1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              6         0         6       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/detect.vhd --

----------------Focused Condition View-------------------
Line       28 Item    1  ((((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) and ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)))
Condition totals: 0 of 6 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
    (iRgb.red > rgbCoord.rl)         N  '_1' not hit             Hit '_1'
    (iRgb.red < rgbCoord.rh)         N  '_1' not hit             Hit '_1'
  (iRgb.green > rgbCoord.gl)         N  No hits                  Hit '_0' and '_1'
  (iRgb.green < rgbCoord.gh)         N  No hits                  Hit '_0' and '_1'
   (iRgb.blue > rgbCoord.bl)         N  No hits                  Hit '_0' and '_1'
   (iRgb.blue < rgbCoord.bh)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:          1  (iRgb.red > rgbCoord.rl)_0    -                             
  Row   2:    ***0***  (iRgb.red > rgbCoord.rl)_1    ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)) && (iRgb.red < rgbCoord.rh)
  Row   3:          1  (iRgb.red < rgbCoord.rh)_0    (iRgb.red > rgbCoord.rl)      
  Row   4:    ***0***  (iRgb.red < rgbCoord.rh)_1    ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)) && (iRgb.red > rgbCoord.rl)
  Row   5:    ***0***  (iRgb.green > rgbCoord.gl)_0  ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh))
  Row   6:    ***0***  (iRgb.green > rgbCoord.gl)_1  ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green < rgbCoord.gh)
  Row   7:    ***0***  (iRgb.green < rgbCoord.gh)_0  ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green > rgbCoord.gl)
  Row   8:    ***0***  (iRgb.green < rgbCoord.gh)_1  ((iRgb.blue > rgbCoord.bl) and (iRgb.blue < rgbCoord.bh)) && ((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) && (iRgb.green > rgbCoord.gl)
  Row   9:    ***0***  (iRgb.blue > rgbCoord.bl)_0   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh)))
 Row   10:    ***0***  (iRgb.blue > rgbCoord.bl)_1   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue < rgbCoord.bh)
 Row   11:    ***0***  (iRgb.blue < rgbCoord.bh)_0   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue > rgbCoord.bl)
 Row   12:    ***0***  (iRgb.blue < rgbCoord.bh)_1   (((iRgb.red > rgbCoord.rl) and (iRgb.red < rgbCoord.rh)) and ((iRgb.green > rgbCoord.gl) and (iRgb.green < rgbCoord.gh))) && (iRgb.blue > rgbCoord.bl)


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/digiClk.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           12         4         8      33.3

================================Statement Details================================

Statement Coverage for file ../modules/dut/digiClk.vhd --

    1                                                --02072019 [02-07-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.std_logic_arith.all;
    5                                                use ieee.std_logic_unsigned.all;
    6                                                use work.constantspackage.all;
    7                                                use work.vpfRecords.all;
    8                                                --source clock 142.857132 instead 150 = half p 71428566 else if 75= 37500000*2
    9                                                --source clock 100Mhz = half p 50000000 but to sec in per ms 50000
    10                                               entity digiClk is
    11                                                   port (
    12                                                   clk1    : in std_logic;
    13                                                   seconds : out std_logic_vector(5 downto 0);
    14                                                   minutes : out std_logic_vector(5 downto 0);
    15                                                   hours   : out std_logic_vector(4 downto 0));
    16                                               end digiClk;
    17                                               architecture Behavioral of digiClk is
    18                                               constant HALFPERIOD     : integer   := 71428566;--@142.8MHz= 1/2sec for HARDWARE
    19                                               constant TESTHALFPERIOD : integer   := 50000;--@100MHz= 1/2ms
    20                                               signal sec,min,hour     : integer range 0 to 60 :=0;
    21                                               signal count            : integer   := 1;
    22                                               signal clk              : std_logic :='0';
    23                                               begin
    24              1                          1         seconds <= conv_std_logic_vector(sec,6);
    25              1                          1         minutes <= conv_std_logic_vector(min,6);
    26              1                          1         hours   <= conv_std_logic_vector(hour,5);
    27                                               process(clk1)begin
    28                                                   if(clk1'event and clk1='1') then
    29              1                       1131             count <=count + 1;
    30                                                       if(count = HALFPERIOD) then
    31              1                    ***0***                 clk     <= not clk;
    32              1                    ***0***                 count   <=1;
    33                                                       end if;
    34                                                   end if;
    35                                               end process;
    36                                               process(clk)begin
    37                                                   if(clk'event and clk='1') then
    38              1                    ***0***             sec <= sec+ 1;
    39                                                       if(sec = 59) then
    40              1                    ***0***                 sec<=0;
    41              1                    ***0***                 min <= min + 1;
    42                                                           if(min = 59) then
    43              1                    ***0***                     hour <= hour + 1;
    44              1                    ***0***                     min <= 0;
    45                                                               if(hour = 23) then
    46              1                    ***0***                         hour <= 0;
    47                                                               end if;
    48                                                           end if;
    49                                                       end if;
    50                                                   end if;
    51                                               end process;
    52                                               end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        10         2         8      20.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/digiClk.vhd --

------------------------------------IF Branch------------------------------------
    28                                      1131     Count coming in to IF
    28              1                       1131         if(clk1'event and clk1='1') then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    30                                      1131     Count coming in to IF
    30              1                    ***0***             if(count = HALFPERIOD) then
                                            1131     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    37                                   ***0***     Count coming in to IF
    37              1                    ***0***         if(clk'event and clk='1') then
                                            ECOP     All False Count
Branch totals: 0 hits of 1 branch = 0.0%

------------------------------------IF Branch------------------------------------
    39                                   ***0***     Count coming in to IF
    39              1                    ***0***             if(sec = 59) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    42                                   ***0***     Count coming in to IF
    42              1                    ***0***                 if(min = 59) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    45                                   ***0***     Count coming in to IF
    45              1                    ***0***                     if(hour = 23) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/frameProcess.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           40        40         0     100.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/frameProcess.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity frameProcess is
    9                                                generic (
    10                                                   i_data_width            : integer := 8;
    11                                                   s_data_width            : integer := 16;
    12                                                   b_data_width            : integer := 32;
    13                                                   img_width               : integer := 256;
    14                                                   adwrWidth               : integer := 16;
    15                                                   addrWidth               : integer := 12);
    16                                               port (
    17                                                   clk                     : in std_logic;
    18                                                   rst_l                   : in std_logic;
    19                                                   iRgbSet                 : in rRgb;
    20                                                   --cpu side in
    21                                                   iRgbCoord               : in region;
    22                                                   iPoiRegion              : in poi;
    23                                                   iKls                    : in coefficient;
    24                                                   iAls                    : in coefficient;
    25                                                   iEdgeType               : in std_logic_vector(b_data_width-1 downto 0);
    26                                                   iThreshold              : in std_logic_vector(s_data_width-1 downto 0); 
    27                                                   --out
    28                                                   oFrameData              : out fcolors;
    29                                                   --to cpu
    30                                                   oFifoStatus             : out std_logic_vector(b_data_width-1 downto 0);
    31                                                   oGridLockData           : out std_logic_vector(b_data_width-1 downto 0));
    32                                               end entity;
    33                                               architecture arch of frameProcess is
    34                                                   signal sharp            : channel;
    35                                                   signal rgbV1Correct     : channel;
    36                                                   signal rgbV2Correct     : channel;
    37                                                   signal soble            : channel;
    38                                                   signal rgbRemix         : channel;
    39                                                   signal rgbPoi           : channel;
    40                                                   signal blur1vx          : channel;
    41                                                   signal blur2vx          : channel;
    42                                                   signal blur3vx          : channel;
    43                                                   signal blur4vx          : channel;
    44                                                   signal rgbDetect        : channel;
    45                                                   signal hsv              : hsvChannel;
    46                                                   signal hsl              : hsvChannel;
    47                                                   signal hsvCcBlur4vx     : hsvChannel;
    48                                                   signal cord             : coord;
    49                                                   signal syncxy           : coord;
    50                                                   signal cordIn           : coord;
    51                                                   signal rgbIn            : channel;
    52                                                   signal rgbSum           : tpRgb;
    53                                                   signal rgbDetectLock    : std_logic;
    54                                                   signal rgbPoiLock       : std_logic;
    55                                                   signal edgeValid        : std_logic;
    56                                                   signal sValid           : std_logic;
    57                                               begin
    58              1                          1         oFrameData.hsl.red            <= hsl.h;
    59              1                          1         oFrameData.hsl.green          <= hsl.s;
    60              1                          1         oFrameData.hsl.blue           <= hsl.v;
    61              1                          1         oFrameData.hsl.valid          <= hsl.valid;
    62              1                          1         oFrameData.hsv.red            <= hsv.h;
    63              1                          1         oFrameData.hsv.green          <= hsv.s;
    64              1                          1         oFrameData.hsv.blue           <= hsv.v;
    65              1                          1         oFrameData.hsv.valid          <= hsv.valid;
    66              1                          1         oFrameData.hsvCcBl.red        <= hsvCcBlur4vx.h;
    67              1                          1         oFrameData.hsvCcBl.green      <= hsvCcBlur4vx.s;
    68              1                          1         oFrameData.hsvCcBl.blue       <= hsvCcBlur4vx.v;
    69              1                          1         oFrameData.hsvCcBl.valid      <= hsvCcBlur4vx.valid;
    70              1                          2         oFrameData.rgb.red            <= iRgbSet.red;
    71              1                          2         oFrameData.rgb.green          <= iRgbSet.green;
    72              1                          2         oFrameData.rgb.blue           <= iRgbSet.blue;
    73              1                          2         oFrameData.rgb.valid          <= iRgbSet.valid;
    74              1                          4         oFrameData.sharp              <= sharp;
    75              1                          3         oFrameData.blur1x             <= blur1vx;
    76              1                          3         oFrameData.blur2x             <= blur2vx;
    77              1                          3         oFrameData.blur3x             <= blur3vx;
    78              1                          3         oFrameData.blur4x             <= blur4vx;
    79              1                          1         oFrameData.rgbCorrect         <= rgbV1Correct;
    80              1                          1         oFrameData.soble              <= soble;
    81              1                          1         oFrameData.rgbRemix           <= rgbRemix;
    82              1                          1         oFrameData.rgbDetect          <= rgbDetect;
    83              1                          1         oFrameData.rgbPoi             <= rgbPoi;
    84              1                          1         oFrameData.rgbSum             <= rgbSum;
    85              1                          2         oFrameData.rgbDetectLock      <= rgbDetectLock;
    86              1                          2         oFrameData.rgbPoiLock         <= rgbPoiLock;
    87              1                          2         oFrameData.cod                <= syncxy;
    88              1                          2         oFrameData.pEof               <= iRgbSet.pEof;
    89              1                          2         oFrameData.pSof               <= iRgbSet.pSof;
    90              1                          2         rgbIn.red                     <= iRgbSet.red;
    91              1                          2         rgbIn.green                   <= iRgbSet.green;
    92              1                          2         rgbIn.blue                    <= iRgbSet.blue;
    93              1                          2         rgbIn.valid                   <= iRgbSet.valid;
    94              1                          2         cordIn.x                      <= iRgbSet.cord.x;
    95              1                          2         cordIn.y                      <= iRgbSet.cord.y;
    96                                               pipCoordP: process (clk) begin
    97                                                   if rising_edge(clk) then
    98              1                          3             syncxy          <= cordIn;
    99              1                          3             cord            <= syncxy;
    100                                                  end if;
    101                                              end process pipCoordP;
    102                                              colorCorrectionInst: colorCorrection
    103                                              generic map(
    104                                                  i_data_width        => i_data_width)
    105                                              port map(           
    106                                                  clk                 => clk,
    107                                                  rst_l               => rst_l,
    108                                                  iRgb                => rgbIn,
    109                                                  als                 => iAls,    
    110                                                  oRgb                => rgbV1Correct);
    111                                              sobelFilterInst: sobelFilter
    112                                              generic map(
    113                                                  i_data_width        => i_data_width,
    114                                                  img_width           => img_width,
    115                                                  adwrWidth           => adwrWidth,
    116                                                  addrWidth           => addrWidth)
    117                                              port map(   
    118                                                  clk                 => clk,
    119                                                  rst_l               => rst_l,
    120                                                  iEdgeType           => iEdgeType,
    121                                                  endOfFrame          => iRgbSet.pEof,
    122                                                  iRgb                => rgbIn,
    123                                                  threshold           => iThreshold,
    124                                                  kls                 => iKls,
    125                                                  oRgb                => soble,
    126                                                  sValid              => sValid,
    127                                                  edgeValid           => edgeValid);
    128                                              edgeObjectsInst: edgeObjects
    129                                              generic map(
    130                                                  i_data_width        => i_data_width)
    131                                              port map(   
    132                                                  clk                 => clk,
    133                                                  rst_l               => rst_l,
    134                                                  iRgb                => rgbIn,
    135                                                  bRgb                => blur1vx,
    136                                                  sRgb                => sharp,
    137                                                  edgeValid           => edgeValid,
    138                                                  sValid              => sValid,
    139                                                  oRgbRemix           => rgbRemix);
    140                                              sharpFilterInst: sharpFilter
    141                                              generic map(
    142                                                  i_data_width        => i_data_width,
    143                                                  img_width           => img_width,
    144                                                  adwrWidth           => adwrWidth,
    145                                                  addrWidth           => addrWidth)
    146                                              port map(   
    147                                                  clk                 => clk,
    148                                                  rst_l               => rst_l,
    149                                                  iRgb                => rgbIn,
    150                                                  endOfFrame          => iRgbSet.pEof,
    151                                                  kls                 => iKls,
    152                                                  oRgb                => sharp);
    153                                              blurFilter1xInst: blurFilter
    154                                              generic map(
    155                                                  iMSB                => blurMsb,
    156                                                  iLSB                => blurLsb,
    157                                                  i_data_width        => i_data_width,
    158                                                  img_width           => img_width,
    159                                                  adwrWidth           => adwrWidth,
    160                                                  addrWidth           => addrWidth)
    161                                              port map(
    162                                                  clk                 => clk,
    163                                                  rst_l               => rst_l,
    164                                                  iRgb                => rgbIn,
    165                                                  oRgb                => blur1vx);
    166                                              blurFilter2xInst: blurFilter
    167                                              generic map(
    168                                                  iMSB                => blurMsb - 1,
    169                                                  iLSB                => blurLsb - 1,
    170                                                  i_data_width        => i_data_width,
    171                                                  img_width           => img_width,
    172                                                  adwrWidth           => adwrWidth,
    173                                                  addrWidth           => addrWidth)
    174                                              port map(
    175                                                  clk                 => clk,
    176                                                  rst_l               => rst_l,
    177                                                  iRgb                => blur1vx,
    178                                                  oRgb                => blur2vx);
    179                                              blurFilter3xInst: blurFilter
    180                                              generic map(
    181                                                  iMSB                => blurMsb - 1,
    182                                                  iLSB                => blurLsb - 1,
    183                                                  i_data_width        => i_data_width,
    184                                                  img_width           => img_width,
    185                                                  adwrWidth           => adwrWidth,
    186                                                  addrWidth           => addrWidth)
    187                                              port map(
    188                                                  clk                 => clk,
    189                                                  rst_l               => rst_l,
    190                                                  iRgb                => blur2vx,
    191                                                  oRgb                => blur3vx);
    192                                              blurFilter4xInst: blurFilter
    193                                              generic map(
    194                                                  iMSB                => blurMsb - 1,
    195                                                  iLSB                => blurLsb - 1,
    196                                                  i_data_width        => i_data_width,
    197                                                  img_width           => img_width,
    198                                                  adwrWidth           => adwrWidth,
    199                                                  addrWidth           => addrWidth)
    200                                              port map(
    201                                                  clk                 => clk,
    202                                                  rst_l               => rst_l,
    203                                                  iRgb                => blur3vx,
    204                                                  oRgb                => blur4vx);
    205                                              colorCorrection1Inst: colorCorrection
    206                                              generic map(
    207                                                  i_data_width        => i_data_width)
    208                                              port map(           
    209                                                  clk                 => clk,
    210                                                  rst_l               => rst_l,
    211                                                  iRgb                => blur4vx,
    212                                                  als                 => iAls,    
    213                                                  oRgb                => rgbV2Correct);
    214                                              hsv_blur4xInst: hsv_c
    215                                              generic map(
    216                                                  i_data_width        => i_data_width)
    217                                              port map(   
    218                                                  clk                 => clk,
    219                                                  reset               => rst_l,
    220                                                  iRgb                => rgbV2Correct,
    221                                                  oHsv                => hsvCcBlur4vx);
    222                                              detectInst: detect
    223                                              generic map(
    224                                                  i_data_width        => i_data_width)
    225                                              port map(
    226                                                  clk                 => clk,
    227                                                  rst_l               => rst_l,
    228                                                  iRgb                => rgbIn,
    229                                                  rgbCoord            => iRgbCoord,
    230                                                  endOfFrame          => iRgbSet.pEof,
    231                                                  iCord               => cord,
    232                                                  pDetect             => rgbDetectLock,
    233                                                  oRgb                => rgbDetect);
    234                                              pointOfInterestInst: pointOfInterest
    235                                              generic map(
    236                                                  i_data_width        => i_data_width,
    237                                                  s_data_width        => s_data_width,
    238                                                  b_data_width        => b_data_width)
    239                                              port map(
    240                                                  clk                 => clk,
    241                                                  rst_l               => rst_l,
    242                                                  iRgb                => rgbIn,
    243                                                  iCord               => cord,
    244                                                  endOfFrame          => iRgbSet.pEof,
    245                                                  gridLockDatao       => oGridLockData,
    246                                                  pRegion             => iPoiRegion,
    247                                                  fifoStatus          => oFifoStatus,
    248                                                  oGridLocation       => rgbPoiLock,
    249                                                  oRgb                => rgbPoi);
    250                                              hslInst: hsl_c
    251                                              generic map(
    252                                                  i_data_width        => i_data_width)
    253                                              port map(   
    254                                                  clk                 => clk,
    255                                                  reset               => rst_l,
    256                                                  iRgb                => rgbIn,
    257                                                  oHsl                => hsl);
    258                                              hsvInst: hsv_c
    259                                              generic map(
    260                                                  i_data_width        => i_data_width)
    261                                              port map(   
    262                                                  clk                 => clk,
    263                                                  reset               => rst_l,
    264                                                  iRgb                => rgbIn,
    265                                                  oHsv                => hsv);
    266                                              -- frameTestPatternInst: frameTestPattern
    267                                              -- generic map(
    268                                                  -- s_data_width        => s_data_width)
    269                                              -- port map(   
    270                                                  -- clk                 => clk,
    271                                                  -- iValid              => rgbIn.valid,
    272                                                  -- iCord               => cord,
    273                                                  -- oRgb                => rgbSum);
    274                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         1         1         0     100.0

================================Branch Details================================

Branch Coverage for file ../modules/dut/frameProcess.vhd --

------------------------------------IF Branch------------------------------------
    97                                         3     Count coming in to IF
    97              1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/mWrRd.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           95        95         0     100.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/mWrRd.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity mWrRd is
    9                                                generic (
    10                                                   revision_number  : std_logic_vector(31 downto 0) := x"00000000";
    11                                                   s_data_width     : integer    := 16;
    12                                                   b_data_width     : integer    := 32);
    13                                               port (
    14                                                   seconds          : in std_logic_vector(5 downto 0);
    15                                                   minutes          : in std_logic_vector(5 downto 0);
    16                                                   hours            : in std_logic_vector(4 downto 0);
    17                                                   rgbCoord         : out region;
    18                                                   aBusSelect       : out std_logic_vector(b_data_width-1 downto 0);
    19                                                   threshold        : out std_logic_vector(s_data_width -1 downto 0);
    20                                                   videoChannel     : out std_logic_vector(b_data_width-1 downto 0);
    21                                                   dChannel         : out std_logic_vector(b_data_width-1 downto 0);
    22                                                   cChannel         : out std_logic_vector(b_data_width-1 downto 0);
    23                                                   oRgbOsharp       : out std_logic_vector(b_data_width-1 downto 0);
    24                                                   oEdgeType        : out std_logic_vector(b_data_width-1 downto 0);
    25                                                   pRegion          : out poi;
    26                                                   als              : out coefficient;
    27                                                   kls              : out coefficient;
    28                                                   fifoStatus       : in std_logic_vector(b_data_width-1 downto 0);
    29                                                   gridLockDatao    : in std_logic_vector(b_data_width-1 downto 0);
    30                                                   wrRegsIn         : in mRegs;
    31                                                   rdRegsOut        : out mRegs);
    32                                               end mWrRd;
    33                                               architecture Behavioral of mWrRd is
    34                                               begin
    35              1                          2         oRgbOsharp              <= wrRegsIn.cfigReg0;
    36              1                          2         oEdgeType               <= wrRegsIn.cfigReg1;
    37              1                          2         aBusSelect              <= wrRegsIn.cfigReg3;
    38              1                          2         threshold               <= wrRegsIn.cfigReg4(s_data_width -1 downto 0);
    39              1                          2         videoChannel            <= wrRegsIn.cfigReg5;
    40              1                          2         dChannel                <= wrRegsIn.cfigReg6;
    41              1                          2         cChannel                <= wrRegsIn.cfigReg7;
    42              1                          2         kls.k1                  <= wrRegsIn.cfigReg8;
    43              1                          2         kls.k2                  <= wrRegsIn.cfigReg9;
    44              1                          2         kls.k3                  <= wrRegsIn.cfigReg10;
    45              1                          2         kls.k4                  <= wrRegsIn.cfigReg11;
    46              1                          2         kls.k5                  <= wrRegsIn.cfigReg12;
    47              1                          2         kls.k6                  <= wrRegsIn.cfigReg13;
    48              1                          2         kls.k7                  <= wrRegsIn.cfigReg14;
    49              1                          2         kls.k8                  <= wrRegsIn.cfigReg15;
    50              1                          2         kls.k9                  <= wrRegsIn.cfigReg16;
    51              1                          2         kls.config              <= to_integer(unsigned(wrRegsIn.cfigReg17));
    52              1                          2         als.k1                  <= wrRegsIn.cfigReg21;
    53              1                          2         als.k2                  <= wrRegsIn.cfigReg22;
    54              1                          2         als.k3                  <= wrRegsIn.cfigReg23;
    55              1                          2         als.k4                  <= wrRegsIn.cfigReg24;
    56              1                          2         als.k5                  <= wrRegsIn.cfigReg25;
    57              1                          2         als.k6                  <= wrRegsIn.cfigReg26;
    58              1                          2         als.k7                  <= wrRegsIn.cfigReg27;
    59              1                          2         als.k8                  <= wrRegsIn.cfigReg28;
    60              1                          2         als.k9                  <= wrRegsIn.cfigReg29;
    61              1                          2         als.config              <= to_integer(unsigned(wrRegsIn.cfigReg30));
    62              1                          2         pRegion.pointInterest   <= to_integer(unsigned(wrRegsIn.cfigReg31(s_data_width -1 downto 0)));--set the point
    63              1                          2         pRegion.deltaConfig     <= to_integer(unsigned(wrRegsIn.cfigReg32(s_data_width -1 downto 0)));--set the point delta
    64              1                          2         pRegion.cpuAckGoAgain   <= wrRegsIn.cfigReg33(0);
    65              1                          2         pRegion.cpuWgridLock    <= wrRegsIn.cfigReg34(0);
    66              1                          2         pRegion.cpuAckoffFrame  <= wrRegsIn.cfigReg35(0);
    67              1                          2         pRegion.fifoReadAddress <= wrRegsIn.cfigReg36(13 downto 0);--fifo read address location upto cpuGridCont[Max-Locations]
    68              1                          2         pRegion.fifoReadEnable  <= wrRegsIn.cfigReg36(16);--fifo read enable
    69              1                          2         pRegion.clearFifoData   <= wrRegsIn.cfigReg37(0);--clear the fifo
    70              1                          2         rgbCoord.rl             <= wrRegsIn.cfigReg50(7 downto 0);
    71              1                          2         rgbCoord.rh             <= wrRegsIn.cfigReg51(7 downto 0);
    72              1                          2         rgbCoord.gl             <= wrRegsIn.cfigReg52(7 downto 0);
    73              1                          2         rgbCoord.gh             <= wrRegsIn.cfigReg53(7 downto 0);
    74              1                          2         rgbCoord.bl             <= wrRegsIn.cfigReg54(7 downto 0);
    75              1                          2         rgbCoord.bh             <= wrRegsIn.cfigReg55(7 downto 0);
    76              1                          2         rdRegsOut.cfigReg0      <= wrRegsIn.cfigReg0;
    77              1                          2         rdRegsOut.cfigReg1      <= wrRegsIn.cfigReg1;
    78              1                          2         rdRegsOut.cfigReg2      <= wrRegsIn.cfigReg2;
    79              1                          2         rdRegsOut.cfigReg3      <= wrRegsIn.cfigReg3;
    80              1                          2         rdRegsOut.cfigReg4      <= wrRegsIn.cfigReg4;
    81              1                          2         rdRegsOut.cfigReg5      <= wrRegsIn.cfigReg5;
    82              1                          2         rdRegsOut.cfigReg6      <= wrRegsIn.cfigReg6;
    83              1                          2         rdRegsOut.cfigReg7      <= wrRegsIn.cfigReg7;
    84              1                          2         rdRegsOut.cfigReg8      <= wrRegsIn.cfigReg8;
    85              1                          2         rdRegsOut.cfigReg9      <= wrRegsIn.cfigReg9;
    86              1                          2         rdRegsOut.cfigReg10     <= wrRegsIn.cfigReg10;
    87              1                          2         rdRegsOut.cfigReg11     <= wrRegsIn.cfigReg11;
    88              1                          2         rdRegsOut.cfigReg12     <= wrRegsIn.cfigReg12;
    89              1                          2         rdRegsOut.cfigReg13     <= wrRegsIn.cfigReg13;
    90              1                          2         rdRegsOut.cfigReg14     <= wrRegsIn.cfigReg14;
    91              1                          2         rdRegsOut.cfigReg15     <= wrRegsIn.cfigReg15;
    92              1                          2         rdRegsOut.cfigReg16     <= wrRegsIn.cfigReg16;
    93              1                          2         rdRegsOut.cfigReg17     <= wrRegsIn.cfigReg17;
    94              1                          2         rdRegsOut.cfigReg28     <= wrRegsIn.cfigReg28;
    95              1                          2         rdRegsOut.cfigReg29     <= wrRegsIn.cfigReg29;
    96              1                          2         rdRegsOut.cfigReg30     <= wrRegsIn.cfigReg30;
    97              1                          2         rdRegsOut.cfigReg31     <= wrRegsIn.cfigReg31;
    98              1                          2         rdRegsOut.cfigReg32     <= wrRegsIn.cfigReg32;
    99              1                          2         rdRegsOut.cfigReg33     <= wrRegsIn.cfigReg33;
    100             1                          2         rdRegsOut.cfigReg34     <= wrRegsIn.cfigReg34;
    101             1                          2         rdRegsOut.cfigReg35     <= wrRegsIn.cfigReg35;
    102             1                          2         rdRegsOut.cfigReg36     <= x"0000" & "00" & wrRegsIn.cfigReg36(13 downto 0);
    103             1                          2         rdRegsOut.cfigReg37     <= wrRegsIn.cfigReg37;
    104             1                          2         rdRegsOut.cfigReg38     <= gridLockDatao;
    105             1                          2         rdRegsOut.cfigReg39     <= x"000000" & "0000000" & fifoStatus(0);--fifoFullh
    106             1                          3         rdRegsOut.cfigReg40     <= x"000000" & "0000000" & fifoStatus(1);--fifoEmptyh
    107             1                          2         rdRegsOut.cfigReg41     <= x"000000" & "0000000" & fifoStatus(2);--fifoFullh
    108             1                          1         rdRegsOut.cfigReg42     <= x"000000" & fifoStatus(23 downto 16);--cpuGridCont
    109             1                          2         rdRegsOut.cfigReg43     <= wrRegsIn.cfigReg43;
    110             1                          2         rdRegsOut.cfigReg44     <= wrRegsIn.cfigReg44;
    111             1                          2         rdRegsOut.cfigReg45     <= wrRegsIn.cfigReg45;
    112             1                          2         rdRegsOut.cfigReg46     <= wrRegsIn.cfigReg46;
    113             1                          2         rdRegsOut.cfigReg47     <= wrRegsIn.cfigReg47;
    114             1                          2         rdRegsOut.cfigReg48     <= wrRegsIn.cfigReg48;
    115             1                          2         rdRegsOut.cfigReg49     <= wrRegsIn.cfigReg49;
    116             1                          2         rdRegsOut.cfigReg50     <= wrRegsIn.cfigReg50;
    117             1                          2         rdRegsOut.cfigReg51     <= wrRegsIn.cfigReg51;
    118             1                          2         rdRegsOut.cfigReg52     <= wrRegsIn.cfigReg52;
    119             1                          2         rdRegsOut.cfigReg53     <= wrRegsIn.cfigReg53;
    120             1                          2         rdRegsOut.cfigReg54     <= wrRegsIn.cfigReg54;
    121             1                          2         rdRegsOut.cfigReg55     <= wrRegsIn.cfigReg55;
    122             1                          2         rdRegsOut.cfigReg56     <= wrRegsIn.cfigReg56;
    123             1                          2         rdRegsOut.cfigReg57     <= wrRegsIn.cfigReg57;
    124             1                          2         rdRegsOut.cfigReg58     <= wrRegsIn.cfigReg58;
    125             1                          2         rdRegsOut.cfigReg59     <= wrRegsIn.cfigReg59;
    126             1                          2         rdRegsOut.cfigReg60     <= x"000000" & "00" & seconds;
    127             1                          2         rdRegsOut.cfigReg61     <= x"000000" & "00" & minutes;
    128             1                          2         rdRegsOut.cfigReg62     <= x"000000" & "000" & hours;
    129             1                          1         rdRegsOut.cfigReg63     <= revision_number;
    130                                              end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         0         0         0     100.0
Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/pixelCord.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           97        22        75      22.6

================================Statement Details================================

Statement Coverage for file ../modules/dut/pixelCord.vhd --

    1                                                
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                
    8                                                entity pixelCord is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   iRed           : in std_logic_vector(7 downto 0);
    12                                                   iGreen         : in std_logic_vector(7 downto 0);
    13                                                   iBlue          : in std_logic_vector(7 downto 0);
    14                                                   iValid         : in std_logic;
    15                                                   iPixelEn       : in std_logic;
    16                                                   iEof           : in std_logic;
    17                                                   iX             : in integer;
    18                                                   iY             : in integer;
    19                                                   oRed           : out std_logic_vector(7 downto 0);
    20                                                   oGreen         : out std_logic_vector(7 downto 0);
    21                                                   oBlue          : out std_logic_vector(7 downto 0);
    22                                                   oValid         : out std_logic);
    23                                               end entity;
    24                                               architecture rtl of pixelCord is
    25                                                   signal iCord           : cord;
    26                                                   signal oRgb            : channel;
    27                                                   signal iRgb            : channel;
    28                                                   signal frameSize       : intersectPoint;
    29                                                   signal initCord        : intersectPoint;
    30                                                   signal newCord         : intersectPoint;
    31                                                   signal grid1Cord       : intersectPoint;
    32                                                   signal grid2Cord       : intersectPoint;
    33                                                   signal grid3Cord       : intersectPoint;
    34                                                   signal grid4Cord       : intersectPoint;
    35                                                   signal rgb             : channel;
    36                                               begin
    37              1                          1         iCord.x         <= iX;
    38              1                          1         iCord.y         <= iY;
    39                                                   
    40              1                          1         iRgb.red         <= iRed;
    41              1                          1         iRgb.green       <= iGreen;
    42              1                          1         iRgb.blue        <= iBlue;
    43              1                          1         iRgb.valid       <= iValid;
    44                                                   
    45              1                          1         oRed             <= oRgb.red;
    46              1                          1         oGreen           <= oRgb.green;
    47              1                          1         oBlue            <= oRgb.blue;
    48              1                          2         oValid           <= oRgb.valid;
    49                                                   
    50                                                   
    51              1                          1         initCord.rht   <= initCordValueRht;
    52              1                          1         initCord.lft   <= initCordValueLft;
    53              1                          1         initCord.top   <= initCordValueTop;
    54              1                          1         initCord.bot   <= initCordValueBot;
    55              1                          1         frameSize.lft  <= frameSizeLft;
    56              1                          1         frameSize.rht  <= frameSizeRht;
    57              1                          1         frameSize.top  <= frameSizeTop;
    58              1                          1         frameSize.bot  <= frameSizeBot;
    59                                               dataOutP: process (clk)begin
    60                                                   if rising_edge(clk) then
    61              1                          1             oRgb.valid  <= iRgb.valid;
    62              1                          1             oRgb.red    <= rgb.red;
    63              1                          1             oRgb.green  <= rgb.green;
    64              1                          1             oRgb.blue   <= rgb.blue;
    65                                                   end if;
    66                                               end process dataOutP;
    67                                               pixelCordP: process (clk)begin
    68                                                   if rising_edge(clk) then
    69                                                       if (iRgb.valid = hi) then
    70                                                           ------------------------------------
    71                                                           if (iPixelEn = hi) then 
    72                                                               ------------------------------------
    73                                                               --Left Coordinates
    74                                                               ------------------------------------
    75                                                               if (iCord.x <= newCord.lft) then
    76                                                                   if ( iCord.x >= frameSize.lft) then 
    77              1                    ***0***                             newCord.lft <= iCord.x - 1;
    78                                                                   end if;   
    79                                                               end if;
    80                                                               ------------------------------------
    81                                                               --Right Coordinates
    82                                                               ------------------------------------
    83                                                               if (iCord.x >= newCord.rht) then
    84                                                                   if ( iCord.x <= frameSize.rht) then 
    85              1                    ***0***                             newCord.rht <= iCord.x + 1;
    86                                                                   end if;   
    87                                                               end if;
    88                                                               ------------------------------------
    89                                                               --Top Coordinates
    90                                                               ------------------------------------
    91                                                               if (iCord.y <= newCord.top) then
    92                                                                   if ( iCord.y >= frameSize.top) then 
    93              1                    ***0***                             newCord.top <= iCord.y - 1;
    94                                                                   end if;   
    95                                                               end if;
    96                                                               ------------------------------------
    97                                                               --Bottom Coordinates
    98                                                               ------------------------------------
    99                                                               if (iCord.y >= newCord.bot) then
    100                                                                  if ( iCord.y <= frameSize.bot) then 
    101             1                    ***0***                             newCord.bot <= iCord.y + 1;
    102                                                                  end if;   
    103                                                              end if;
    104                                                          end if;--iPixelEn
    105                                                          ------------------------------------
    106                                                          -- 4TH FRAME
    107                                                          ------------------------------------
    108                                                          if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    109             1                    ***0***                     rgb.red        <= white;
    110             1                    ***0***                     rgb.green      <= black;
    111             1                    ***0***                     rgb.blue       <= black;
    112                                                          elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    113             1                    ***0***                     rgb.red        <= white;
    114             1                    ***0***                     rgb.green      <= black;
    115             1                    ***0***                     rgb.blue       <= black;
    116                                                          elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    117             1                    ***0***                     rgb.red        <= white;
    118             1                    ***0***                     rgb.green      <= black;
    119             1                    ***0***                     rgb.blue       <= black;
    120                                                          elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    121             1                    ***0***                     rgb.red        <= white;
    122             1                    ***0***                     rgb.green      <= black;
    123             1                    ***0***                     rgb.blue       <= black;
    124                                                          ------------------------------------
    125                                                         -- 3RD FRAME
    126                                                          ------------------------------------
    127                                                          elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    128             1                    ***0***                     rgb.red        <= black;
    129             1                    ***0***                     rgb.green      <= white;
    130             1                    ***0***                     rgb.blue       <= black;
    131                                                          elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    132             1                    ***0***                     rgb.red        <= black;
    133             1                    ***0***                     rgb.green      <= white;
    134             1                    ***0***                     rgb.blue       <= black;
    135                                                          elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    136             1                    ***0***                     rgb.red        <= black;
    137             1                    ***0***                     rgb.green      <= white;
    138             1                    ***0***                     rgb.blue       <= black;
    139                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    140             1                    ***0***                     rgb.red        <= black;
    141             1                    ***0***                     rgb.green      <= white;
    142             1                    ***0***                     rgb.blue       <= black;
    143                                                          ------------------------------------
    144                                                          -- 2ND FRAME
    145                                                          ------------------------------------
    146                                                          elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    147             1                    ***0***                     rgb.red        <= black;
    148             1                    ***0***                     rgb.green      <= black;
    149             1                    ***0***                     rgb.blue       <= white;
    150                                                          elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    151             1                    ***0***                     rgb.red        <= black;
    152             1                    ***0***                     rgb.green      <= black;
    153             1                    ***0***                     rgb.blue       <= white;
    154                                                          elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    155             1                    ***0***                     rgb.red        <= black;
    156             1                    ***0***                     rgb.green      <= black;
    157             1                    ***0***                     rgb.blue       <= white;
    158                                                          elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    159             1                    ***0***                     rgb.red        <= black;
    160             1                    ***0***                     rgb.green      <= black;
    161             1                    ***0***                     rgb.blue       <= white;
    162                                                          ------------------------------------
    163                                                          -- 1ST FRAME
    164                                                          ------------------------------------
    165                                                          elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    166             1                    ***0***                     rgb.red        <= x"80";
    167             1                    ***0***                     rgb.green      <= black;
    168             1                    ***0***                     rgb.blue       <= x"80";
    169                                                          elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    170             1                    ***0***                     rgb.red        <= x"80";
    171             1                    ***0***                     rgb.green      <= black;
    172             1                    ***0***                     rgb.blue       <= x"80";
    173                                                          elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    174             1                    ***0***                     rgb.red        <= x"80";
    175             1                    ***0***                     rgb.green      <= black;
    176             1                    ***0***                     rgb.blue       <= x"80";
    177                                                          elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    178             1                    ***0***                     rgb.red        <= x"80";
    179             1                    ***0***                     rgb.green      <= black;
    180             1                    ***0***                     rgb.blue       <= x"80";
    181                                                          else
    182             1                    ***0***                     rgb.red        <= iRgb.red;
    183             1                    ***0***                     rgb.green      <= iRgb.green;
    184             1                    ***0***                     rgb.blue       <= iRgb.blue;
    185                                                          end if;
    186                                                      end if;--iRgb.valid
    187                                                      if (iEof = hi)then
    188                                                          --RESET COORDINATES TO DEFAULT
    189             1                    ***0***                 newCord.lft       <= initCord.lft;
    190             1                    ***0***                 newCord.rht       <= initCord.rht;
    191             1                    ***0***                 newCord.top       <= initCord.top;
    192             1                    ***0***                 newCord.bot       <= initCord.bot;
    193                                                          -- 1ST FRAME
    194             1                    ***0***                 grid1Cord.lft     <= newCord.lft;
    195             1                    ***0***                 grid1Cord.rht     <= newCord.rht;
    196             1                    ***0***                 grid1Cord.top     <= newCord.top;
    197             1                    ***0***                 grid1Cord.bot     <= newCord.bot;
    198                                                          -- 2ND FRAME
    199             1                    ***0***                 grid2Cord.lft     <= grid1Cord.lft;
    200             1                    ***0***                 grid2Cord.rht     <= grid1Cord.rht;
    201             1                    ***0***                 grid2Cord.top     <= grid1Cord.top;
    202             1                    ***0***                 grid2Cord.bot     <= grid1Cord.bot;
    203                                                          -- 3RD FRAME
    204             1                    ***0***                 grid3Cord.lft     <= grid2Cord.lft;
    205             1                    ***0***                 grid3Cord.rht     <= grid2Cord.rht;
    206             1                    ***0***                 grid3Cord.top     <= grid2Cord.top;
    207             1                    ***0***                 grid3Cord.bot     <= grid2Cord.bot;
    208                                                          -- 4TH FRAME
    209             1                    ***0***                 grid4Cord.lft     <= grid3Cord.lft;
    210             1                    ***0***                 grid4Cord.rht     <= grid3Cord.rht;
    211             1                    ***0***                 grid4Cord.top     <= grid3Cord.top;
    212             1                    ***0***                 grid4Cord.bot     <= grid3Cord.bot;
    213                                                      end if;--iEof
    214                                                  end if;
    215                                              end process pixelCordP;
    216                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        41         4        37       9.7

================================Branch Details================================

Branch Coverage for file ../modules/dut/pixelCord.vhd --

------------------------------------IF Branch------------------------------------
    60                                         1     Count coming in to IF
    60              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    68                                         1     Count coming in to IF
    68              1                          1         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         1     Count coming in to IF
    69              1                    ***0***             if (iRgb.valid = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    71                                   ***0***     Count coming in to IF
    71              1                    ***0***                 if (iPixelEn = hi) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    75                                   ***0***     Count coming in to IF
    75              1                    ***0***                     if (iCord.x <= newCord.lft) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***                         if ( iCord.x >= frameSize.lft) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    83                                   ***0***     Count coming in to IF
    83              1                    ***0***                     if (iCord.x >= newCord.rht) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    84                                   ***0***     Count coming in to IF
    84              1                    ***0***                         if ( iCord.x <= frameSize.rht) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    91                                   ***0***     Count coming in to IF
    91              1                    ***0***                     if (iCord.y <= newCord.top) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    92                                   ***0***     Count coming in to IF
    92              1                    ***0***                         if ( iCord.y >= frameSize.top) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    99                                   ***0***     Count coming in to IF
    99              1                    ***0***                     if (iCord.y >= newCord.bot) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    100                                  ***0***     Count coming in to IF
    100             1                    ***0***                         if ( iCord.y <= frameSize.bot) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    108                                  ***0***     Count coming in to IF
    108             1                    ***0***                 if ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    112             1                    ***0***                 elsif ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))then
    116             1                    ***0***                 elsif ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    120             1                    ***0***                 elsif ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))then
    127             1                    ***0***                 elsif ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    131             1                    ***0***                 elsif ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    135             1                    ***0***                 elsif ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    139             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))then
    146             1                    ***0***                 elsif ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    150             1                    ***0***                 elsif ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))then
    154             1                    ***0***                 elsif ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    158             1                    ***0***                 elsif ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))then
    165             1                    ***0***                 elsif ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    169             1                    ***0***                 elsif ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))then
    173             1                    ***0***                 elsif ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    177             1                    ***0***                 elsif ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))then
    181             1                    ***0***                 else
Branch totals: 0 hits of 17 branches = 0.0%

------------------------------------IF Branch------------------------------------
    187                                        1     Count coming in to IF
    187             1                    ***0***             if (iEof = hi)then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             48         0        48       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/pixelCord.vhd --

----------------Focused Condition View-------------------
Line       108 Item    1  ((iCord.y = grid4Cord.bot) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.bot)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.bot) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.bot) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       112 Item    1  ((iCord.y = grid4Cord.top) and ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid4Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid4Cord.top)_1   ((iCord.x >= grid4Cord.lft) and (iCord.x <= grid4Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid4Cord.lft)_0  (iCord.y = grid4Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid4Cord.lft)_1  (iCord.y = grid4Cord.top) && (iCord.x <= grid4Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid4Cord.rht)_0  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid4Cord.rht)_1  (iCord.y = grid4Cord.top) && (iCord.x >= grid4Cord.lft)

----------------Focused Condition View-------------------
Line       116 Item    1  ((iCord.x = grid4Cord.lft) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.lft)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.lft) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.lft) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       120 Item    1  ((iCord.x = grid4Cord.rht) and ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid4Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid4Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid4Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid4Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid4Cord.rht)_1   ((iCord.y >= grid4Cord.top) and (iCord.y <= grid4Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid4Cord.top)_0  (iCord.x = grid4Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid4Cord.top)_1  (iCord.x = grid4Cord.rht) && (iCord.y <= grid4Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid4Cord.bot)_0  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)
  Row   6:    ***0***  (iCord.y <= grid4Cord.bot)_1  (iCord.x = grid4Cord.rht) && (iCord.y >= grid4Cord.top)

----------------Focused Condition View-------------------
Line       127 Item    1  ((iCord.y = grid3Cord.bot) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.bot)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.bot) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       131 Item    1  ((iCord.y = grid3Cord.top) and ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid3Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid3Cord.top)_1   ((iCord.x >= grid3Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid3Cord.lft)_0  (iCord.y = grid3Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid3Cord.lft)_1  (iCord.y = grid3Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid3Cord.top) && (iCord.x >= grid3Cord.lft)

----------------Focused Condition View-------------------
Line       135 Item    1  ((iCord.x = grid3Cord.lft) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.lft)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.lft) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.lft) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       139 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid3Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid3Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid3Cord.top) and (iCord.y <= grid3Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid3Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid3Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid3Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid3Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)
  Row   6:    ***0***  (iCord.y <= grid3Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid3Cord.top)

----------------Focused Condition View-------------------
Line       146 Item    1  ((iCord.y = grid2Cord.bot) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.bot)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.bot) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.bot) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       150 Item    1  ((iCord.y = grid2Cord.top) and ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid2Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid2Cord.top)_1   ((iCord.x >= grid2Cord.lft) and (iCord.x <= grid3Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid2Cord.lft)_0  (iCord.y = grid2Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid2Cord.lft)_1  (iCord.y = grid2Cord.top) && (iCord.x <= grid3Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid3Cord.rht)_0  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid3Cord.rht)_1  (iCord.y = grid2Cord.top) && (iCord.x >= grid2Cord.lft)

----------------Focused Condition View-------------------
Line       154 Item    1  ((iCord.x = grid2Cord.lft) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid2Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid2Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid2Cord.lft)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid2Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid2Cord.lft) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid2Cord.lft) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       158 Item    1  ((iCord.x = grid3Cord.rht) and ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid3Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid2Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid2Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid3Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid3Cord.rht)_1   ((iCord.y >= grid2Cord.top) and (iCord.y <= grid2Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid2Cord.top)_0  (iCord.x = grid3Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid2Cord.top)_1  (iCord.x = grid3Cord.rht) && (iCord.y <= grid2Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid2Cord.bot)_0  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)
  Row   6:    ***0***  (iCord.y <= grid2Cord.bot)_1  (iCord.x = grid3Cord.rht) && (iCord.y >= grid2Cord.top)

----------------Focused Condition View-------------------
Line       165 Item    1  ((iCord.y = grid1Cord.bot) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.bot)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.bot)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.bot)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.bot) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.bot) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       169 Item    1  ((iCord.y = grid1Cord.top) and ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.y = grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.x >= grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.x <= grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.y = grid1Cord.top)_0   -                             
  Row   2:    ***0***  (iCord.y = grid1Cord.top)_1   ((iCord.x >= grid1Cord.lft) and (iCord.x <= grid1Cord.rht))
  Row   3:    ***0***  (iCord.x >= grid1Cord.lft)_0  (iCord.y = grid1Cord.top)     
  Row   4:    ***0***  (iCord.x >= grid1Cord.lft)_1  (iCord.y = grid1Cord.top) && (iCord.x <= grid1Cord.rht)
  Row   5:    ***0***  (iCord.x <= grid1Cord.rht)_0  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)
  Row   6:    ***0***  (iCord.x <= grid1Cord.rht)_1  (iCord.y = grid1Cord.top) && (iCord.x >= grid1Cord.lft)

----------------Focused Condition View-------------------
Line       173 Item    1  ((iCord.x = grid1Cord.lft) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.lft)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.lft)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.lft)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.lft)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.lft) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.lft) && (iCord.y >= grid1Cord.top)

----------------Focused Condition View-------------------
Line       177 Item    1  ((iCord.x = grid1Cord.rht) and ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot)))
Condition totals: 0 of 3 input terms covered = 0.0%

                  Input Term   Covered  Reason for no coverage   Hint
                 -----------  --------  -----------------------  --------------
   (iCord.x = grid1Cord.rht)         N  No hits                  Hit '_0' and '_1'
  (iCord.y >= grid1Cord.top)         N  No hits                  Hit '_0' and '_1'
  (iCord.y <= grid1Cord.bot)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                    Non-masking condition(s)      
 ---------  ---------  --------------------          -------------------------     
  Row   1:    ***0***  (iCord.x = grid1Cord.rht)_0   -                             
  Row   2:    ***0***  (iCord.x = grid1Cord.rht)_1   ((iCord.y >= grid1Cord.top) and (iCord.y <= grid1Cord.bot))
  Row   3:    ***0***  (iCord.y >= grid1Cord.top)_0  (iCord.x = grid1Cord.rht)     
  Row   4:    ***0***  (iCord.y >= grid1Cord.top)_1  (iCord.x = grid1Cord.rht) && (iCord.y <= grid1Cord.bot)
  Row   5:    ***0***  (iCord.y <= grid1Cord.bot)_0  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)
  Row   6:    ***0***  (iCord.y <= grid1Cord.bot)_1  (iCord.x = grid1Cord.rht) && (iCord.y >= grid1Cord.top)


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/pointOfInterest.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           40        18        22      45.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/pointOfInterest.vhd --

    1                                                --05022019 [05-02-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity pointOfInterest is
    9                                                generic (
    10                                                   i_data_width   : integer := 8;
    11                                                   s_data_width   : integer := 16;
    12                                                   b_data_width   : integer := 32);
    13                                               port (
    14                                                   clk            : in std_logic;
    15                                                   rst_l          : in std_logic;
    16                                                   iCord          : in coord;
    17                                                   endOfFrame     : in std_logic;
    18                                                   pRegion        : in poi;
    19                                                   iRgb           : in channel;
    20                                                   oRgb           : out channel;
    21                                                   gridLockDatao  : out std_logic_vector(b_data_width-1 downto 0);
    22                                                   fifoStatus     : out std_logic_vector(b_data_width-1 downto 0);
    23                                                   oGridLocation  : out std_logic);
    24                                               end entity;
    25                                               architecture arch of pointOfInterest is
    26                                                   constant FIFO_ADDR_WIDTH :integer := 14;
    27                                                   constant FIFO_DATA_WIDTH :integer := 24;
    28                                                   constant FIFO_DEPTH :integer := 2**(FIFO_ADDR_WIDTH);--8192
    29                                                   type fState is (idle,lockReady,fifoFullStatus,fifoEmptyStatus,waitForNewFrame,gridEnCheck);
    30                                                   signal fifoControlState : fState;
    31                                                   signal wrAddrsGlCtr     : integer := 0;
    32                                                   signal GlEnable         : std_logic;
    33                                                   signal rdData           : std_logic_vector(23 downto 0);
    34                                                   signal wrDataIn         : std_logic_vector(23 downto 0);
    35                                                   signal clearData        : std_logic;
    36                                                   signal wrEn             : std_logic;
    37                                                   signal wrLstEn          : std_logic;
    38                                                   signal emptyO           : std_logic; 
    39                                                   signal wrDone           : std_logic; 
    40                                                   signal rdDone           : std_logic; 
    41                                                   signal fullO            : std_logic;
    42                                                   signal clrStatus        : std_logic;
    43                                                   signal wrAddress        : std_logic_vector (FIFO_ADDR_WIDTH-1 downto 0); 
    44                                                   signal wrAddr           : std_logic_vector (FIFO_ADDR_WIDTH-1 downto 0); 
    45                                                   signal gridEn           : std_logic;    
    46                                                   signal fifoIsFull       : std_logic;
    47                                                   signal fifoIsEmpty      : std_logic;
    48                                                   signal gridContMax      : std_logic_vector (15 downto 0);
    49                                                   signal pCont            : cord;    
    50                                               begin
    51              1                          2         oGridLocation  <= GlEnable;
    52              1                          3         fifoStatus     <= "00000000" & gridContMax & "00000" & fifoIsFull & fifoIsEmpty & fifoIsFull;
    53              1                          1         gridLockDatao  <= x"00" & rdData;
    54              1                          1         wrAddress      <= std_logic_vector(to_unsigned(wrAddrsGlCtr,FIFO_ADDR_WIDTH));
    55                                               fifoControlP: process (clk) begin
    56                                               if (rising_edge (clk)) then
    57                                                   if (rst_l = lo) then
    58              1                          4             fifoControlState <= idle;
    59              1                          4             gridEn           <= lo;
    60              1                          4             fifoIsFull       <= lo;
    61              1                          4             fifoIsEmpty      <= lo;
    62              1                          4             clrStatus        <= hi;
    63                                                   else
    64                                                   case (fifoControlState) is
    65                                                   when idle =>
    66                                                   --READY
    67              1                          1             fifoIsFull   <= lo;
    68              1                          1             fifoIsEmpty  <= hi;
    69              1                          1             clrStatus    <= lo;
    70                                                       --Enable
    71                                                       if (pRegion.cpuWgridLock = hi) then
    72              1                    ***0***                 fifoControlState <= waitForNewFrame;
    73                                                       end if;
    74                                                   when waitForNewFrame =>
    75                                                   --WAIT
    76                                                       if (endOfFrame = hi) then
    77              1                    ***0***                 fifoControlState <= gridEnCheck;
    78                                                       end if;
    79                                                   when gridEnCheck =>
    80                                                       if (GlEnable = lo) then
    81              1                    ***0***                 fifoControlState <= lockReady;
    82              1                    ***0***                 gridEn           <= hi;
    83                                                       end if;
    84                                                   when lockReady =>
    85                                                   --CHECK
    86              1                    ***0***             fifoIsFull  <= lo;
    87              1                    ***0***             fifoIsEmpty <= lo;
    88                                                       --WriteDone Pulse
    89                                                       if (wrDone = hi) then
    90              1                    ***0***                 fifoControlState <= fifoFullStatus;
    91              1                    ***0***                 gridEn           <= lo;
    92                                                       end if;
    93                                                   when fifoFullStatus => 
    94                                                   --CHECK
    95              1                    ***0***             fifoIsFull   <= hi;--Full
    96              1                    ***0***             fifoIsEmpty  <= lo;
    97              1                    ***0***             gridContMax <= std_logic_vector(resize(unsigned(wrAddr), gridContMax'length));
    98                                                       --ReadDone Pulse
    99                                                       if (rdDone = hi) then
    100             1                    ***0***                 fifoControlState <= fifoEmptyStatus;               
    101                                                      end if;
    102                                                  when fifoEmptyStatus =>
    103                                                  --RESET
    104             1                    ***0***             fifoIsFull   <= lo;
    105             1                    ***0***             fifoIsEmpty  <= hi;
    106                                                      if (pRegion.cpuAckGoAgain = hi) then
    107             1                    ***0***                 fifoControlState <= idle;
    108             1                    ***0***                 clrStatus        <= hi;
    109                                                      end if;
    110                                                  when others =>
    111             1                    ***0***             fifoControlState <= idle;
    112                                                  end case;
    113                                                  end if;
    114                                              end if;
    115                                              end process fifoControlP;  
    116                                              enablePointerP: process (clk)begin
    117                                                  if rising_edge(clk) then
    118             1                          3             wrDataIn  <= (iRgb.red & iRgb.green & iRgb.blue);
    119             1                          3             wrAddr    <= wrAddress;
    120                                                      if (((pCont.x >= pRegion.pointInterest) and (pCont.x <= pRegion.pointInterest + pInterestWidth)) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= pRegion.pointInterest + pInterestHight))) 
    121                                                      and (iRgb.valid = hi) then
    122             1                    ***0***                 GlEnable     <= hi;
    123                                                      else
    124             1                          3                 GlEnable     <= lo;
    125                                                      end if;
    126             1                          3             wrLstEn       <= not(gridEn);
    127                                                      if (gridEn = hi and GlEnable = hi) then
    128             1                    ***0***                 wrEn         <= hi;
    129             1                    ***0***                 wrAddrsGlCtr <= wrAddrsGlCtr + 1;
    130                                                      elsif (gridEn = hi and GlEnable = lo)then
    131             1                    ***0***                 wrEn          <= wrLstEn;
    132             1                    ***0***                 wrAddrsGlCtr  <= wrAddrsGlCtr;
    133                                                      else
    134             1                          3                 wrEn          <= lo;
    135             1                          3                 wrAddrsGlCtr  <=  0;
    136                                                      end if;
    137                                                  end if;
    138                                              end process enablePointerP;
    139                                              gridLockFifoInt : gridLockFifo
    140                                              generic map(
    141                                                  FIFO_DEPTH      => FIFO_DEPTH,
    142                                                  FIFO_DATA_WIDTH => FIFO_DATA_WIDTH,
    143                                                  FIFO_ADDR_WIDTH => FIFO_ADDR_WIDTH)
    144                                              port map(
    145                                                  clk             => clk,
    146                                                  clrStatus       => clrStatus,
    147                                                  rdEn            => pRegion.fifoReadEnable,
    148                                                  rdAddress       => pRegion.fifoReadAddress(FIFO_ADDR_WIDTH-1 downto 0),
    149                                                  dataO           => rdData,
    150                                                  wrEn            => wrEn,
    151                                                  wrAddress       => wrAddr,
    152                                                  dataIn          => wrDataIn,
    153                                                  wrDone          => wrDone,
    154                                                  rdDone          => rdDone,
    155                                                  emptyO          => emptyO,
    156                                                  fullO           => fullO);
    157                                              --pipCordP: process (clk)begin
    158                                              --    if rising_edge(clk) then
    159                                              --        pCont.x      <= to_integer((unsigned(iCord.x)));
    160                                              --        pCont.y      <= to_integer((unsigned(iCord.y)));
    161                                              --    end if;
    162                                              --end process pipCordP;
    163                                              --pixelCordInt : pixelCord
    164                                              --port map(
    165                                              --    clk      => clk,
    166                                              --    iRgb     => iRgb,
    167                                              --    iPixelEn => GlEnable,
    168                                              --    iEof     => endOfFrame,
    169                                              --    iCord    => pCont,
    170                                              --    oRgb     => oRgb);
    171                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        28         8        20      28.5

================================Branch Details================================

Branch Coverage for file ../modules/dut/pointOfInterest.vhd --

------------------------------------IF Branch------------------------------------
    56                                         5     Count coming in to IF
    56              1                          5     if (rising_edge (clk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         5     Count coming in to IF
    57              1                          4         if (rst_l = lo) then
    63              1                          1         else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    64                                         1     Count coming in to CASE
    65              1                          1         when idle =>
    74              1                    ***0***         when waitForNewFrame =>
    79              1                    ***0***         when gridEnCheck =>
    84              1                    ***0***         when lockReady =>
    93              1                    ***0***         when fifoFullStatus => 
    102             1                    ***0***         when fifoEmptyStatus =>
    110             1                    ***0***         when others =>
Branch totals: 1 hit of 7 branches = 14.2%

------------------------------------IF Branch------------------------------------
    71                                         1     Count coming in to IF
    71              1                    ***0***             if (pRegion.cpuWgridLock = hi) then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***             if (endOfFrame = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    80                                   ***0***     Count coming in to IF
    80              1                    ***0***             if (GlEnable = lo) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    89                                   ***0***     Count coming in to IF
    89              1                    ***0***             if (wrDone = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    99                                   ***0***     Count coming in to IF
    99              1                    ***0***             if (rdDone = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    106                                  ***0***     Count coming in to IF
    106             1                    ***0***             if (pRegion.cpuAckGoAgain = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    117                                        3     Count coming in to IF
    117             1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    121                                        3     Count coming in to IF
    121             1                    ***0***             and (iRgb.valid = hi) then
    123             1                          3             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    127                                        3     Count coming in to IF
    127             1                    ***0***             if (gridEn = hi and GlEnable = hi) then
    130             1                    ***0***             elsif (gridEn = hi and GlEnable = lo)then
    133             1                          3             else
Branch totals: 1 hit of 3 branches = 33.3%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              9         0         9       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/pointOfInterest.vhd --

----------------Focused Condition View-------------------
Line       121 Item    1  ((((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight)))) and (iRgb.valid = hi))
Condition totals: 0 of 5 input terms covered = 0.0%

                                             Input Term   Covered  Reason for no coverage   Hint
                                            -----------  --------  -----------------------  --------------
                     (pCont.x >= pRegion.pointInterest)         N  '_1' not hit             Hit '_1'
  (pCont.x <= (pRegion.pointInterest + pInterestWidth))         N  No hits                  Hit '_0' and '_1'
                     (pCont.y >= pRegion.pointInterest)         N  No hits                  Hit '_0' and '_1'
  (pCont.y <= (pRegion.pointInterest + pInterestHight))         N  No hits                  Hit '_0' and '_1'
                                      (iRgb.valid = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                                               Non-masking condition(s)      
 ---------  ---------  --------------------                                     -------------------------     
  Row   1:          1  (pCont.x >= pRegion.pointInterest)_0                     -                             
  Row   2:    ***0***  (pCont.x >= pRegion.pointInterest)_1                     (iRgb.valid = hi) && ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))) && (pCont.x <= (pRegion.pointInterest + pInterestWidth))
  Row   3:    ***0***  (pCont.x <= (pRegion.pointInterest + pInterestWidth))_0  (pCont.x >= pRegion.pointInterest)
  Row   4:    ***0***  (pCont.x <= (pRegion.pointInterest + pInterestWidth))_1  (iRgb.valid = hi) && ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))) && (pCont.x >= pRegion.pointInterest)
  Row   5:    ***0***  (pCont.y >= pRegion.pointInterest)_0                     ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth)))
  Row   6:    ***0***  (pCont.y >= pRegion.pointInterest)_1                     (iRgb.valid = hi) && ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y <= (pRegion.pointInterest + pInterestHight))
  Row   7:    ***0***  (pCont.y <= (pRegion.pointInterest + pInterestHight))_0  ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y >= pRegion.pointInterest)
  Row   8:    ***0***  (pCont.y <= (pRegion.pointInterest + pInterestHight))_1  (iRgb.valid = hi) && ((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) && (pCont.y >= pRegion.pointInterest)
  Row   9:    ***0***  (iRgb.valid = hi)_0                                      (((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))))
 Row   10:    ***0***  (iRgb.valid = hi)_1                                      (((pCont.x >= pRegion.pointInterest) and (pCont.x <= (pRegion.pointInterest + pInterestWidth))) and ((pCont.y >= pRegion.pointInterest) and (pCont.y <= (pRegion.pointInterest + pInterestHight))))

----------------Focused Condition View-------------------
Line       127 Item    1  ((gridEn = hi) and (GlEnable = hi))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
    (gridEn = hi)         N  '_1' not hit             Hit '_1'
  (GlEnable = hi)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (gridEn = hi)_0       -                             
  Row   2:    ***0***  (gridEn = hi)_1       (GlEnable = hi)               
  Row   3:    ***0***  (GlEnable = hi)_0     (gridEn = hi)                 
  Row   4:    ***0***  (GlEnable = hi)_1     (gridEn = hi)                 

----------------Focused Condition View-------------------
Line       130 Item    1  ((gridEn = hi) and (GlEnable = lo))
Condition totals: 0 of 2 input terms covered = 0.0%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
    (gridEn = hi)         N  '_1' not hit             Hit '_1'
  (GlEnable = lo)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          1  (gridEn = hi)_0       -                             
  Row   2:    ***0***  (gridEn = hi)_1       (GlEnable = lo)               
  Row   3:    ***0***  (GlEnable = lo)_0     (gridEn = hi)                 
  Row   4:    ***0***  (GlEnable = lo)_1     (gridEn = hi)                 


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                         8.3
        States                       6         1         5      16.6
        Transitions                 10         0        10       0.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/pointOfInterest.vhd --

FSM_ID: fifoControlState
    Current State Object : fifoControlState
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  65                idle                   0
  74     waitForNewFrame                   4
  79         gridEnCheck                   5
  84           lockReady                   1
  93      fifoFullStatus                   2
 102     fifoEmptyStatus                   3
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
                    idle                   4
    Uncovered States :
    ------------------
                   State
                   -----
         waitForNewFrame
             gridEnCheck
               lockReady
          fifoFullStatus
         fifoEmptyStatus
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  72                   0          idle -> waitForNewFrame
  77                   1          waitForNewFrame -> gridEnCheck
  58                   2          waitForNewFrame -> idle
  81                   3          gridEnCheck -> lockReady
  58                   4          gridEnCheck -> idle 
  90                   5          lockReady -> fifoFullStatus
  58                   6          lockReady -> idle   
 100                   7          fifoFullStatus -> fifoEmptyStatus
  58                   8          fifoFullStatus -> idle
 107                   9          fifoEmptyStatus -> idle


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       6         1         5      16.6
        Transitions                 10         0        10       0.0

=================================================================================
=== File: ../modules/dut/raw2rgb.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           57        30        27      52.6

================================Statement Details================================

Statement Coverage for file ../modules/dut/raw2rgb.vhd --

    1                                                library ieee;
    2                                                use ieee.std_logic_1164.all;
    3                                                use ieee.numeric_std.all;
    4                                                use work.constantspackage.all;
    5                                                use work.vpfRecords.all;
    6                                                use work.portspackage.all;
    7                                                entity RawToRgb is
    8                                                port (
    9                                                    clk            : in std_logic;
    10                                                   rst_l          : in std_logic;
    11                                                   iTpData        : in rTp;
    12                                                   oRgbSet        : out rRgb);
    13                                               end entity;
    14                                               architecture arch of RawToRgb is
    15                                                   signal rgb           : rawRgb;
    16                                                   signal tpd1          : uTp;
    17                                                   signal tpd2          : uTp;
    18                                                   signal r1Valid       : std_logic :='0';
    19                                                   signal r2Valid       : std_logic :='0';
    20                                                   signal d1TpData      : rTp;
    21                                                   signal d2TpData      : rTp;
    22                                               begin
    23                                               validSyncP: process(clk) begin
    24                                                   if rising_edge(clk) then
    25              1                          6             r1Valid       <= iTpData.valid;
    26              1                          6             r2Valid       <= r1Valid;
    27              1                          6             oRgbSet.valid <= r2Valid;
    28              1                          6             d1TpData      <= iTpData;
    29              1                          6             d2TpData      <= d1TpData;
    30              1                          6             oRgbSet.pEof  <= d2TpData.pEof;
    31              1                          6             oRgbSet.pSof  <= d2TpData.pSof;
    32              1                          6             oRgbSet.cord  <= d2TpData.cord;
    33                                                   end if;
    34                                               end process validSyncP;
    35                                               syncDataP: process (clk) begin
    36                                                   if rising_edge(clk) then
    37                                                       if rst_l = '0' then
    38              1                          2                 tpd1.tp3  <=(others => '0');
    39              1                          2                 tpd2.tp3  <=(others => '0');
    40              1                          2                 tpd1.tp2  <=(others => '0');
    41              1                          2                 tpd2.tp2  <=(others => '0');
    42              1                          2                 tpd1.tp1  <=(others => '0');
    43              1                          2                 tpd2.tp1  <=(others => '0');
    44                                                           else
    45              1                          1                 tpd1.tp1  <=unsigned(iTpData.taps.tp1);
    46              1                          1                 tpd1.tp2  <=unsigned(iTpData.taps.tp2);
    47              1                          1                 tpd1.tp3  <=unsigned(iTpData.taps.tp3);
    48              1                          1                 tpd2.tp1  <=tpd1.tp1;
    49              1                          1                 tpd2.tp2  <=tpd1.tp2;
    50              1                          1                 tpd2.tp3  <=tpd1.tp3;
    51                                                           end if;
    52                                                       end if;
    53                                               end process syncDataP;
    54                                               rawToRgbP: process (clk)
    55                                                   variable loc_addr : std_logic_vector(1 downto 0);
    56                                                   begin
    57                                                       if rising_edge(clk) then
    58                                                       if rst_l = '0' then
    59              1                          3                 rgb.red   <=(others => '0');
    60              1                          3                 rgb.green <=(others => '0');
    61              1                          3                 rgb.blue  <=(others => '0'); 
    62                                                       else
    63              1                          1             loc_addr := iTpData.cord.y(0) & iTpData.cord.x(0);
    64                                                       case loc_addr IS
    65                                                           when b"11" => 
    66                                                               if (iTpData.cord.y(11 downto 0) = x"001") then
    67              1                    ***0***                         rgb.red   <= tpd1.tp2;
    68              1                    ***0***                         rgb.green <= '0' & (tpd1.tp3 + unsigned(iTpData.taps.tp2));
    69              1                    ***0***                         rgb.blue  <= unsigned(iTpData.taps.tp3);
    70                                                               else          
    71              1                    ***0***                         rgb.red   <= tpd1.tp2;
    72              1                    ***0***                         rgb.green <= '0' & (unsigned(iTpData.taps.tp2) + tpd1.tp1);
    73              1                    ***0***                         rgb.blue  <= unsigned(iTpData.taps.tp1);
    74                                                               end if;
    75                                                           when b"10" => 
    76                                                               if (iTpData.cord.y(11 downto 0) = x"001") then
    77                                                                   if (iTpData.cord.x(11 downto 0) = x"000") then
    78              1                    ***0***                             rgb.red    <= tpd2.tp3;
    79              1                    ***0***                             rgb.green  <= tpd2.tp2 & '0';
    80              1                    ***0***                             rgb.blue   <= tpd1.tp2;
    81                                                                   else
    82              1                    ***0***                             rgb.red    <= unsigned(iTpData.taps.tp2);
    83              1                    ***0***                             rgb.green  <= '0' & (tpd1.tp2 + unsigned(iTpData.taps.tp3));
    84              1                    ***0***                             rgb.blue   <= tpd1.tp3;    
    85                                                                   end if;
    86                                                               else
    87                                                                   if (iTpData.cord.x(11 downto 0) = x"000") then
    88              1                    ***0***                             rgb.red    <= tpd2.tp1;
    89              1                    ***0***                             rgb.green  <= tpd1.tp1 & '0';
    90              1                    ***0***                             rgb.blue   <= tpd1.tp2;
    91                                                                   else
    92              1                    ***0***                             rgb.red    <= unsigned(iTpData.taps.tp2);
    93              1                    ***0***                             rgb.green  <= '0' & (tpd1.tp2 + unsigned(iTpData.taps.tp1));
    94              1                    ***0***                             rgb.blue   <= tpd1.tp1;    
    95                                                                   end if;
    96                                                               end if;
    97                                                           when b"01" => 
    98              1                    ***0***                     rgb.red      <= tpd1.tp1;
    99              1                    ***0***                     rgb.green    <= '0' & (unsigned(iTpData.taps.tp1) + tpd1.tp2);
    100             1                    ***0***                     rgb.blue     <= unsigned(iTpData.taps.tp2);    
    101                                                          when b"00" => 
    102                                                              if (iTpData.cord.x(11 downto 0) = x"000") then
    103             1                          1                         rgb.red     <= tpd2.tp2;
    104             1                          1                         rgb.green   <= tpd2.tp1 & '0';
    105             1                          1                         rgb.blue    <= tpd1.tp1;
    106                                                              else
    107             1                    ***0***                         rgb.red     <= unsigned(iTpData.taps.tp1);
    108             1                    ***0***                         rgb.green   <= '0' & (tpd1.tp1 + unsigned(iTpData.taps.tp2));
    109             1                    ***0***                         rgb.blue    <= tpd1.tp2;    
    110                                                              end if;
    111                                                          when others => 
    112             1                    ***0***                     rgb.red     <= rgb.red;
    113             1                    ***0***                     rgb.green   <= rgb.green;
    114             1                    ***0***                     rgb.blue    <= rgb.blue;
    115                                                      end case;
    116                                                      end if;
    117                                                      end if; 
    118                                              end process rawToRgbP;
    119             1                          2         oRgbSet.red    <= std_logic_vector(rgb.red(11 downto 4));
    120             1                          2         oRgbSet.green  <= std_logic_vector(rgb.green(12 downto 5));
    121             1                          2         oRgbSet.blue   <= std_logic_vector(rgb.blue(11 downto 4));
    122                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        22         9        13      40.9

================================Branch Details================================

Branch Coverage for file ../modules/dut/raw2rgb.vhd --

------------------------------------IF Branch------------------------------------
    24                                         6     Count coming in to IF
    24              1                          6         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    36                                         3     Count coming in to IF
    36              1                          3         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    37                                         3     Count coming in to IF
    37              1                          2             if rst_l = '0' then
    44              1                          1                 else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    57                                         4     Count coming in to IF
    57              1                          4             if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    58                                         4     Count coming in to IF
    58              1                          3             if rst_l = '0' then
    62              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    64                                         1     Count coming in to CASE
    65              1                    ***0***                 when b"11" => 
    75              1                    ***0***                 when b"10" => 
    97              1                    ***0***                 when b"01" => 
    101             1                          1                 when b"00" => 
    111             1                    ***0***                 when others => 
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    66                                   ***0***     Count coming in to IF
    66              1                    ***0***                     if (iTpData.cord.y(11 downto 0) = x"001") then
    70              1                    ***0***                     else          
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    76                                   ***0***     Count coming in to IF
    76              1                    ***0***                     if (iTpData.cord.y(11 downto 0) = x"001") then
    86              1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    77                                   ***0***     Count coming in to IF
    77              1                    ***0***                         if (iTpData.cord.x(11 downto 0) = x"000") then
    81              1                    ***0***                         else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    87                                   ***0***     Count coming in to IF
    87              1                    ***0***                         if (iTpData.cord.x(11 downto 0) = x"000") then
    91              1                    ***0***                         else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    102                                        1     Count coming in to IF
    102             1                          1                     if (iTpData.cord.x(11 downto 0) = x"000") then
    106             1                    ***0***                     else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/sharpFilter.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           18        14         4      77.7

================================Statement Details================================

Statement Coverage for file ../modules/dut/sharpFilter.vhd --

    1                                                --02092019 [02-09-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity sharpFilter is
    9                                                generic (
    10                                                   i_data_width  : integer := 8;
    11                                                   img_width     : integer := 256;
    12                                                   adwrWidth     : integer := 16;
    13                                                   addrWidth     : integer := 12);
    14                                               port (
    15                                                   clk           : in std_logic;
    16                                                   rst_l         : in std_logic;
    17                                                   iRgb          : in channel;
    18                                                   kls           : in coefficient;
    19                                                   endOfFrame    : in std_logic;   
    20                                                   oRgb          : out channel);
    21                                               end entity;
    22                                               architecture arch of sharpFilter is
    23                                               ---------------------------------------------------------------------------------
    24                                                   signal vTapRGB0x        : std_logic_vector(23 downto 0) := (others => '0');
    25                                                   signal vTapRGB1x        : std_logic_vector(23 downto 0) := (others => '0');
    26                                                   signal vTapRGB2x        : std_logic_vector(23 downto 0) := (others => '0');
    27                                                   signal v1TapRGB0x       : std_logic_vector(23 downto 0) := (others => '0');
    28                                                   signal v1TapRGB1x       : std_logic_vector(23 downto 0) := (others => '0');
    29                                                   signal v1TapRGB2x       : std_logic_vector(23 downto 0) := (others => '0');
    30                                                   signal enable           : std_logic;
    31                                                   signal d1en             : std_logic;
    32                                                   signal d2en             : std_logic;
    33                                                   signal d3en             : std_logic;
    34                                                   signal d4en             : std_logic;
    35                                                   signal d5en             : std_logic;
    36                                                   signal rCountAddress    : integer;
    37                                                   signal rAddress         : std_logic_vector(15 downto 0);
    38                                                   signal rgb1x            : channel;
    39                                                   signal rgb2x            : channel;
    40                                                   signal d2RGB            : std_logic_vector(23 downto 0) := (others => '0');
    41                                               ---------------------------------------------------------------------------------
    42                                               begin
    43                                               tapValidAdressP: process(clk)begin
    44                                                   if rising_edge(clk) then
    45                                                       if (iRgb.valid = '1') then
    46              1                    ***0***                 rCountAddress  <= rCountAddress + 1;
    47                                                       else
    48              1                          2                 rCountAddress  <= 0;
    49                                                       end if;
    50                                                   end if;
    51                                               end process tapValidAdressP;
    52              1                          2     rAddress  <= std_logic_vector(to_unsigned(rCountAddress, 16));
    53                                               RGBInst: buffer_controller
    54                                               generic map(
    55                                                   img_width       => img_width,
    56                                                   adwrWidth       => adwrWidth,
    57                                                   dataWidth       => 24,
    58                                                   addrWidth       => addrWidth)
    59                                               port map(
    60                                                   aclk            => clk,
    61                                                   i_enable        => iRgb.valid,
    62                                                   i_data          => d2RGB,
    63                                                   i_wadd          => rAddress,
    64                                                   i_radd          => rAddress,
    65                                                   en_datao        => enable,
    66                                                   taps0x          => v1TapRGB0x,
    67                                                   taps1x          => v1TapRGB1x,
    68                                                   taps2x          => v1TapRGB2x);
    69                                               MACrInst: sharpMac
    70                                               port map(
    71                                                   clk             => clk,
    72                                                   rst_l           => rst_l,
    73                                                   vTap0x          => vTapRGB0x(23 downto 16),
    74                                                   vTap1x          => vTapRGB1x(23 downto 16),
    75                                                   vTap2x          => vTapRGB2x(23 downto 16),
    76                                                   endOfFrame      => endOfFrame,
    77                                                   kls             => kls,
    78                                                   DataO           => oRgb.red);
    79                                               MACgInst: sharpMac
    80                                               port map(
    81                                                   clk             => clk,
    82                                                   rst_l           => rst_l,
    83                                                   vTap0x          => vTapRGB0x(15 downto 8),
    84                                                   vTap1x          => vTapRGB1x(15 downto 8),
    85                                                   vTap2x          => vTapRGB2x(15 downto 8),
    86                                                   endOfFrame      => endOfFrame,
    87                                                   kls             => kls,    
    88                                                   DataO           => oRgb.green);
    89                                               MACbInst: sharpMac
    90                                               port map(
    91                                                   clk             => clk,
    92                                                   rst_l           => rst_l,
    93                                                   vTap0x          => vTapRGB0x(i_data_width-1 downto 0),
    94                                                   vTap1x          => vTapRGB1x(i_data_width-1 downto 0),
    95                                                   vTap2x          => vTapRGB2x(i_data_width-1 downto 0),
    96                                                   endOfFrame      => endOfFrame,
    97                                                   kls             => kls,   
    98                                                   DataO           => oRgb.blue);
    99                                               tapSignedP : process (clk) begin
    100                                                  if rising_edge(clk) then
    101             1                          6             rgb1x      <= iRgb;  
    102             1                          6             rgb2x      <= rgb1x;
    103             1                          6             d2RGB      <= rgb2x.red & rgb2x.green & rgb2x.blue;
    104             1                          6             d1en       <= enable;
    105             1                          6             d2en       <= d1en;
    106             1                          6             d3en       <= d2en;
    107             1                          6             d4en       <= d3en;
    108             1                          6             d5en       <= d4en;
    109             1                          6             oRgb.valid <= d5en;
    110                                                      if(enable = '1') then
    111             1                    ***0***                 vTapRGB0x <=v1TapRGB0x;
    112             1                    ***0***                 vTapRGB1x <=v1TapRGB1x;
    113             1                    ***0***                 vTapRGB2x <=v1TapRGB2x;
    114                                                      else
    115             1                          6                 vTapRGB0x <=(others => '0');
    116             1                          6                 vTapRGB1x <=(others => '0');
    117             1                          6                 vTapRGB2x <=(others => '0');
    118                                                      end if;
    119                                                end if;
    120                                              end process tapSignedP;
    121                                              end arch;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         4         2      66.6

================================Branch Details================================

Branch Coverage for file ../modules/dut/sharpFilter.vhd --

------------------------------------IF Branch------------------------------------
    44                                         2     Count coming in to IF
    44              1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    45                                         2     Count coming in to IF
    45              1                    ***0***             if (iRgb.valid = '1') then
    47              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    100                                        6     Count coming in to IF
    100             1                          6         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    110                                        6     Count coming in to IF
    110             1                    ***0***             if(enable = '1') then
    114             1                          6             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/sharpMac.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           46        35        11      76.0

================================Statement Details================================

Statement Coverage for file ../modules/dut/sharpMac.vhd --

    1                                                --01162019 [01-16-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity sharpMac is
    9                                                port (
    10                                                   clk            : in std_logic;
    11                                                   rst_l          : in std_logic;
    12                                                   vTap0x         : in std_logic_vector(7 downto 0);
    13                                                   vTap1x         : in std_logic_vector(7 downto 0);
    14                                                   vTap2x         : in std_logic_vector(7 downto 0);
    15                                                   kls            : in coefficient;  
    16                                                   endOfFrame     : in std_logic;     
    17                                                   DataO          : out std_logic_vector(7 downto 0));
    18                                               end entity;
    19                                               architecture arch of sharpMac is
    20                                               ---------------------------------------------------------------------------------
    21                                                   constant i_data_width : integer := 8;
    22                                                   type detap is record
    23                                                       vTap0x    : signed(i_data_width downto 0);
    24                                                       vTap1x    : signed(i_data_width downto 0);
    25                                                       vTap2x    : signed(i_data_width downto 0);
    26                                                   end record;
    27                                                   type s_pixel is record
    28                                                       m1        : signed (16 downto 0);
    29                                                       m2        : signed (16 downto 0);
    30                                                       m3        : signed (16 downto 0);
    31                                                       mac       : signed (i_data_width+3 downto 0);
    32                                                   end record;
    33                                               ---------------------------------------------------------------------------------
    34                                                   signal mac1X      : s_pixel;
    35                                                   signal mac2X      : s_pixel;
    36                                                   signal mac3X      : s_pixel;
    37                                                   signal tpd1       : detap;
    38                                                   signal tpd2       : detap;
    39                                                   signal tpd3       : detap;
    40                                                   signal o1Data     : signed(i_data_width+3 downto 0);
    41                                                   signal o2Data     : signed(i_data_width+3 downto 0);
    42                                                   signal Kernel_1   : signed(7 downto 0) :=x"00";-- [ 0]
    43                                                   signal Kernel_2   : signed(7 downto 0) :=x"FF";-- [-1]
    44                                                   signal Kernel_3   : signed(7 downto 0) :=x"00";-- [ 0]
    45                                                   signal Kernel_4   : signed(7 downto 0) :=x"FF";-- [-1]
    46                                                   signal Kernel_5   : signed(7 downto 0) :=x"05";-- [ 5]
    47                                                   signal Kernel_6   : signed(7 downto 0) :=x"FF";-- [-1]
    48                                                   signal Kernel_7   : signed(7 downto 0) :=x"00";-- [ 0]
    49                                                   signal Kernel_8   : signed(7 downto 0) :=x"FF";-- [-1]
    50                                                   signal Kernel_9   : signed(7 downto 0) :=x"00";-- [ 0]
    51                                               ---------------------------------------------------------------------------------
    52                                               begin
    53                                               KUPDATE : process (clk) begin
    54                                                 if rising_edge(clk) then
    55                                                 if (kls.config = 2) then
    56              1                    ***0***           Kernel_1    <= signed(kls.k1(i_data_width-1 downto 0));
    57              1                    ***0***           Kernel_2    <= signed(kls.k2(i_data_width-1 downto 0));
    58              1                    ***0***           Kernel_3    <= signed(kls.k3(i_data_width-1 downto 0));
    59              1                    ***0***           Kernel_4    <= signed(kls.k4(i_data_width-1 downto 0));
    60              1                    ***0***           Kernel_5    <= signed(kls.k5(i_data_width-1 downto 0));
    61              1                    ***0***           Kernel_6    <= signed(kls.k6(i_data_width-1 downto 0));
    62              1                    ***0***           Kernel_7    <= signed(kls.k7(i_data_width-1 downto 0));
    63              1                    ***0***           Kernel_8    <= signed(kls.k8(i_data_width-1 downto 0));
    64              1                    ***0***           Kernel_9    <= signed(kls.k9(i_data_width-1 downto 0));
    65                                                 end if;
    66                                                 end if;
    67                                               end process KUPDATE;
    68                                                 TAP_DELAY : process (clk) begin
    69                                                   if rising_edge(clk) then
    70                                                       if rst_l = '0' then
    71              1                          6                 tpd1.vTap0x    <= (others => '0');
    72              1                          6                 tpd1.vTap1x    <= (others => '0');
    73              1                          6                 tpd1.vTap2x    <= (others => '0');
    74              1                          6                 tpd2.vTap0x    <= (others => '0');
    75              1                          6                 tpd2.vTap1x    <= (others => '0');
    76              1                          6                 tpd2.vTap2x    <= (others => '0'); 
    77              1                          6                 tpd3.vTap0x    <= (others => '0');
    78              1                          6                 tpd3.vTap1x    <= (others => '0');
    79              1                          6                 tpd3.vTap2x    <= (others => '0');
    80                                                       else
    81              1                          3                 tpd1.vTap0x    <= signed('0' & vTap0x);
    82              1                          3                 tpd1.vTap1x    <= signed('0' & vTap1x);
    83              1                          3                 tpd1.vTap2x    <= signed('0' & vTap2x);
    84              1                          3                 tpd2.vTap0x    <= tpd1.vTap0x;
    85              1                          3                 tpd2.vTap1x    <= tpd1.vTap1x;
    86              1                          3                 tpd2.vTap2x    <= tpd1.vTap2x;
    87              1                          3                 tpd3.vTap0x    <= tpd2.vTap0x;
    88              1                          3                 tpd3.vTap1x    <= tpd2.vTap1x;
    89              1                          3                 tpd3.vTap2x    <= tpd2.vTap2x;
    90                                                       end if;
    91                                                   end if;
    92                                                 end process TAP_DELAY;
    93                                                 --1st Row Pixels
    94                                                 MAC_X_A : process (clk) begin
    95                                                   if rising_edge(clk) then
    96              1                          9             mac1X.m1    <= (tpd1.vTap0x * Kernel_9);--1st Row 1st pixel
    97              1                          9             mac1X.m2    <= (tpd2.vTap0x * Kernel_8);--1st Row 2nd pixel
    98              1                          9             mac1X.m3    <= (tpd3.vTap0x * Kernel_7);--1st Row 3rd pixel
    99              1                          9             mac1X.mac   <= mac1X.m1(i_data_width+3 downto 0) + mac1X.m2(i_data_width+3 downto 0) + mac1X.m3(i_data_width+3 downto 0);
    100                                                  end if;
    101                                                end process MAC_X_A;
    102                                                MAC_X_B : process (clk) begin
    103                                                  if rising_edge(clk) then
    104             1                          9             mac2X.m1    <= (tpd1.vTap1x * Kernel_6);--2nd Row 1st pixel
    105             1                          9             mac2X.m2    <= (tpd2.vTap1x * Kernel_5);--2nd Row 2nd pixel
    106             1                          9             mac2X.m3    <= (tpd3.vTap1x * Kernel_4);--2nd Row 3rd pixel
    107             1                          9             mac2X.mac   <= mac2X.m1(i_data_width+3 downto 0) + mac2X.m2(i_data_width+3 downto 0) + mac2X.m3(i_data_width+3 downto 0);
    108                                                  end if;
    109                                                end process MAC_X_B;
    110                                                MAC_X_C : process (clk) begin
    111                                                  if rising_edge(clk) then
    112             1                          9             mac3X.m1    <= (tpd1.vTap2x * Kernel_3);--3rd Row 1st pixel
    113             1                          9             mac3X.m2    <= (tpd2.vTap2x * Kernel_2);--3rd Row 2nd pixel
    114             1                          9             mac3X.m3    <= (tpd3.vTap2x * Kernel_1);--3rd Row 3rd pixel
    115             1                          9             mac3X.mac   <= mac3X.m1(i_data_width+3 downto 0) + mac3X.m2(i_data_width+3 downto 0) + mac3X.m3(i_data_width+3 downto 0);
    116                                                  end if;
    117                                                end process MAC_X_C;
    118                                                PA_X : process (clk) begin
    119                                                  if rising_edge(clk) then
    120             1                          9             o1Data <= mac1X.mac + mac2X.mac + mac3X.mac;
    121                                                  end if;
    122                                                end process PA_X;
    123             1                          9       U_DATA : process(o1Data)begin
    124                                                  if(o1Data(11) = '1')then
    125             1                    ***0***             o2Data <= (others => '0');
    126                                                  else
    127             1                          9             o2Data <= o1Data;
    128                                                  end if;
    129                                                end process U_DATA;
    130             1                          9       O_DATA : process(o2Data)begin
    131                                                  if(o2Data(8) = '1')then
    132             1                    ***0***             DataO <= (others => '1');
    133                                                  else
    134             1                          9             DataO <= std_logic_vector(o2Data(7 downto 0));
    135                                                  end if;
    136                                                end process O_DATA;
    137                                              end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        14        11         3      78.5

================================Branch Details================================

Branch Coverage for file ../modules/dut/sharpMac.vhd --

------------------------------------IF Branch------------------------------------
    54                                         6     Count coming in to IF
    54              1                          6       if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    55                                         6     Count coming in to IF
    55              1                    ***0***       if (kls.config = 2) then
                                               6     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    69                                         9     Count coming in to IF
    69              1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    70                                         9     Count coming in to IF
    70              1                          6             if rst_l = '0' then
    80              1                          3             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    95                                         9     Count coming in to IF
    95              1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    103                                        9     Count coming in to IF
    103             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    111                                        9     Count coming in to IF
    111             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    119                                        9     Count coming in to IF
    119             1                          9         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    124                                        9     Count coming in to IF
    124             1                    ***0***         if(o1Data(11) = '1')then
    126             1                          9         else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    131                                        9     Count coming in to IF
    131             1                    ***0***         if(o2Data(8) = '1')then
    133             1                          9         else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/tap_buffer.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            7         6         1      85.7

================================Statement Details================================

Statement Coverage for file ../modules/dut/tap_buffer.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                entity tap_buffer is
    8                                                generic (
    9                                                    img_width    : integer := 4095;
    10                                                   dataWidth    : integer := 12; 
    11                                                   addrWidth    : integer := 12);
    12                                               port (
    13                                                   write_clk    : in std_logic;
    14                                                   write_enb    : in std_logic;
    15                                                   w_address    : in std_logic_vector(addrWidth - 1 downto 0);
    16                                                   idata        : in std_logic_vector(dataWidth - 1 downto 0);
    17                                                   read_clk     : in std_logic;
    18                                                   r_address    : in std_logic_vector(addrWidth - 1 downto 0);
    19                                                   odata        : out std_logic_vector(dataWidth - 1 downto 0));
    20                                               end entity;
    21                                               architecture arch of tap_buffer is
    22                                                   type ram_type is array (0 to img_width) of std_logic_vector (dataWidth - 1 downto 0);
    23                                                   signal rowbuffer    : ram_type := (others => (others => '0'));
    24                                                   signal oregister    : std_logic_vector(dataWidth - 1 downto 0);
    25                                                   signal write1s_enb  : std_logic;
    26                                                   signal write2s_enb  : std_logic;
    27                                                   signal write3s_enb  : std_logic;  
    28                                                   signal write_or_enb : std_logic;
    29                                               begin
    30                                               process (write_clk) begin
    31                                                   if rising_edge(write_clk) then
    32              1                      27144             write1s_enb <= write_enb;
    33              1                      27144             write2s_enb <= write1s_enb;
    34              1                      27144             write3s_enb <= write2s_enb;
    35                                                   end if;
    36                                               end process;
    37              1                         48     write_or_enb <= write_enb or write3s_enb;
    38                                               process (write_clk) begin
    39                                               if rising_edge(write_clk) then
    40                                                   if (write_or_enb ='1') then
    41              1                    ***0***             rowbuffer(to_integer(unsigned(w_address))) <= idata;
    42                                                   end if;
    43                                               end if;
    44                                               end process;
    45                                               process (read_clk) begin
    46                                               if rising_edge(read_clk) then
    47              1                      27144         oregister <= rowbuffer(to_integer(unsigned(r_address)));
    48                                               end if;
    49                                               end process;
    50                                               process (read_clk) begin
    51                                               if rising_edge(read_clk) then
    52              1                         48         odata <= oregister;
    53                                               end if;
    54                                               end process;
    55                                               end architecture;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         5         1      83.3

================================Branch Details================================

Branch Coverage for file ../modules/dut/tap_buffer.vhd --

------------------------------------IF Branch------------------------------------
    31                                     27144     Count coming in to IF
    31              1                      27144         if rising_edge(write_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    39                                        76     Count coming in to IF
    39              1                         76     if rising_edge(write_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    40                                        76     Count coming in to IF
    40              1                    ***0***         if (write_or_enb ='1') then
                                              76     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    46                                     27144     Count coming in to IF
    46              1                      27144     if rising_edge(read_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    51                                        48     Count coming in to IF
    51              1                         48     if rising_edge(read_clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         0         2       0.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/tap_buffer.vhd --

----------------Focused Expression View-----------------
Line       37 Item    1  (write_enb or write3s_enb)
Expression totals: 0 of 2 input terms covered = 0.0%

   Input Term   Covered  Reason for no coverage   Hint
  -----------  --------  -----------------------  --------------
    write_enb         N  '_1' not hit             Hit '_1'
  write3s_enb         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:         24  write_enb_0           not write3s_enb               
  Row   2:    ***0***  write_enb_1           not write3s_enb               
  Row   3:         24  write3s_enb_0         not write_enb                 
  Row   4:    ***0***  write3s_enb_1         not write_enb                 


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/template.v
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           24         8        16      33.3

================================Statement Details================================

Statement Coverage for file ../modules/dut/template.v --

    1                                                module template(input wire clk,
    2                                                		   input wire en_i,
    3                                                		   input wire ina,
    4                                                		   input wire inb,
    5                                                		   output reg en_o,
    6                                                		   output reg out_c);
    7                                                	integer counter, state;
    8                                                	reg[1:0] temp_a, temp_b;
    9                                                	reg[2:0] temp_out;
    10                                               	//Init
    11                                               	initial begin
    12              1                          1     		counter = 0;
    13              1                          1     		temp_a = 2'b00;
    14              1                          1     		temp_b = 2'b00;
    15              1                          1     		temp_out = 3'b000;
    16              1                          1     		out_c = 1;
    17              1                          1     		en_o <= 0;
    18              1                          1     		state = 0;
    19                                               	end
    20              1                       1131     	always@(posedge clk)
    21                                               	begin
    22                                               		//State 0: Wait for en_i
    23                                               		if(en_i==1'b1)
    24                                               		begin
    25              1                    ***0***     			state = 1;
    26                                               		end
    27                                               		case(state)
    28                                               			//State 1: Start reading inputs
    29                                               			1: begin
    30              1                    ***0***     				temp_a = temp_a << 1;
    31              1                    ***0***     				temp_a = temp_a | ina;
    32              1                    ***0***     				temp_b = temp_b << 1;
    33              1                    ***0***     				temp_b = temp_b | inb;
    34              1                    ***0***     				counter = counter + 1;
    35                                               				//After 2 bits, do the operation an move to the next state
    36                                               				if(counter==2) begin
    37              1                    ***0***     					temp_out = temp_a + temp_b;
    38              1                    ***0***     					state = 2;
    39                                               				end
    40                                               			end
    41                                               			//State 2: Enable en_o and sends result to the output
    42                                               			2: begin
    43              1                    ***0***     				out_c <= temp_out[2];
    44              1                    ***0***     				temp_out = temp_out << 1;
    45              1                    ***0***     				counter = counter + 1;
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
    48                                               				if(counter==6) begin
    49              1                    ***0***     					counter = 0;
    50              1                    ***0***     					out_c <= 1'b1;
    51              1                    ***0***     					state = 0;
    52                                               				end
    53                                               			end
    54                                               		endcase
    55                                               	end
    56                                               endmodule

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13         2        11      15.3

================================Branch Details================================

Branch Coverage for file ../modules/dut/template.v --

------------------------------------IF Branch------------------------------------
    23                                      1131     Count coming in to IF
    23              1                    ***0***     		if(en_i==1'b1)
                                            1131     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    27                                      1131     Count coming in to CASE
    29              1                    ***0***     			1: begin
    42              1                    ***0***     			2: begin
                                            1131     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    36                                   ***0***     Count coming in to IF
    36              1                    ***0***     				if(counter==2) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    46                                   ***0***     Count coming in to IF
    46              1                    ***0***     				if(counter==3) en_o <= 1'b1;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    47                                   ***0***     Count coming in to IF
    47              1                    ***0***     				if(counter==4) en_o <= 1'b0;
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    48                                   ***0***     Count coming in to IF
    48              1                    ***0***     				if(counter==6) begin
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                         0.0
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/template.v --

FSM_ID: state
    Current State Object : state
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  29                 st0                   1
  42                 st1                   2
  25                 st2                   0
    Uncovered States :
    ------------------
                   State
                   -----
                     st0
                     st1
                     st2
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  38                   0          st0 -> st1          
  51                   1          st1 -> st2          
  25                   2          st1 -> st0          
  25                   3          st2 -> st0          


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       3         0         3       0.0
        Transitions                  4         0         4       0.0

=================================================================================
=== File: ../modules/dut/vfpConfig.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                          491        94       397      19.1

================================Statement Details================================

Statement Coverage for file ../modules/dut/vfpConfig.vhd --

    1                                                --02072019 [02-07-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity videoProcess_v1_0_Config is
    9                                                    generic (
    10                                                       revision_number          : std_logic_vector(31 downto 0) := x"00000000";
    11                                                       C_S_AXI_DATA_WIDTH       : integer    := 32;
    12                                                       C_S_AXI_ADDR_WIDTH       : integer    := 8);
    13                                                   port (
    14                                                       wrRegsOut                : out mRegs;
    15                                                       rdRegsIn                 : in mRegs;
    16                                                       S_AXI_ACLK               : in std_logic;
    17                                                       S_AXI_ARESETN            : in std_logic;
    18                                                       S_AXI_AWADDR             : in std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    19                                                       S_AXI_AWPROT             : in std_logic_vector(2 downto 0);
    20                                                       S_AXI_AWVALID            : in std_logic;
    21                                                       S_AXI_AWREADY            : out std_logic;
    22                                                       S_AXI_WDATA              : in std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    23                                                       S_AXI_WSTRB              : in std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
    24                                                       S_AXI_WVALID             : in std_logic;
    25                                                       S_AXI_WREADY             : out std_logic;
    26                                                       S_AXI_BRESP              : out std_logic_vector(1 downto 0);
    27                                                       S_AXI_BVALID             : out std_logic;
    28                                                       S_AXI_BREADY             : in std_logic;
    29                                                       S_AXI_ARADDR             : in std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    30                                                       S_AXI_ARPROT             : in std_logic_vector(2 downto 0);
    31                                                       S_AXI_ARVALID            : in std_logic;
    32                                                       S_AXI_ARREADY            : out std_logic;
    33                                                       S_AXI_RDATA              : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    34                                                       S_AXI_RRESP              : out std_logic_vector(1 downto 0);
    35                                                       S_AXI_RVALID             : out std_logic;
    36                                                       S_AXI_RREADY             : in std_logic);
    37                                               end videoProcess_v1_0_Config;
    38                                               architecture arch_imp of videoProcess_v1_0_Config is
    39                                               	constant ADDR_LSB            : integer := (C_S_AXI_DATA_WIDTH/32)+ 1;
    40                                               	constant OPT_MEM_ADDR_BITS   : integer := 5;
    41                                               	signal axi_awaddr	         : std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    42                                               	signal axi_awready	         : std_logic;
    43                                               	signal axi_wready	         : std_logic;
    44                                               	signal axi_bresp	         : std_logic_vector(1 downto 0);
    45                                               	signal axi_bvalid	         : std_logic;
    46                                               	signal axi_araddr	         : std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
    47                                               	signal axi_arready	         : std_logic;
    48                                               	signal axi_rdata	         : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    49                                               	signal axi_rresp	         : std_logic_vector(1 downto 0);
    50                                               	signal axi_rvalid	         : std_logic;
    51                                                   signal slv_reg_rden          : std_logic;
    52                                                   signal slv_reg_wren          : std_logic;
    53                                                   signal reg_data_out          : std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
    54                                                   signal byte_index            : integer;
    55                                                   signal aw_en                 : std_logic;
    56                                                   signal localRegs             : mRegs;
    57                                               
    58                                                   
    59                                               begin
    60              1                          2         S_AXI_AWREADY    <= axi_awready;
    61              1                          2         S_AXI_WREADY     <= axi_wready;
    62              1                          2         S_AXI_BRESP      <= axi_bresp;
    63              1                          2         S_AXI_BVALID     <= axi_bvalid;
    64              1                          2         S_AXI_ARREADY    <= axi_arready;
    65              1                          2         S_AXI_RDATA      <= axi_rdata;
    66              1                          2         S_AXI_RRESP      <= axi_rresp;
    67              1                          2         S_AXI_RVALID     <= axi_rvalid;
    68                                                   process (S_AXI_ACLK)
    69                                                   begin
    70                                                     if rising_edge(S_AXI_ACLK) then 
    71                                                       if S_AXI_ARESETN = '0' then
    72              1                          2               axi_awready <= '0';
    73              1                          2               aw_en <= '1';
    74                                                       else
    75                                                         if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    76              1                    ***0***                 axi_awready <= '1';
    77                                                           elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then
    78              1                    ***0***                     aw_en <= '1';
    79              1                    ***0***                     axi_awready <= '0';
    80                                                         else
    81              1                          1                 axi_awready <= '0';
    82                                                         end if;
    83                                                       end if;
    84                                                     end if;
    85                                                   end process;
    86                                                   process (S_AXI_ACLK)
    87                                                   begin
    88                                                     if rising_edge(S_AXI_ACLK) then 
    89                                                       if S_AXI_ARESETN = '0' then
    90              1                          2               axi_awaddr <= (others => '0');
    91                                                       else
    92                                                         if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    93              1                    ***0***                 axi_awaddr <= S_AXI_AWADDR;
    94                                                         end if;
    95                                                       end if;
    96                                                     end if;                   
    97                                                   end process; 
    98                                                   process (S_AXI_ACLK)
    99                                                   begin
    100                                                    if rising_edge(S_AXI_ACLK) then 
    101                                                      if S_AXI_ARESETN = '0' then
    102             1                          2               axi_wready <= '0';
    103                                                      else
    104                                                        if (axi_wready = '0' and S_AXI_WVALID = '1' and S_AXI_AWVALID = '1' and aw_en = '1') then
    105             1                    ***0***                   axi_wready <= '1';
    106                                                        else
    107             1                          1                 axi_wready <= '0';
    108                                                        end if;
    109                                                      end if;
    110                                                    end if;
    111                                                  end process; 
    112             1                          2         slv_reg_wren <= axi_wready and S_AXI_WVALID and axi_awready and S_AXI_AWVALID ;
    113                                              	process (S_AXI_ACLK)
    114                                              	variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0); 
    115                                              	begin
    116                                              	  if rising_edge(S_AXI_ACLK) then 
    117                                              	    if S_AXI_ARESETN = '0' then
    118             1                         99     	      localRegs.cfigReg0 <= (others => '0');
    119             1                         99     	      localRegs.cfigReg1 <= (others => '0');
    120             1                         99     	      localRegs.cfigReg2 <= (others => '0');
    121             1                         99     	      localRegs.cfigReg3 <= (others => '0');
    122             1                         99     	      localRegs.cfigReg4 <= (others => '0');
    123             1                         99     	      localRegs.cfigReg5 <= (others => '0');
    124             1                         99     	      localRegs.cfigReg6 <= (others => '0');
    125             1                         99     	      localRegs.cfigReg7 <= (others => '0');
    126             1                         99     	      localRegs.cfigReg8 <= (others => '0');
    127             1                         99     	      localRegs.cfigReg9 <= (others => '0');
    128             1                         99     	      localRegs.cfigReg10 <= (others => '0');
    129             1                         99     	      localRegs.cfigReg11 <= (others => '0');
    130             1                         99     	      localRegs.cfigReg12 <= (others => '0');
    131             1                         99     	      localRegs.cfigReg13 <= (others => '0');
    132             1                         99     	      localRegs.cfigReg14 <= (others => '0');
    133             1                         99     	      localRegs.cfigReg15 <= (others => '0');
    134             1                         99     	      localRegs.cfigReg16 <= (others => '0');
    135             1                         99     	      localRegs.cfigReg17 <= (others => '0');
    136             1                         99     	      localRegs.cfigReg18 <= (others => '0');
    137             1                         99     	      localRegs.cfigReg19 <= (others => '0');
    138             1                         99     	      localRegs.cfigReg20 <= (others => '0');
    139             1                         99     	      localRegs.cfigReg21 <= (others => '0');
    140             1                         99     	      localRegs.cfigReg22 <= (others => '0');
    141             1                         99     	      localRegs.cfigReg23 <= (others => '0');
    142             1                         99     	      localRegs.cfigReg24 <= (others => '0');
    143             1                         99     	      localRegs.cfigReg25 <= (others => '0');
    144             1                         99     	      localRegs.cfigReg26 <= (others => '0');
    145             1                         99     	      localRegs.cfigReg27 <= (others => '0');
    146             1                         99     	      localRegs.cfigReg28 <= (others => '0');
    147             1                         99     	      localRegs.cfigReg29 <= (others => '0');
    148             1                         99     	      localRegs.cfigReg30 <= (others => '0');
    149             1                         99     	      localRegs.cfigReg31 <= (others => '0');
    150             1                         99     	      localRegs.cfigReg32 <= (others => '0');
    151             1                         99     	      localRegs.cfigReg33 <= (others => '0');
    152             1                         99     	      localRegs.cfigReg34 <= (others => '0');
    153             1                         99     	      localRegs.cfigReg35 <= (others => '0');
    154             1                         99     	      localRegs.cfigReg36 <= (others => '0');
    155             1                         99     	      localRegs.cfigReg37 <= (others => '0');
    156             1                         99     	      localRegs.cfigReg38 <= (others => '0');
    157             1                         99     	      localRegs.cfigReg39 <= (others => '0');
    158             1                         99     	      localRegs.cfigReg40 <= (others => '0');
    159             1                         99     	      localRegs.cfigReg41 <= (others => '0');
    160             1                         99     	      localRegs.cfigReg42 <= (others => '0');
    161             1                         99     	      localRegs.cfigReg43 <= (others => '0');
    162             1                         99     	      localRegs.cfigReg44 <= (others => '0');
    163             1                         99     	      localRegs.cfigReg45 <= (others => '0');
    164             1                         99     	      localRegs.cfigReg46 <= (others => '0');
    165             1                         99     	      localRegs.cfigReg47 <= (others => '0');
    166             1                         99     	      localRegs.cfigReg48 <= (others => '0');
    167             1                         99     	      localRegs.cfigReg49 <= (others => '0');
    168             1                         99     	      localRegs.cfigReg50 <= (others => '0');
    169             1                         99     	      localRegs.cfigReg51 <= (others => '0');
    170             1                         99     	      localRegs.cfigReg52 <= (others => '0');
    171             1                         99     	      localRegs.cfigReg53 <= (others => '0');
    172             1                         99     	      localRegs.cfigReg54 <= (others => '0');
    173             1                         99     	      localRegs.cfigReg55 <= (others => '0');
    174             1                         99     	      localRegs.cfigReg56 <= (others => '0');
    175             1                         99     	      localRegs.cfigReg57 <= (others => '0');
    176             1                         99     	      localRegs.cfigReg58 <= (others => '0');
    177             1                         99     	      localRegs.cfigReg59 <= (others => '0');
    178             1                         99     	      localRegs.cfigReg60 <= (others => '0');
    179             1                         99     	      localRegs.cfigReg61 <= (others => '0');
    180             1                         99     	      localRegs.cfigReg62 <= (others => '0');
    181             1                         99     	      localRegs.cfigReg63 <= (others => '0');
    182                                              	    else
    183             1                       1032     	      loc_addr := axi_awaddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    184                                              	      if (slv_reg_wren = '1') then
    185                                              	        case loc_addr is
    186                                              	          when b"000000" =>
    187             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    187             2                    ***0***     
    188                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    189             1                    ***0***     	                localRegs.cfigReg0(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    190                                              	              end if;
    191             1                    ***0***     	            end loop;
    192                                              	          when b"000001" =>
    193             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    193             2                    ***0***     
    194                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    195             1                    ***0***     	                localRegs.cfigReg1(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    196                                              	              end if;
    197             1                    ***0***     	            end loop;
    198                                              	          when b"000010" =>
    199             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    199             2                    ***0***     
    200                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    201             1                    ***0***     	                localRegs.cfigReg2(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    202                                              	              end if;
    203             1                    ***0***     	            end loop;
    204                                              	          when b"000011" =>
    205             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    205             2                    ***0***     
    206                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    207             1                    ***0***     	                localRegs.cfigReg3(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    208                                              	              end if;
    209             1                    ***0***     	            end loop;
    210                                              	          when b"000100" =>
    211             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    211             2                    ***0***     
    212                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    213             1                    ***0***     	                localRegs.cfigReg4(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    214                                              	              end if;
    215             1                    ***0***     	            end loop;
    216                                              	          when b"000101" =>
    217             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    217             2                    ***0***     
    218                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    219             1                    ***0***     	                localRegs.cfigReg5(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    220                                              	              end if;
    221             1                    ***0***     	            end loop;
    222                                              	          when b"000110" =>
    223             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    223             2                    ***0***     
    224                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    225             1                    ***0***     	                localRegs.cfigReg6(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    226                                              	              end if;
    227             1                    ***0***     	            end loop;
    228                                              	          when b"000111" =>
    229             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    229             2                    ***0***     
    230                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    231             1                    ***0***     	                localRegs.cfigReg7(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    232                                              	              end if;
    233             1                    ***0***     	            end loop;
    234                                              	          when b"001000" =>
    235             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    235             2                    ***0***     
    236                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    237             1                    ***0***     	                localRegs.cfigReg8(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    238                                              	              end if;
    239             1                    ***0***     	            end loop;
    240                                              	          when b"001001" =>
    241             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    241             2                    ***0***     
    242                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    243             1                    ***0***     	                localRegs.cfigReg9(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    244                                              	              end if;
    245             1                    ***0***     	            end loop;
    246                                              	          when b"001010" =>
    247             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    247             2                    ***0***     
    248                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    249             1                    ***0***     	                localRegs.cfigReg10(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    250                                              	              end if;
    251             1                    ***0***     	            end loop;
    252                                              	          when b"001011" =>
    253             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    253             2                    ***0***     
    254                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    255             1                    ***0***     	                localRegs.cfigReg11(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    256                                              	              end if;
    257             1                    ***0***     	            end loop;
    258                                              	          when b"001100" =>
    259             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    259             2                    ***0***     
    260                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    261             1                    ***0***     	                localRegs.cfigReg12(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    262                                              	              end if;
    263             1                    ***0***     	            end loop;
    264                                              	          when b"001101" =>
    265             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    265             2                    ***0***     
    266                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    267             1                    ***0***     	                localRegs.cfigReg13(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    268                                              	              end if;
    269             1                    ***0***     	            end loop;
    270                                              	          when b"001110" =>
    271             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    271             2                    ***0***     
    272                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    273             1                    ***0***     	                localRegs.cfigReg14(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    274                                              	              end if;
    275             1                    ***0***     	            end loop;
    276                                              	          when b"001111" =>
    277             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    277             2                    ***0***     
    278                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    279             1                    ***0***     	                localRegs.cfigReg15(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    280                                              	              end if;
    281             1                    ***0***     	            end loop;
    282                                              	          when b"010000" =>
    283             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    283             2                    ***0***     
    284                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    285             1                    ***0***     	                localRegs.cfigReg16(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    286                                              	              end if;
    287             1                    ***0***     	            end loop;
    288                                              	          when b"010001" =>
    289             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    289             2                    ***0***     
    290                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    291             1                    ***0***     	                localRegs.cfigReg17(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    292                                              	              end if;
    293             1                    ***0***     	            end loop;
    294                                              	          when b"010010" =>
    295             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    295             2                    ***0***     
    296                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    297             1                    ***0***     	                localRegs.cfigReg18(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    298                                              	              end if;
    299             1                    ***0***     	            end loop;
    300                                              	          when b"010011" =>
    301             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    301             2                    ***0***     
    302                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    303             1                    ***0***     	                localRegs.cfigReg19(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    304                                              	              end if;
    305             1                    ***0***     	            end loop;
    306                                              	          when b"010100" =>
    307             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    307             2                    ***0***     
    308                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    309             1                    ***0***     	                localRegs.cfigReg20(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    310                                              	              end if;
    311             1                    ***0***     	            end loop;
    312                                              	          when b"010101" =>
    313             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    313             2                    ***0***     
    314                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    315             1                    ***0***     	                localRegs.cfigReg21(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    316                                              	              end if;
    317             1                    ***0***     	            end loop;
    318                                              	          when b"010110" =>
    319             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    319             2                    ***0***     
    320                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    321             1                    ***0***     	                localRegs.cfigReg22(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    322                                              	              end if;
    323             1                    ***0***     	            end loop;
    324                                              	          when b"010111" =>
    325             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    325             2                    ***0***     
    326                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    327             1                    ***0***     	                localRegs.cfigReg23(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    328                                              	              end if;
    329             1                    ***0***     	            end loop;
    330                                              	          when b"011000" =>
    331             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    331             2                    ***0***     
    332                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    333             1                    ***0***     	                localRegs.cfigReg24(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    334                                              	              end if;
    335             1                    ***0***     	            end loop;
    336                                              	          when b"011001" =>
    337             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    337             2                    ***0***     
    338                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    339             1                    ***0***     	                localRegs.cfigReg25(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    340                                              	              end if;
    341             1                    ***0***     	            end loop;
    342                                              	          when b"011010" =>
    343             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    343             2                    ***0***     
    344                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    345             1                    ***0***     	                localRegs.cfigReg26(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    346                                              	              end if;
    347             1                    ***0***     	            end loop;
    348                                              	          when b"011011" =>
    349             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    349             2                    ***0***     
    350                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    351             1                    ***0***     	                localRegs.cfigReg27(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    352                                              	              end if;
    353             1                    ***0***     	            end loop;
    354                                              	          when b"011100" =>
    355             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    355             2                    ***0***     
    356                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    357             1                    ***0***     	                localRegs.cfigReg28(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    358                                              	              end if;
    359             1                    ***0***     	            end loop;
    360                                              	          when b"011101" =>
    361             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    361             2                    ***0***     
    362                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    363             1                    ***0***     	                localRegs.cfigReg29(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    364                                              	              end if;
    365             1                    ***0***     	            end loop;
    366                                              	          when b"011110" =>
    367             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    367             2                    ***0***     
    368                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    369             1                    ***0***     	                localRegs.cfigReg30(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    370                                              	              end if;
    371             1                    ***0***     	            end loop;
    372                                              	          when b"011111" =>
    373             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    373             2                    ***0***     
    374                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    375             1                    ***0***     	                localRegs.cfigReg31(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    376                                              	              end if;
    377             1                    ***0***     	            end loop;
    378                                              	          when b"100000" =>
    379             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    379             2                    ***0***     
    380                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    381             1                    ***0***     	                localRegs.cfigReg32(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    382                                              	              end if;
    383             1                    ***0***     	            end loop;
    384                                              	          when b"100001" =>
    385             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    385             2                    ***0***     
    386                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    387             1                    ***0***     	                localRegs.cfigReg33(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    388                                              	              end if;
    389             1                    ***0***     	            end loop;
    390                                              	          when b"100010" =>
    391             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    391             2                    ***0***     
    392                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    393             1                    ***0***     	                localRegs.cfigReg34(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    394                                              	              end if;
    395             1                    ***0***     	            end loop;
    396                                              	          when b"100011" =>
    397             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    397             2                    ***0***     
    398                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    399             1                    ***0***     	                localRegs.cfigReg35(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    400                                              	              end if;
    401             1                    ***0***     	            end loop;
    402                                              	          when b"100100" =>
    403             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    403             2                    ***0***     
    404                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    405             1                    ***0***     	                localRegs.cfigReg36(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    406                                              	              end if;
    407             1                    ***0***     	            end loop;
    408                                              	          when b"100101" =>
    409             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    409             2                    ***0***     
    410                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    411             1                    ***0***     	                localRegs.cfigReg37(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    412                                              	              end if;
    413             1                    ***0***     	            end loop;
    414                                              	          when b"100110" =>
    415             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    415             2                    ***0***     
    416                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    417             1                    ***0***     	                localRegs.cfigReg38(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    418                                              	              end if;
    419             1                    ***0***     	            end loop;
    420                                              	          when b"100111" =>
    421             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    421             2                    ***0***     
    422                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    423             1                    ***0***     	                localRegs.cfigReg39(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    424                                              	              end if;
    425             1                    ***0***     	            end loop;
    426                                              	          when b"101000" =>
    427             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    427             2                    ***0***     
    428                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    429             1                    ***0***     	                localRegs.cfigReg40(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    430                                              	              end if;
    431             1                    ***0***     	            end loop;
    432                                              	          when b"101001" =>
    433             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    433             2                    ***0***     
    434                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    435             1                    ***0***     	                localRegs.cfigReg41(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    436                                              	              end if;
    437             1                    ***0***     	            end loop;
    438                                              	          when b"101010" =>
    439             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    439             2                    ***0***     
    440                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    441             1                    ***0***     	                localRegs.cfigReg42(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    442                                              	              end if;
    443             1                    ***0***     	            end loop;
    444                                              	          when b"101011" =>
    445             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    445             2                    ***0***     
    446                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    447             1                    ***0***     	                localRegs.cfigReg43(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    448                                              	              end if;
    449             1                    ***0***     	            end loop;
    450                                              	          when b"101100" =>
    451             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    451             2                    ***0***     
    452                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    453             1                    ***0***     	                localRegs.cfigReg44(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    454                                              	              end if;
    455             1                    ***0***     	            end loop;
    456                                              	          when b"101101" =>
    457             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    457             2                    ***0***     
    458                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    459             1                    ***0***     	                localRegs.cfigReg45(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    460                                              	              end if;
    461             1                    ***0***     	            end loop;
    462                                              	          when b"101110" =>
    463             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    463             2                    ***0***     
    464                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    465             1                    ***0***     	                localRegs.cfigReg46(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    466                                              	              end if;
    467             1                    ***0***     	            end loop;
    468                                              	          when b"101111" =>
    469             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    469             2                    ***0***     
    470                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    471             1                    ***0***     	                localRegs.cfigReg47(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    472                                              	              end if;
    473             1                    ***0***     	            end loop;
    474                                              	          when b"110000" =>
    475             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    475             2                    ***0***     
    476                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    477             1                    ***0***     	                localRegs.cfigReg48(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    478                                              	              end if;
    479             1                    ***0***     	            end loop;
    480                                              	          when b"110001" =>
    481             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    481             2                    ***0***     
    482                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    483             1                    ***0***     	                localRegs.cfigReg49(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    484                                              	              end if;
    485             1                    ***0***     	            end loop;
    486                                              	          when b"110010" =>
    487             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    487             2                    ***0***     
    488                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    489             1                    ***0***     	                localRegs.cfigReg50(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    490                                              	              end if;
    491             1                    ***0***     	            end loop;
    492                                              	          when b"110011" =>
    493             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    493             2                    ***0***     
    494                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    495             1                    ***0***     	                localRegs.cfigReg51(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    496                                              	              end if;
    497             1                    ***0***     	            end loop;
    498                                              	          when b"110100" =>
    499             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    499             2                    ***0***     
    500                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    501             1                    ***0***     	                localRegs.cfigReg52(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    502                                              	              end if;
    503             1                    ***0***     	            end loop;
    504                                              	          when b"110101" =>
    505             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    505             2                    ***0***     
    506                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    507             1                    ***0***     	                localRegs.cfigReg53(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    508                                              	              end if;
    509             1                    ***0***     	            end loop;
    510                                              	          when b"110110" =>
    511             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    511             2                    ***0***     
    512                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    513             1                    ***0***     	                localRegs.cfigReg54(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    514                                              	              end if;
    515             1                    ***0***     	            end loop;
    516                                              	          when b"110111" =>
    517             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    517             2                    ***0***     
    518                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    519             1                    ***0***     	                localRegs.cfigReg55(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    520                                              	              end if;
    521             1                    ***0***     	            end loop;
    522                                              	          when b"111000" =>
    523             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    523             2                    ***0***     
    524                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    525             1                    ***0***     	                localRegs.cfigReg56(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    526                                              	              end if;
    527             1                    ***0***     	            end loop;
    528                                              	          when b"111001" =>
    529             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    529             2                    ***0***     
    530                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    531             1                    ***0***     	                localRegs.cfigReg57(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    532                                              	              end if;
    533             1                    ***0***     	            end loop;
    534                                              	          when b"111010" =>
    535             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    535             2                    ***0***     
    536                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    537             1                    ***0***     	                localRegs.cfigReg58(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    538                                              	              end if;
    539             1                    ***0***     	            end loop;
    540                                              	          when b"111011" =>
    541             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    541             2                    ***0***     
    542                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    543             1                    ***0***     	                localRegs.cfigReg59(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    544                                              	              end if;
    545             1                    ***0***     	            end loop;
    546                                              	          when b"111100" =>
    547             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    547             2                    ***0***     
    548                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    549             1                    ***0***     	                localRegs.cfigReg60(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    550                                              	              end if;
    551             1                    ***0***     	            end loop;
    552                                              	          when b"111101" =>
    553             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    553             2                    ***0***     
    554                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    555             1                    ***0***     	                localRegs.cfigReg61(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    556                                              	              end if;
    557             1                    ***0***     	            end loop;
    558                                              	          when b"111110" =>
    559             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    559             2                    ***0***     
    560                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    561             1                    ***0***     	                localRegs.cfigReg62(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    562                                              	              end if;
    563             1                    ***0***     	            end loop;
    564                                              	          when b"111111" =>
    565             1                    ***0***     	            for byte_index in 0 to (C_S_AXI_DATA_WIDTH/8-1) loop
    565             2                    ***0***     
    566                                              	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
    567             1                    ***0***     	                localRegs.cfigReg63(byte_index*8+7 downto byte_index*8) <= S_AXI_WDATA(byte_index*8+7 downto byte_index*8);
    568                                              	              end if;
    569             1                    ***0***     	            end loop;
    570                                              	          when others =>
    571                                                              --stored cpu values
    572             1                    ***0***     	            localRegs.cfigReg0 <= localRegs.cfigReg0;
    573             1                    ***0***     	            localRegs.cfigReg1 <= localRegs.cfigReg1;
    574             1                    ***0***     	            localRegs.cfigReg2 <= localRegs.cfigReg2;
    575             1                    ***0***     	            localRegs.cfigReg3 <= localRegs.cfigReg3;
    576             1                    ***0***     	            localRegs.cfigReg4 <= localRegs.cfigReg4;
    577             1                    ***0***     	            localRegs.cfigReg5 <= localRegs.cfigReg5;
    578             1                    ***0***     	            localRegs.cfigReg6 <= localRegs.cfigReg6;
    579             1                    ***0***     	            localRegs.cfigReg7 <= localRegs.cfigReg7;
    580             1                    ***0***     	            localRegs.cfigReg8 <= localRegs.cfigReg8;
    581             1                    ***0***     	            localRegs.cfigReg9 <= localRegs.cfigReg9;
    582             1                    ***0***     	            localRegs.cfigReg10 <= localRegs.cfigReg10;
    583             1                    ***0***     	            localRegs.cfigReg11 <= localRegs.cfigReg11;
    584             1                    ***0***     	            localRegs.cfigReg12 <= localRegs.cfigReg12;
    585             1                    ***0***     	            localRegs.cfigReg13 <= localRegs.cfigReg13;
    586             1                    ***0***     	            localRegs.cfigReg14 <= localRegs.cfigReg14;
    587             1                    ***0***     	            localRegs.cfigReg15 <= localRegs.cfigReg15;
    588             1                    ***0***     	            localRegs.cfigReg16 <= localRegs.cfigReg16;
    589             1                    ***0***     	            localRegs.cfigReg17 <= localRegs.cfigReg17;
    590             1                    ***0***     	            localRegs.cfigReg18 <= localRegs.cfigReg18;
    591             1                    ***0***     	            localRegs.cfigReg19 <= localRegs.cfigReg19;
    592             1                    ***0***     	            localRegs.cfigReg20 <= localRegs.cfigReg20;
    593             1                    ***0***     	            localRegs.cfigReg21 <= localRegs.cfigReg21;
    594             1                    ***0***     	            localRegs.cfigReg22 <= localRegs.cfigReg22;
    595             1                    ***0***     	            localRegs.cfigReg23 <= localRegs.cfigReg23;
    596             1                    ***0***     	            localRegs.cfigReg24 <= localRegs.cfigReg24;
    597             1                    ***0***     	            localRegs.cfigReg25 <= localRegs.cfigReg25;
    598             1                    ***0***     	            localRegs.cfigReg26 <= localRegs.cfigReg26;
    599             1                    ***0***     	            localRegs.cfigReg27 <= localRegs.cfigReg27;
    600             1                    ***0***     	            localRegs.cfigReg28 <= localRegs.cfigReg28;
    601             1                    ***0***     	            localRegs.cfigReg29 <= localRegs.cfigReg29;
    602             1                    ***0***     	            localRegs.cfigReg30 <= localRegs.cfigReg30;
    603             1                    ***0***     	            localRegs.cfigReg31 <= localRegs.cfigReg31;
    604             1                    ***0***     	            localRegs.cfigReg32 <= localRegs.cfigReg32;
    605             1                    ***0***     	            localRegs.cfigReg33 <= localRegs.cfigReg33;
    606             1                    ***0***     	            localRegs.cfigReg34 <= localRegs.cfigReg34;
    607             1                    ***0***     	            localRegs.cfigReg35 <= localRegs.cfigReg35;
    608             1                    ***0***     	            localRegs.cfigReg36 <= localRegs.cfigReg36;
    609             1                    ***0***     	            localRegs.cfigReg37 <= localRegs.cfigReg37;
    610             1                    ***0***     	            localRegs.cfigReg38 <= localRegs.cfigReg38;
    611             1                    ***0***     	            localRegs.cfigReg39 <= localRegs.cfigReg39;
    612             1                    ***0***     	            localRegs.cfigReg40 <= localRegs.cfigReg40;
    613             1                    ***0***     	            localRegs.cfigReg41 <= localRegs.cfigReg41;
    614             1                    ***0***     	            localRegs.cfigReg42 <= localRegs.cfigReg42;
    615             1                    ***0***     	            localRegs.cfigReg43 <= localRegs.cfigReg43;
    616             1                    ***0***     	            localRegs.cfigReg44 <= localRegs.cfigReg44;
    617             1                    ***0***     	            localRegs.cfigReg45 <= localRegs.cfigReg45;
    618             1                    ***0***     	            localRegs.cfigReg46 <= localRegs.cfigReg46;
    619             1                    ***0***     	            localRegs.cfigReg47 <= localRegs.cfigReg47;
    620             1                    ***0***     	            localRegs.cfigReg48 <= localRegs.cfigReg48;
    621             1                    ***0***     	            localRegs.cfigReg49 <= localRegs.cfigReg49;
    622             1                    ***0***     	            localRegs.cfigReg50 <= localRegs.cfigReg50;
    623             1                    ***0***     	            localRegs.cfigReg51 <= localRegs.cfigReg51;
    624             1                    ***0***     	            localRegs.cfigReg52 <= localRegs.cfigReg52;
    625             1                    ***0***     	            localRegs.cfigReg53 <= localRegs.cfigReg53;
    626             1                    ***0***     	            localRegs.cfigReg54 <= localRegs.cfigReg54;
    627             1                    ***0***     	            localRegs.cfigReg55 <= localRegs.cfigReg55;
    628             1                    ***0***     	            localRegs.cfigReg56 <= localRegs.cfigReg56;
    629             1                    ***0***     	            localRegs.cfigReg57 <= localRegs.cfigReg57;
    630             1                    ***0***     	            localRegs.cfigReg58 <= localRegs.cfigReg58;
    631             1                    ***0***     	            localRegs.cfigReg59 <= localRegs.cfigReg59;
    632             1                    ***0***     	            localRegs.cfigReg60 <= localRegs.cfigReg60;
    633             1                    ***0***     	            localRegs.cfigReg61 <= localRegs.cfigReg61;
    634             1                    ***0***     	            localRegs.cfigReg62 <= localRegs.cfigReg62;
    635             1                    ***0***     	            localRegs.cfigReg63 <= localRegs.cfigReg63;
    636                                              	        end case;
    637                                              	      end if;
    638                                              	    end if;
    639                                              	  end if;                   
    640                                              	end process; 
    641                                                  process (S_AXI_ACLK)
    642                                                  begin
    643                                                    if rising_edge(S_AXI_ACLK) then 
    644                                                      if S_AXI_ARESETN = '0' then
    645             1                          2               axi_bvalid  <= '0';
    646             1                          2               axi_bresp   <= "00"; 
    647                                                      else
    648                                                        if (axi_awready = '1' and S_AXI_AWVALID = '1' and axi_wready = '1' and S_AXI_WVALID = '1' and axi_bvalid = '0'  ) then
    649             1                    ***0***                 axi_bvalid <= '1';
    650             1                    ***0***                 axi_bresp  <= "00"; 
    651                                                        elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then   
    652             1                    ***0***                 axi_bvalid <= '0';                                 
    653                                                        end if;
    654                                                      end if;
    655                                                    end if;                   
    656                                                  end process; 
    657                                                  process (S_AXI_ACLK)
    658                                                  begin
    659                                                    if rising_edge(S_AXI_ACLK) then 
    660                                                      if S_AXI_ARESETN = '0' then
    661             1                          2               axi_arready <= '0';
    662             1                          2               axi_araddr  <= (others => '1');
    663                                                      else
    664                                                        if (axi_arready = '0' and S_AXI_ARVALID = '1') then
    665             1                    ***0***                 axi_arready <= '1';
    666             1                    ***0***                 axi_araddr  <= S_AXI_ARADDR;           
    667                                                        else
    668             1                          1                 axi_arready <= '0';
    669                                                        end if;
    670                                                      end if;
    671                                                    end if;                   
    672                                                  end process; 
    673                                                  process (S_AXI_ACLK)
    674                                                  begin
    675                                                    if rising_edge(S_AXI_ACLK) then
    676                                                      if S_AXI_ARESETN = '0' then
    677             1                          2               axi_rvalid <= '0';
    678             1                          2               axi_rresp  <= "00";
    679                                                      else
    680                                                        if (axi_arready = '1' and S_AXI_ARVALID = '1' and axi_rvalid = '0') then
    681             1                    ***0***                 axi_rvalid <= '1';
    682             1                    ***0***                 axi_rresp  <= "00"; 
    683                                                        elsif (axi_rvalid = '1' and S_AXI_RREADY = '1') then
    684             1                    ***0***                 axi_rvalid <= '0';
    685                                                        end if;            
    686                                                      end if;
    687                                                    end if;
    688                                                  end process;
    689             1                          2         slv_reg_rden <= axi_arready and S_AXI_ARVALID and (not axi_rvalid);
    690             1                          9     process (axi_araddr, S_AXI_ARESETN, slv_reg_rden, rdRegsIn.cfigReg0, rdRegsIn.cfigReg1, rdRegsIn.cfigReg2, rdRegsIn.cfigReg3, rdRegsIn.cfigReg4, rdRegsIn.cfigReg5, rdRegsIn.cfigReg6, rdRegsIn.cfigReg7, rdRegsIn.cfigReg8, rdRegsIn.cfigReg9, rdRegsIn.cfigReg10, rdRegsIn.cfigReg11, rdRegsIn.cfigReg12, rdRegsIn.cfigReg13, rdRegsIn.cfigReg14, rdRegsIn.cfigReg15, rdRegsIn.cfigReg16, rdRegsIn.cfigReg17, rdRegsIn.cfigReg18, rdRegsIn.cfigReg19, rdRegsIn.cfigReg20, rdRegsIn.cfigReg21, rdRegsIn.cfigReg22, rdRegsIn.cfigReg23, rdRegsIn.cfigReg24, rdRegsIn.cfigReg25, rdRegsIn.cfigReg26, rdRegsIn.cfigReg27, rdRegsIn.cfigReg28, rdRegsIn.cfigReg29, rdRegsIn.cfigReg30, rdRegsIn.cfigReg31, rdRegsIn.cfigReg32, rdRegsIn.cfigReg33, rdRegsIn.cfigReg34, rdRegsIn.cfigReg35, rdRegsIn.cfigReg36, rdRegsIn.cfigReg37, rdRegsIn.cfigReg38, rdRegsIn.cfigReg39, rdRegsIn.cfigReg40, rdRegsIn.cfigReg41, rdRegsIn.cfigReg42, rdRegsIn.cfigReg43, rdRegsIn.cfigReg44, rdRegsIn.cfigReg45, rdRegsIn.cfigReg46, rdRegsIn.cfigReg47, rdRegsIn.cfigReg48, rdRegsIn.cfigReg49, rdRegsIn.cfigReg50, rdRegsIn.cfigReg51, rdRegsIn.cfigReg52, rdRegsIn.cfigReg53, rdRegsIn.cfigReg54, rdRegsIn.cfigReg55, rdRegsIn.cfigReg56, rdRegsIn.cfigReg57, rdRegsIn.cfigReg58, rdRegsIn.cfigReg59, rdRegsIn.cfigReg60, rdRegsIn.cfigReg61, rdRegsIn.cfigReg62, rdRegsIn.cfigReg63)
    691                                                  variable loc_addr :std_logic_vector(OPT_MEM_ADDR_BITS downto 0);
    692                                                  begin
    693             1                          9             loc_addr := axi_araddr(ADDR_LSB + OPT_MEM_ADDR_BITS downto ADDR_LSB);
    694                                                      case loc_addr is
    695                                                        when b"000000" =>
    696             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg0;
    697                                                        when b"000001" =>
    698             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg1;
    699                                                        when b"000010" =>
    700             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg2;
    701                                                        when b"000011" =>
    702             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg3;
    703                                                        when b"000100" =>
    704             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg4;
    705                                                        when b"000101" =>
    706             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg5;
    707                                                        when b"000110" =>
    708             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg6;
    709                                                        when b"000111" =>
    710             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg7;
    711                                                        when b"001000" =>
    712             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg8;
    713                                                        when b"001001" =>
    714             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg9;
    715                                                        when b"001010" =>
    716             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg10;
    717                                                        when b"001011" =>
    718             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg11;
    719                                                        when b"001100" =>
    720             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg12;
    721                                                        when b"001101" =>
    722             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg13;
    723                                                        when b"001110" =>
    724             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg14;
    725                                                        when b"001111" =>
    726             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg15;
    727                                                        when b"010000" =>
    728             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg16;
    729                                                        when b"010001" =>
    730             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg17;
    731                                                        when b"010010" =>
    732             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg18;
    733                                                        when b"010011" =>
    734             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg19;
    735                                                        when b"010100" =>
    736             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg20;
    737                                                        when b"010101" =>
    738             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg21;
    739                                                        when b"010110" =>
    740             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg22;
    741                                                        when b"010111" =>
    742             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg23;
    743                                                        when b"011000" =>
    744             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg24;
    745                                                        when b"011001" =>
    746             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg25;
    747                                                        when b"011010" =>
    748             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg26;
    749                                                        when b"011011" =>
    750             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg27;
    751                                                        when b"011100" =>
    752             1                    ***0***                 reg_data_out <= rdRegsIn.cfigReg28;
    753                                                        when b"011101" =>
    754             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg29;
    755                                                        when b"011110" =>
    756             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg30;
    757                                                        when b"011111" =>
    758             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg31;
    759                                              	      when b"100000" =>
    760             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg32;
    761                                              	      when b"100001" =>
    762             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg33;
    763                                              	      when b"100010" =>
    764             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg34;
    765                                              	      when b"100011" =>
    766             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg35;
    767                                              	      when b"100100" =>
    768             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg36;
    769                                              	      when b"100101" =>
    770             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg37;
    771                                              	      when b"100110" =>
    772             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg38;
    773                                              	      when b"100111" =>
    774             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg39;
    775                                              	      when b"101000" =>
    776             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg40;
    777                                              	      when b"101001" =>
    778             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg41;
    779                                              	      when b"101010" =>
    780             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg42;
    781                                              	      when b"101011" =>
    782             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg43;
    783                                              	      when b"101100" =>
    784             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg44;
    785                                              	      when b"101101" =>
    786             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg45;
    787                                              	      when b"101110" =>
    788             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg46;
    789                                              	      when b"101111" =>
    790             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg47;
    791                                              	      when b"110000" =>
    792             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg48;
    793                                              	      when b"110001" =>
    794             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg49;
    795                                              	      when b"110010" =>
    796             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg50;
    797                                              	      when b"110011" =>
    798             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg51;
    799                                              	      when b"110100" =>
    800             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg52;
    801                                              	      when b"110101" =>
    802             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg53;
    803                                              	      when b"110110" =>
    804             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg54;
    805                                              	      when b"110111" =>
    806             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg55;
    807                                              	      when b"111000" =>
    808             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg56;
    809                                              	      when b"111001" =>
    810             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg57;
    811                                              	      when b"111010" =>
    812             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg58;
    813                                              	      when b"111011" =>
    814             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg59;
    815                                              	      when b"111100" =>
    816             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg60;
    817                                              	      when b"111101" =>
    818             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg61;
    819                                              	      when b"111110" =>
    820             1                    ***0***     	        reg_data_out <= rdRegsIn.cfigReg62;
    821                                              	      when b"111111" =>
    822             1                          6     	        reg_data_out <= rdRegsIn.cfigReg63;
    823                                                        when others =>
    824             1                          3                 reg_data_out  <= (others => '0');
    825                                                      end case;
    826                                                  end process;
    827                                                  
    828                                                  process( S_AXI_ACLK ) begin
    829                                                    if (rising_edge (S_AXI_ACLK)) then
    830                                                      if ( S_AXI_ARESETN = '0' ) then
    831             1                          2               axi_rdata  <= (others => '0');
    832                                                      else
    833                                                        if (slv_reg_rden = '1') then
    834             1                    ***0***                   axi_rdata <= reg_data_out;     
    835                                                        end if;   
    836                                                      end if;
    837                                                    end if;
    838                                                  end process;
    839                                              
    840                                                  cpuOut: process (S_AXI_ACLK) begin
    841                                                      if (rising_edge (S_AXI_ACLK)) then
    842             1                       1131                 wrRegsOut <= localRegs;
    843                                                      end if;
    844                                                  end process cpuOut;
    845                                              
    846                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                       302        35       267      11.5

================================Branch Details================================

Branch Coverage for file ../modules/dut/vfpConfig.vhd --

------------------------------------IF Branch------------------------------------
    70                                         3     Count coming in to IF
    70              1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    71                                         3     Count coming in to IF
    71              1                          2             if S_AXI_ARESETN = '0' then
    74              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    75                                         1     Count coming in to IF
    75              1                    ***0***               if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
    77              1                    ***0***                 elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then
    80              1                          1               else
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    88                                         3     Count coming in to IF
    88              1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    89                                         3     Count coming in to IF
    89              1                          2             if S_AXI_ARESETN = '0' then
    91              1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    92                                         1     Count coming in to IF
    92              1                    ***0***               if (axi_awready = '0' and S_AXI_AWVALID = '1' and S_AXI_WVALID = '1' and aw_en = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    100                                        3     Count coming in to IF
    100             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    101                                        3     Count coming in to IF
    101             1                          2             if S_AXI_ARESETN = '0' then
    103             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    104                                        1     Count coming in to IF
    104             1                    ***0***               if (axi_wready = '0' and S_AXI_WVALID = '1' and S_AXI_AWVALID = '1' and aw_en = '1') then
    106             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    116                                     1131     Count coming in to IF
    116             1                       1131     	  if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    117                                     1131     Count coming in to IF
    117             1                         99     	    if S_AXI_ARESETN = '0' then
    182             1                       1032     	    else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    184                                     1032     Count coming in to IF
    184             1                    ***0***     	      if (slv_reg_wren = '1') then
                                            1032     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------CASE Branch------------------------------------
    185                                  ***0***     Count coming in to CASE
    186             1                    ***0***     	          when b"000000" =>
    192             1                    ***0***     	          when b"000001" =>
    198             1                    ***0***     	          when b"000010" =>
    204             1                    ***0***     	          when b"000011" =>
    210             1                    ***0***     	          when b"000100" =>
    216             1                    ***0***     	          when b"000101" =>
    222             1                    ***0***     	          when b"000110" =>
    228             1                    ***0***     	          when b"000111" =>
    234             1                    ***0***     	          when b"001000" =>
    240             1                    ***0***     	          when b"001001" =>
    246             1                    ***0***     	          when b"001010" =>
    252             1                    ***0***     	          when b"001011" =>
    258             1                    ***0***     	          when b"001100" =>
    264             1                    ***0***     	          when b"001101" =>
    270             1                    ***0***     	          when b"001110" =>
    276             1                    ***0***     	          when b"001111" =>
    282             1                    ***0***     	          when b"010000" =>
    288             1                    ***0***     	          when b"010001" =>
    294             1                    ***0***     	          when b"010010" =>
    300             1                    ***0***     	          when b"010011" =>
    306             1                    ***0***     	          when b"010100" =>
    312             1                    ***0***     	          when b"010101" =>
    318             1                    ***0***     	          when b"010110" =>
    324             1                    ***0***     	          when b"010111" =>
    330             1                    ***0***     	          when b"011000" =>
    336             1                    ***0***     	          when b"011001" =>
    342             1                    ***0***     	          when b"011010" =>
    348             1                    ***0***     	          when b"011011" =>
    354             1                    ***0***     	          when b"011100" =>
    360             1                    ***0***     	          when b"011101" =>
    366             1                    ***0***     	          when b"011110" =>
    372             1                    ***0***     	          when b"011111" =>
    378             1                    ***0***     	          when b"100000" =>
    384             1                    ***0***     	          when b"100001" =>
    390             1                    ***0***     	          when b"100010" =>
    396             1                    ***0***     	          when b"100011" =>
    402             1                    ***0***     	          when b"100100" =>
    408             1                    ***0***     	          when b"100101" =>
    414             1                    ***0***     	          when b"100110" =>
    420             1                    ***0***     	          when b"100111" =>
    426             1                    ***0***     	          when b"101000" =>
    432             1                    ***0***     	          when b"101001" =>
    438             1                    ***0***     	          when b"101010" =>
    444             1                    ***0***     	          when b"101011" =>
    450             1                    ***0***     	          when b"101100" =>
    456             1                    ***0***     	          when b"101101" =>
    462             1                    ***0***     	          when b"101110" =>
    468             1                    ***0***     	          when b"101111" =>
    474             1                    ***0***     	          when b"110000" =>
    480             1                    ***0***     	          when b"110001" =>
    486             1                    ***0***     	          when b"110010" =>
    492             1                    ***0***     	          when b"110011" =>
    498             1                    ***0***     	          when b"110100" =>
    504             1                    ***0***     	          when b"110101" =>
    510             1                    ***0***     	          when b"110110" =>
    516             1                    ***0***     	          when b"110111" =>
    522             1                    ***0***     	          when b"111000" =>
    528             1                    ***0***     	          when b"111001" =>
    534             1                    ***0***     	          when b"111010" =>
    540             1                    ***0***     	          when b"111011" =>
    546             1                    ***0***     	          when b"111100" =>
    552             1                    ***0***     	          when b"111101" =>
    558             1                    ***0***     	          when b"111110" =>
    564             1                    ***0***     	          when b"111111" =>
    570             1                    ***0***     	          when others =>
Branch totals: 0 hits of 65 branches = 0.0%

------------------------------------IF Branch------------------------------------
    188                                  ***0***     Count coming in to IF
    188             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    194                                  ***0***     Count coming in to IF
    194             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    200                                  ***0***     Count coming in to IF
    200             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    206                                  ***0***     Count coming in to IF
    206             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    212                                  ***0***     Count coming in to IF
    212             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    218                                  ***0***     Count coming in to IF
    218             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    224                                  ***0***     Count coming in to IF
    224             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    230                                  ***0***     Count coming in to IF
    230             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    236                                  ***0***     Count coming in to IF
    236             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    242                                  ***0***     Count coming in to IF
    242             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    248                                  ***0***     Count coming in to IF
    248             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    254                                  ***0***     Count coming in to IF
    254             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    260                                  ***0***     Count coming in to IF
    260             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    266                                  ***0***     Count coming in to IF
    266             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    272                                  ***0***     Count coming in to IF
    272             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    278                                  ***0***     Count coming in to IF
    278             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    284                                  ***0***     Count coming in to IF
    284             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    290                                  ***0***     Count coming in to IF
    290             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    296                                  ***0***     Count coming in to IF
    296             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    302                                  ***0***     Count coming in to IF
    302             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    308                                  ***0***     Count coming in to IF
    308             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    314                                  ***0***     Count coming in to IF
    314             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    320                                  ***0***     Count coming in to IF
    320             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    326                                  ***0***     Count coming in to IF
    326             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    332                                  ***0***     Count coming in to IF
    332             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    338                                  ***0***     Count coming in to IF
    338             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    344                                  ***0***     Count coming in to IF
    344             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    350                                  ***0***     Count coming in to IF
    350             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    356                                  ***0***     Count coming in to IF
    356             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    362                                  ***0***     Count coming in to IF
    362             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    368                                  ***0***     Count coming in to IF
    368             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    374                                  ***0***     Count coming in to IF
    374             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    380                                  ***0***     Count coming in to IF
    380             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    386                                  ***0***     Count coming in to IF
    386             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    392                                  ***0***     Count coming in to IF
    392             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    398                                  ***0***     Count coming in to IF
    398             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    404                                  ***0***     Count coming in to IF
    404             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    410                                  ***0***     Count coming in to IF
    410             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    416                                  ***0***     Count coming in to IF
    416             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    422                                  ***0***     Count coming in to IF
    422             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    428                                  ***0***     Count coming in to IF
    428             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    434                                  ***0***     Count coming in to IF
    434             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    440                                  ***0***     Count coming in to IF
    440             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    446                                  ***0***     Count coming in to IF
    446             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    452                                  ***0***     Count coming in to IF
    452             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    458                                  ***0***     Count coming in to IF
    458             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    464                                  ***0***     Count coming in to IF
    464             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    470                                  ***0***     Count coming in to IF
    470             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    476                                  ***0***     Count coming in to IF
    476             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    482                                  ***0***     Count coming in to IF
    482             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    488                                  ***0***     Count coming in to IF
    488             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    494                                  ***0***     Count coming in to IF
    494             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    500                                  ***0***     Count coming in to IF
    500             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    506                                  ***0***     Count coming in to IF
    506             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    512                                  ***0***     Count coming in to IF
    512             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    518                                  ***0***     Count coming in to IF
    518             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    524                                  ***0***     Count coming in to IF
    524             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    530                                  ***0***     Count coming in to IF
    530             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    536                                  ***0***     Count coming in to IF
    536             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    542                                  ***0***     Count coming in to IF
    542             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    548                                  ***0***     Count coming in to IF
    548             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    554                                  ***0***     Count coming in to IF
    554             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    560                                  ***0***     Count coming in to IF
    560             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    566                                  ***0***     Count coming in to IF
    566             1                    ***0***     	              if ( S_AXI_WSTRB(byte_index) = '1' ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    643                                        3     Count coming in to IF
    643             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    644                                        3     Count coming in to IF
    644             1                          2             if S_AXI_ARESETN = '0' then
    647             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    648                                        1     Count coming in to IF
    648             1                    ***0***               if (axi_awready = '1' and S_AXI_AWVALID = '1' and axi_wready = '1' and S_AXI_WVALID = '1' and axi_bvalid = '0'  ) then
    651             1                    ***0***               elsif (S_AXI_BREADY = '1' and axi_bvalid = '1') then   
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------IF Branch------------------------------------
    659                                        3     Count coming in to IF
    659             1                          3           if rising_edge(S_AXI_ACLK) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    660                                        3     Count coming in to IF
    660             1                          2             if S_AXI_ARESETN = '0' then
    663             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    664                                        1     Count coming in to IF
    664             1                    ***0***               if (axi_arready = '0' and S_AXI_ARVALID = '1') then
    667             1                          1               else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    675                                        3     Count coming in to IF
    675             1                          3           if rising_edge(S_AXI_ACLK) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    676                                        3     Count coming in to IF
    676             1                          2             if S_AXI_ARESETN = '0' then
    679             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    680                                        1     Count coming in to IF
    680             1                    ***0***               if (axi_arready = '1' and S_AXI_ARVALID = '1' and axi_rvalid = '0') then
    683             1                    ***0***               elsif (axi_rvalid = '1' and S_AXI_RREADY = '1') then
                                               1     All False Count
Branch totals: 1 hit of 3 branches = 33.3%

------------------------------------CASE Branch------------------------------------
    694                                        9     Count coming in to CASE
    695             1                    ***0***               when b"000000" =>
    697             1                    ***0***               when b"000001" =>
    699             1                    ***0***               when b"000010" =>
    701             1                    ***0***               when b"000011" =>
    703             1                    ***0***               when b"000100" =>
    705             1                    ***0***               when b"000101" =>
    707             1                    ***0***               when b"000110" =>
    709             1                    ***0***               when b"000111" =>
    711             1                    ***0***               when b"001000" =>
    713             1                    ***0***               when b"001001" =>
    715             1                    ***0***               when b"001010" =>
    717             1                    ***0***               when b"001011" =>
    719             1                    ***0***               when b"001100" =>
    721             1                    ***0***               when b"001101" =>
    723             1                    ***0***               when b"001110" =>
    725             1                    ***0***               when b"001111" =>
    727             1                    ***0***               when b"010000" =>
    729             1                    ***0***               when b"010001" =>
    731             1                    ***0***               when b"010010" =>
    733             1                    ***0***               when b"010011" =>
    735             1                    ***0***               when b"010100" =>
    737             1                    ***0***               when b"010101" =>
    739             1                    ***0***               when b"010110" =>
    741             1                    ***0***               when b"010111" =>
    743             1                    ***0***               when b"011000" =>
    745             1                    ***0***               when b"011001" =>
    747             1                    ***0***               when b"011010" =>
    749             1                    ***0***               when b"011011" =>
    751             1                    ***0***               when b"011100" =>
    753             1                    ***0***               when b"011101" =>
    755             1                    ***0***               when b"011110" =>
    757             1                    ***0***               when b"011111" =>
    759             1                    ***0***     	      when b"100000" =>
    761             1                    ***0***     	      when b"100001" =>
    763             1                    ***0***     	      when b"100010" =>
    765             1                    ***0***     	      when b"100011" =>
    767             1                    ***0***     	      when b"100100" =>
    769             1                    ***0***     	      when b"100101" =>
    771             1                    ***0***     	      when b"100110" =>
    773             1                    ***0***     	      when b"100111" =>
    775             1                    ***0***     	      when b"101000" =>
    777             1                    ***0***     	      when b"101001" =>
    779             1                    ***0***     	      when b"101010" =>
    781             1                    ***0***     	      when b"101011" =>
    783             1                    ***0***     	      when b"101100" =>
    785             1                    ***0***     	      when b"101101" =>
    787             1                    ***0***     	      when b"101110" =>
    789             1                    ***0***     	      when b"101111" =>
    791             1                    ***0***     	      when b"110000" =>
    793             1                    ***0***     	      when b"110001" =>
    795             1                    ***0***     	      when b"110010" =>
    797             1                    ***0***     	      when b"110011" =>
    799             1                    ***0***     	      when b"110100" =>
    801             1                    ***0***     	      when b"110101" =>
    803             1                    ***0***     	      when b"110110" =>
    805             1                    ***0***     	      when b"110111" =>
    807             1                    ***0***     	      when b"111000" =>
    809             1                    ***0***     	      when b"111001" =>
    811             1                    ***0***     	      when b"111010" =>
    813             1                    ***0***     	      when b"111011" =>
    815             1                    ***0***     	      when b"111100" =>
    817             1                    ***0***     	      when b"111101" =>
    819             1                    ***0***     	      when b"111110" =>
    821             1                          6     	      when b"111111" =>
    823             1                          3               when others =>
Branch totals: 2 hits of 65 branches = 3.0%

------------------------------------IF Branch------------------------------------
    829                                        3     Count coming in to IF
    829             1                          3           if (rising_edge (S_AXI_ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    830                                        3     Count coming in to IF
    830             1                          2             if ( S_AXI_ARESETN = '0' ) then
    832             1                          1             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    833                                        1     Count coming in to IF
    833             1                    ***0***               if (slv_reg_rden = '1') then
                                               1     All False Count
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    841                                     1131     Count coming in to IF
    841             1                       1131             if (rising_edge (S_AXI_ACLK)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms             28         0        28       0.0

================================Condition Details================================

Condition Coverage for file ../modules/dut/vfpConfig.vhd --

----------------Focused Condition View-------------------
Line       75 Item    1  ((((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_AWVALID = '1')         N  '_1' not hit             Hit '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0    -                             
  Row   2:    ***0***  (axi_awready = '0')_1    (aw_en = '1') && (S_AXI_WVALID = '1') && (S_AXI_AWVALID = '1')
  Row   3:          1  (S_AXI_AWVALID = '1')_0  (axi_awready = '0')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && (S_AXI_WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (S_AXI_WVALID = '1')_0   ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       77 Item    1  ((S_AXI_BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (S_AXI_BREADY = '1')         N  '_1' not hit             Hit '_1'
    (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (S_AXI_BREADY = '1')_0  -                             
  Row   2:    ***0***  (S_AXI_BREADY = '1')_1  (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0    (S_AXI_BREADY = '1')          
  Row   4:    ***0***  (axi_bvalid = '1')_1    (S_AXI_BREADY = '1')          

----------------Focused Condition View-------------------
Line       92 Item    1  ((((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_AWVALID = '1')         N  '_1' not hit             Hit '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_awready = '0')_0    -                             
  Row   2:    ***0***  (axi_awready = '0')_1    (aw_en = '1') && (S_AXI_WVALID = '1') && (S_AXI_AWVALID = '1')
  Row   3:          1  (S_AXI_AWVALID = '1')_0  (axi_awready = '0')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && (S_AXI_WVALID = '1') && (axi_awready = '0')
  Row   5:    ***0***  (S_AXI_WVALID = '1')_0   ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && ((axi_awready = '0') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_awready = '0') and (S_AXI_AWVALID = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       104 Item    1  ((((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1')) and (aw_en = '1'))
Condition totals: 0 of 4 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
     (axi_wready = '0')         N  No hits                  Hit '_0' and '_1'
   (S_AXI_WVALID = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
          (aw_en = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_wready = '0')_0     -                             
  Row   2:    ***0***  (axi_wready = '0')_1     (aw_en = '1') && (S_AXI_AWVALID = '1') && (S_AXI_WVALID = '1')
  Row   3:          1  (S_AXI_WVALID = '1')_0   (axi_wready = '0')            
  Row   4:    ***0***  (S_AXI_WVALID = '1')_1   (aw_en = '1') && (S_AXI_AWVALID = '1') && (axi_wready = '0')
  Row   5:    ***0***  (S_AXI_AWVALID = '1')_0  ((axi_wready = '0') and (S_AXI_WVALID = '1'))
  Row   6:    ***0***  (S_AXI_AWVALID = '1')_1  (aw_en = '1') && ((axi_wready = '0') and (S_AXI_WVALID = '1'))
  Row   7:    ***0***  (aw_en = '1')_0          (((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1'))
  Row   8:    ***0***  (aw_en = '1')_1          (((axi_wready = '0') and (S_AXI_WVALID = '1')) and (S_AXI_AWVALID = '1'))

----------------Focused Condition View-------------------
Line       648 Item    1  (((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1')) and (axi_bvalid = '0'))
Condition totals: 0 of 5 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_awready = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_AWVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_wready = '1')         N  No hits                  Hit '_0' and '_1'
   (S_AXI_WVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_bvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (axi_awready = '1')_0    -                             
  Row   2:    ***0***  (axi_awready = '1')_1    (axi_bvalid = '0') && (S_AXI_WVALID = '1') && (axi_wready = '1') && (S_AXI_AWVALID = '1')
  Row   3:    ***0***  (S_AXI_AWVALID = '1')_0  (axi_awready = '1')           
  Row   4:    ***0***  (S_AXI_AWVALID = '1')_1  (axi_bvalid = '0') && (S_AXI_WVALID = '1') && (axi_wready = '1') && (axi_awready = '1')
  Row   5:    ***0***  (axi_wready = '1')_0     ((axi_awready = '1') and (S_AXI_AWVALID = '1'))
  Row   6:    ***0***  (axi_wready = '1')_1     (axi_bvalid = '0') && (S_AXI_WVALID = '1') && ((axi_awready = '1') and (S_AXI_AWVALID = '1'))
  Row   7:    ***0***  (S_AXI_WVALID = '1')_0   (((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1'))
  Row   8:    ***0***  (S_AXI_WVALID = '1')_1   (axi_bvalid = '0') && (((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1'))
  Row   9:    ***0***  (axi_bvalid = '0')_0     ((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1'))
 Row   10:    ***0***  (axi_bvalid = '0')_1     ((((axi_awready = '1') and (S_AXI_AWVALID = '1')) and (axi_wready = '1')) and (S_AXI_WVALID = '1'))

----------------Focused Condition View-------------------
Line       651 Item    1  ((S_AXI_BREADY = '1') and (axi_bvalid = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
  (S_AXI_BREADY = '1')         N  '_1' not hit             Hit '_1'
    (axi_bvalid = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (S_AXI_BREADY = '1')_0  -                             
  Row   2:    ***0***  (S_AXI_BREADY = '1')_1  (axi_bvalid = '1')            
  Row   3:    ***0***  (axi_bvalid = '1')_0    (S_AXI_BREADY = '1')          
  Row   4:    ***0***  (axi_bvalid = '1')_1    (S_AXI_BREADY = '1')          

----------------Focused Condition View-------------------
Line       664 Item    1  ((axi_arready = '0') and (S_AXI_ARVALID = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_arready = '0')         N  No hits                  Hit '_0' and '_1'
  (S_AXI_ARVALID = '1')         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (axi_arready = '0')_0    -                             
  Row   2:    ***0***  (axi_arready = '0')_1    (S_AXI_ARVALID = '1')         
  Row   3:          1  (S_AXI_ARVALID = '1')_0  (axi_arready = '0')           
  Row   4:    ***0***  (S_AXI_ARVALID = '1')_1  (axi_arready = '0')           

----------------Focused Condition View-------------------
Line       680 Item    1  (((axi_arready = '1') and (S_AXI_ARVALID = '1')) and (axi_rvalid = '0'))
Condition totals: 0 of 3 input terms covered = 0.0%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
    (axi_arready = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_ARVALID = '1')         N  No hits                  Hit '_0' and '_1'
     (axi_rvalid = '0')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:          1  (axi_arready = '1')_0    -                             
  Row   2:    ***0***  (axi_arready = '1')_1    (axi_rvalid = '0') && (S_AXI_ARVALID = '1')
  Row   3:    ***0***  (S_AXI_ARVALID = '1')_0  (axi_arready = '1')           
  Row   4:    ***0***  (S_AXI_ARVALID = '1')_1  (axi_rvalid = '0') && (axi_arready = '1')
  Row   5:    ***0***  (axi_rvalid = '0')_0     ((axi_arready = '1') and (S_AXI_ARVALID = '1'))
  Row   6:    ***0***  (axi_rvalid = '0')_1     ((axi_arready = '1') and (S_AXI_ARVALID = '1'))

----------------Focused Condition View-------------------
Line       683 Item    1  ((axi_rvalid = '1') and (S_AXI_RREADY = '1'))
Condition totals: 0 of 2 input terms covered = 0.0%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
    (axi_rvalid = '1')         N  '_1' not hit             Hit '_1'
  (S_AXI_RREADY = '1')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:          1  (axi_rvalid = '1')_0    -                             
  Row   2:    ***0***  (axi_rvalid = '1')_1    (S_AXI_RREADY = '1')          
  Row   3:    ***0***  (S_AXI_RREADY = '1')_0  (axi_rvalid = '1')            
  Row   4:    ***0***  (S_AXI_RREADY = '1')_1  (axi_rvalid = '1')            


Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             7         0         7       0.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/vfpConfig.vhd --

----------------Focused Expression View-----------------
Line       112 Item    1  (((axi_wready and S_AXI_WVALID) and axi_awready) and S_AXI_AWVALID)
Expression totals: 0 of 4 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
     axi_wready         N  No hits                  Hit '_0' and '_1'
   S_AXI_WVALID         N  No hits                  Hit '_0' and '_1'
    axi_awready         N  No hits                  Hit '_0' and '_1'
  S_AXI_AWVALID         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_wready_0          S_AXI_AWVALID && axi_awready && S_AXI_WVALID
  Row   2:    ***0***  axi_wready_1          S_AXI_AWVALID && axi_awready && S_AXI_WVALID
  Row   3:    ***0***  S_AXI_WVALID_0        S_AXI_AWVALID && axi_awready && axi_wready
  Row   4:    ***0***  S_AXI_WVALID_1        S_AXI_AWVALID && axi_awready && axi_wready
  Row   5:    ***0***  axi_awready_0         S_AXI_AWVALID && (axi_wready and S_AXI_WVALID)
  Row   6:    ***0***  axi_awready_1         S_AXI_AWVALID && (axi_wready and S_AXI_WVALID)
  Row   7:    ***0***  S_AXI_AWVALID_0       ((axi_wready and S_AXI_WVALID) and axi_awready)
  Row   8:    ***0***  S_AXI_AWVALID_1       ((axi_wready and S_AXI_WVALID) and axi_awready)

----------------Focused Expression View-----------------
Line       689 Item    1  ((axi_arready and S_AXI_ARVALID) and not(axi_rvalid))
Expression totals: 0 of 3 input terms covered = 0.0%

     Input Term   Covered  Reason for no coverage   Hint
    -----------  --------  -----------------------  --------------
    axi_arready         N  No hits                  Hit '_0' and '_1'
  S_AXI_ARVALID         N  No hits                  Hit '_0' and '_1'
     axi_rvalid         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  axi_arready_0         not axi_rvalid && S_AXI_ARVALID
  Row   2:    ***0***  axi_arready_1         not axi_rvalid && S_AXI_ARVALID
  Row   3:    ***0***  S_AXI_ARVALID_0       not axi_rvalid && axi_arready 
  Row   4:    ***0***  S_AXI_ARVALID_1       not axi_rvalid && axi_arready 
  Row   5:    ***0***  axi_rvalid_0          (axi_arready and S_AXI_ARVALID)
  Row   6:    ***0***  axi_rvalid_1          (axi_arready and S_AXI_ARVALID)


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/dut/vfpMSaxisRGB.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           58        30        28      51.7

================================Statement Details================================

Statement Coverage for file ../modules/dut/vfpMSaxisRGB.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.std_logic_arith.all;
    5                                                use ieee.std_logic_unsigned.all;
    6                                                use work.constantspackage.all;
    7                                                use work.vpfRecords.all;
    8                                                use work.portspackage.all;
    9                                                entity videoProcess_v1_0_rgb_m_axis is 
    10                                               generic (
    11                                                   i_data_width             : integer := 8;
    12                                                   b_data_width             : integer := 32;
    13                                                   s_data_width             : integer := 16);
    14                                               port (
    15                                                   --stream clock/reset
    16                                                   m_axis_mm2s_aclk         : in std_logic;
    17                                                   m_axis_mm2s_aresetn      : in std_logic;
    18                                                   --config
    19                                                   aBusSelect               : in std_logic_vector(b_data_width-1 downto 0);
    20                                                   iStreamData              : in vStreamData;
    21                                                   --stream to master out
    22                                                   rx_axis_tready_o         : in std_logic;
    23                                                   rx_axis_tvalid           : out std_logic;
    24                                                   rx_axis_tuser            : out std_logic;
    25                                                   rx_axis_tlast            : out std_logic;
    26                                                   rx_axis_tdata            : out std_logic_vector(s_data_width-1 downto 0);
    27                                                   --tx channel
    28                                                   rgb_m_axis_tvalid        : out std_logic;
    29                                                   rgb_m_axis_tlast         : out std_logic;
    30                                                   rgb_m_axis_tuser         : out std_logic;
    31                                                   rgb_m_axis_tready        : in std_logic;
    32                                                   rgb_m_axis_tdata         : out std_logic_vector(s_data_width-1 downto 0);
    33                                                   --rx channel
    34                                                   rgb_s_axis_tready        : out std_logic;
    35                                                   rgb_s_axis_tvalid        : in std_logic;
    36                                                   rgb_s_axis_tuser         : in std_logic;
    37                                                   rgb_s_axis_tlast         : in std_logic;
    38                                                   rgb_s_axis_tdata         : in std_logic_vector(s_data_width-1 downto 0));
    39                                               end videoProcess_v1_0_rgb_m_axis;
    40                                               architecture arch_imp of videoProcess_v1_0_rgb_m_axis is
    41                                                   signal configReg4R       : std_logic_vector(b_data_width-1 downto 0):= (others => lo);
    42                                                   signal axis_sof          : std_logic;
    43                                                   signal mpeg42XCR         : std_logic_vector(i_data_width-1 downto 0);
    44                                                   signal mpeg42XBR         : std_logic :=lo;
    45                                                   signal mpeg42XXX         : std_logic :=lo;
    46                                                   signal tx_axis_tvalid    : std_logic;
    47                                                   signal tx_axis_tlast     : std_logic;
    48                                                   signal tx_axis_tuser     : std_logic;
    49                                                   signal tx_axis_tready    : std_logic;
    50                                               	signal pEofs1            : std_logic :=lo;
    51                                                   signal tx_axis_tdata     : std_logic_vector(s_data_width-1 downto 0);
    52                                                   type video_io_state is (VIDEO_SET_RESET,VIDEO_SOF_OFF,VIDEO_SOF_ON,VIDEO_END_OF_LINE);
    53                                                   signal VIDEO_STATES      : video_io_state; 
    54                                               begin
    55                                               process (m_axis_mm2s_aclk) begin
    56                                                   if rising_edge(m_axis_mm2s_aclk) then
    57              1                          2                 mpeg42XBR  <= not(mpeg42XBR) and iStreamData.ycbcr.valid;
    58              1                          2                 mpeg42XXX  <= not(mpeg42XBR);
    59                                                   end if;
    60                                               end process;
    61                                               process (m_axis_mm2s_aclk) begin
    62                                                   if rising_edge(m_axis_mm2s_aclk) then
    63              1                          2                 mpeg42XCR   <= iStreamData.ycbcr.blue;
    64              1                          2                 configReg4R <= aBusSelect;
    65                                                   end if;
    66                                               end process;
    67                                               process (m_axis_mm2s_aclk) begin
    68                                                   if (rising_edge (m_axis_mm2s_aclk)) then
    69                                                       if (m_axis_mm2s_aresetn = lo) then
    70              1                          6                 VIDEO_STATES <= VIDEO_SET_RESET;
    71                                                       else
    72              1                          2             tx_axis_tuser <=axis_sof;
    73                                                       case (VIDEO_STATES) is
    74                                                       when VIDEO_SET_RESET =>
    75              1                          2                 tx_axis_tlast  <= lo;
    76              1                          2                 tx_axis_tvalid <= lo;
    77              1                          2                 tx_axis_tdata  <= (others => lo);    
    78              1                          2                 axis_sof       <= lo;
    79                                                       if (iStreamData.sof = '1') then
    80              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_OFF;
    81                                                       else
    82              1                          2                 VIDEO_STATES <= VIDEO_SET_RESET;
    83                                                       end if;
    84                                                       when VIDEO_SOF_OFF =>
    85                                                       if (iStreamData.ycbcr.valid = hi) then
    86              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_ON;
    87              1                    ***0***                 axis_sof     <= hi;
    88                                                       else
    89              1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_OFF;
    90                                                       end if;
    91                                                       when VIDEO_SOF_ON =>
    92              1                    ***0***                 axis_sof       <= lo;
    93              1                    ***0***     			tx_axis_tvalid <= hi;
    94                                                           if(iStreamData.eof = hi) then
    95              1                    ***0***                     pEofs1 <= hi;
    96                                                           end if;
    97                                                           if (configReg4R = EXTERNAL_AXIS_STREAM)then
    98                                                               if(mpeg42XXX =hi)then
    99              1                    ***0***                         tx_axis_tdata  <= (iStreamData.ycbcr.green & iStreamData.ycbcr.red);
    100                                                              else
    101             1                    ***0***                         tx_axis_tdata  <= (mpeg42XCR & iStreamData.ycbcr.red);
    102                                                              end if;
    103                                                          elsif (configReg4R = STREAM_TESTPATTERN1)then
    104             1                    ***0***                     tx_axis_tdata  <= iStreamData.cord.x;
    105                                                          elsif (configReg4R = STREAM_TESTPATTERN2)then
    106             1                    ***0***                     tx_axis_tdata  <= iStreamData.cord.y;
    107                                                          else
    108                                                              if(mpeg42XXX =hi)then
    109             1                    ***0***                         tx_axis_tdata  <= (iStreamData.ycbcr.green & iStreamData.ycbcr.red);
    110                                                              else
    111             1                    ***0***                         tx_axis_tdata  <= (mpeg42XCR & iStreamData.ycbcr.red);
    112                                                              end if;
    113                                                          end if;
    114                                                      if (iStreamData.ycbcr.valid = hi) then
    115             1                    ***0***                 tx_axis_tlast  <= lo;
    116             1                    ***0***                 VIDEO_STATES <= VIDEO_SOF_ON;
    117                                                      else
    118             1                    ***0***                 tx_axis_tlast  <= hi;
    119             1                    ***0***                 VIDEO_STATES <= VIDEO_END_OF_LINE;
    120                                                      end if;
    121                                                      when VIDEO_END_OF_LINE =>
    122             1                    ***0***                 tx_axis_tlast  <= lo;
    123             1                    ***0***                 tx_axis_tvalid <= lo;
    124                                                          if (pEofs1 = hi) then
    125             1                    ***0***                     VIDEO_STATES <= VIDEO_SOF_OFF;
    126             1                    ***0***     				pEofs1 <= lo;
    127                                                          elsif (iStreamData.ycbcr.valid = hi) then
    128             1                    ***0***                     VIDEO_STATES <= VIDEO_SOF_ON;
    129                                                          else
    130             1                    ***0***                     VIDEO_STATES <= VIDEO_END_OF_LINE;
    131                                                          end if;
    132                                                      when others =>
    133             1                    ***0***                 VIDEO_STATES <= VIDEO_SET_RESET;
    134                                                      end case;
    135                                                      end if;
    136                                                  end if;
    137                                              end process;
    138                                              process (m_axis_mm2s_aclk) begin
    139                                                  if rising_edge(m_axis_mm2s_aclk) then 
    140                                                      if m_axis_mm2s_aresetn = lo then
    141             1                          3                     rx_axis_tvalid     <= lo;
    142             1                          3                     rx_axis_tuser      <= lo;
    143             1                          3                     rx_axis_tlast      <= lo;
    144             1                          3                     rx_axis_tdata      <= (others => lo);
    145             1                          3                     rgb_m_axis_tvalid  <= lo;
    146             1                          3                     rgb_m_axis_tuser   <= lo;
    147             1                          3                     rgb_m_axis_tlast   <= lo;
    148             1                          3                     rgb_m_axis_tdata   <= (others => lo);
    149             1                          3                     tx_axis_tready     <= lo;
    150                                                      else
    151                                                          if (configReg4R = EXTERNAL_AXIS_STREAM)then
    152                                                              --external processed(unused) parallel copy of cpuTX delayed
    153             1                        197                     rgb_s_axis_tready  <= rx_axis_tready_o;
    154             1                        197                     rx_axis_tvalid     <= rgb_s_axis_tvalid;
    155             1                        197                     rx_axis_tuser      <= rgb_s_axis_tuser;
    156             1                        197                     rx_axis_tlast      <= rgb_s_axis_tlast;
    157             1                        197                     rx_axis_tdata      <= rgb_s_axis_tdata;
    158                                                          else
    159                                                              -- to cpuTX
    160             1                    ***0***                     rx_axis_tvalid     <= tx_axis_tvalid;
    161             1                    ***0***                     rx_axis_tuser      <= tx_axis_tuser;
    162             1                    ***0***                     rx_axis_tlast      <= tx_axis_tlast;
    163             1                    ***0***                     rx_axis_tdata      <= tx_axis_tdata;
    164                                                          end if;
    165                                                              --parallel internal copy of cpuTX
    166             1                        197                     tx_axis_tready     <= rgb_m_axis_tready;
    167             1                        197                     rgb_m_axis_tvalid  <= tx_axis_tvalid;
    168             1                        197                     rgb_m_axis_tuser   <= tx_axis_tuser;
    169             1                        197                     rgb_m_axis_tlast   <= tx_axis_tlast;
    170             1                        197                     rgb_m_axis_tdata   <= tx_axis_tdata;
    171                                                      end if;
    172                                                  end if;
    173                                              end process;
    174                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        34        11        23      32.3

================================Branch Details================================

Branch Coverage for file ../modules/dut/vfpMSaxisRGB.vhd --

------------------------------------IF Branch------------------------------------
    56                                         2     Count coming in to IF
    56              1                          2         if rising_edge(m_axis_mm2s_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    62                                         2     Count coming in to IF
    62              1                          2         if rising_edge(m_axis_mm2s_aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    68                                         8     Count coming in to IF
    68              1                          8         if (rising_edge (m_axis_mm2s_aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    69                                         8     Count coming in to IF
    69              1                          6             if (m_axis_mm2s_aresetn = lo) then
    71              1                          2             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    73                                         2     Count coming in to CASE
    74              1                          2             when VIDEO_SET_RESET =>
    84              1                    ***0***             when VIDEO_SOF_OFF =>
    91              1                    ***0***             when VIDEO_SOF_ON =>
    121             1                    ***0***             when VIDEO_END_OF_LINE =>
    132             1                    ***0***             when others =>
Branch totals: 1 hit of 5 branches = 20.0%

------------------------------------IF Branch------------------------------------
    79                                         2     Count coming in to IF
    79              1                    ***0***             if (iStreamData.sof = '1') then
    81              1                          2             else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    85                                   ***0***     Count coming in to IF
    85              1                    ***0***             if (iStreamData.ycbcr.valid = hi) then
    88              1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    94                                   ***0***     Count coming in to IF
    94              1                    ***0***                 if(iStreamData.eof = hi) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    97                                   ***0***     Count coming in to IF
    97              1                    ***0***                 if (configReg4R = EXTERNAL_AXIS_STREAM)then
    103             1                    ***0***                 elsif (configReg4R = STREAM_TESTPATTERN1)then
    105             1                    ***0***                 elsif (configReg4R = STREAM_TESTPATTERN2)then
    107             1                    ***0***                 else
Branch totals: 0 hits of 4 branches = 0.0%

------------------------------------IF Branch------------------------------------
    98                                   ***0***     Count coming in to IF
    98              1                    ***0***                     if(mpeg42XXX =hi)then
    100             1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    108                                  ***0***     Count coming in to IF
    108             1                    ***0***                     if(mpeg42XXX =hi)then
    110             1                    ***0***                     else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    114                                  ***0***     Count coming in to IF
    114             1                    ***0***             if (iStreamData.ycbcr.valid = hi) then
    117             1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    124                                  ***0***     Count coming in to IF
    124             1                    ***0***                 if (pEofs1 = hi) then
    127             1                    ***0***                 elsif (iStreamData.ycbcr.valid = hi) then
    129             1                    ***0***                 else
Branch totals: 0 hits of 3 branches = 0.0%

------------------------------------IF Branch------------------------------------
    139                                      200     Count coming in to IF
    139             1                        200         if rising_edge(m_axis_mm2s_aclk) then 
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    140                                      200     Count coming in to IF
    140             1                          3             if m_axis_mm2s_aresetn = lo then
    150             1                        197             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    151                                      197     Count coming in to IF
    151             1                        197                 if (configReg4R = EXTERNAL_AXIS_STREAM)then
    158             1                    ***0***                 else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         0         2       0.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/vfpMSaxisRGB.vhd --

----------------Focused Expression View-----------------
Line       57 Item    1  (not(mpeg42XBR) and iStreamData.ycbcr.valid)
Expression totals: 0 of 2 input terms covered = 0.0%

               Input Term   Covered  Reason for no coverage   Hint
              -----------  --------  -----------------------  --------------
                mpeg42XBR         N  No hits                  Hit '_0' and '_1'
  iStreamData.ycbcr.valid         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                 Non-masking condition(s)      
 ---------  ---------  --------------------       -------------------------     
  Row   1:    ***0***  mpeg42XBR_0                iStreamData.ycbcr.valid       
  Row   2:    ***0***  mpeg42XBR_1                iStreamData.ycbcr.valid       
  Row   3:    ***0***  iStreamData.ycbcr.valid_0  not mpeg42XBR                 
  Row   4:    ***0***  iStreamData.ycbcr.valid_1  not mpeg42XBR                 


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                        12.5
        States                       4         1         3      25.0
        Transitions                  8         0         8       0.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/vfpMSaxisRGB.vhd --

FSM_ID: VIDEO_STATES
    Current State Object : VIDEO_STATES
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  74     VIDEO_SET_RESET                   0
  84       VIDEO_SOF_OFF                   1
  91        VIDEO_SOF_ON                   2
 121   VIDEO_END_OF_LINE                   3
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
         VIDEO_SET_RESET                   8
    Uncovered States :
    ------------------
                   State
                   -----
           VIDEO_SOF_OFF
            VIDEO_SOF_ON
       VIDEO_END_OF_LINE
    Uncovered Transitions :
    -----------------------
Line            Trans_ID          Transition          
----            --------          ----------          
  80                   0          VIDEO_SET_RESET -> VIDEO_SOF_OFF
  86                   1          VIDEO_SOF_OFF -> VIDEO_SOF_ON
  70                   2          VIDEO_SOF_OFF -> VIDEO_SET_RESET
 119                   3          VIDEO_SOF_ON -> VIDEO_END_OF_LINE
  70                   4          VIDEO_SOF_ON -> VIDEO_SET_RESET
 125                   5          VIDEO_END_OF_LINE -> VIDEO_SOF_OFF
 128                   6          VIDEO_END_OF_LINE -> VIDEO_SOF_ON
  70                   7          VIDEO_END_OF_LINE -> VIDEO_SET_RESET


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       4         1         3      25.0
        Transitions                  8         0         8       0.0

=================================================================================
=== File: ../modules/dut/vfpMaxisMM2s.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           29        25         4      86.2

================================Statement Details================================

Statement Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

    1                                                --05012019 [05-01-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                entity videoProcess_v1_0_m_axis_mm2s is
    8                                                generic (
    9                                                    s_data_width	                : integer := 16);
    10                                               port (
    11                                                   aclk                            : in std_logic;
    12                                                   aresetn                         : in std_logic;
    13                                                   rgb_s_axis_tready               : out std_logic;
    14                                                   rgb_s_axis_tvalid               : in std_logic;
    15                                                   rgb_s_axis_tuser                : in std_logic;
    16                                                   rgb_s_axis_tlast                : in std_logic;
    17                                                   rgb_s_axis_tdata                : in std_logic_vector(s_data_width-1  downto 0);
    18                                                   m_axis_mm2s_tkeep               : out std_logic_vector(2 downto 0);
    19                                                   m_axis_mm2s_tstrb               : out std_logic_vector(2 downto 0);
    20                                                   m_axis_mm2s_tid                 : out std_logic_vector(0 downto 0);
    21                                                   m_axis_mm2s_tdest               : out std_logic_vector(0 downto 0);  
    22                                                   m_axis_mm2s_tready              : in std_logic;
    23                                                   m_axis_mm2s_tvalid              : out std_logic;
    24                                                   m_axis_mm2s_tuser               : out std_logic;
    25                                                   m_axis_mm2s_tlast               : out std_logic;
    26                                                   m_axis_mm2s_tdata               : out std_logic_vector(s_data_width-1 downto 0));
    27                                               end videoProcess_v1_0_m_axis_mm2s;
    28                                               architecture arch_imp of videoProcess_v1_0_m_axis_mm2s is
    29                                                   type pixel_locations is (video_trans_in_progress,wait_to_go);
    30                                                   signal pixel_locations_address  : pixel_locations; 
    31                                                   signal axis_tvalid              : std_logic:= lo;
    32                                                   signal axis_tuser               : std_logic:= lo;
    33                                                   signal axis_tlast               : std_logic:= lo;
    34                                                   signal axis_tdata               : std_logic_vector(s_data_width-1 downto 0):= (others => lo); 
    35                                                   signal maxis_mm2s_tdata         : std_logic_vector(s_data_width-1 downto 0):= (others => lo);
    36                                                   signal maxis_mm2s_tuser         : std_logic:= lo;
    37                                                   signal maxis_mm2s_tvalid        : std_logic:= lo;
    38                                                   signal maxis_mmss_tvalid        : std_logic:= lo;
    39                                                   signal mm2s_tready              : std_logic:= lo;
    40                                               begin
    41                                               process(aclk) begin
    42                                                   if rising_edge(aclk) then
    43              1                       2262             axis_tvalid <= rgb_s_axis_tvalid;
    44              1                       2262             mm2s_tready <= m_axis_mm2s_tready;
    45              1                       2262             axis_tuser  <= rgb_s_axis_tuser;
    46              1                       2262             axis_tdata  <= rgb_s_axis_tdata(15 downto 8) & rgb_s_axis_tdata(7 downto 0);
    47                                                   end if;
    48                                               end process;
    49                                               process (aclk) begin
    50                                                   if (rising_edge (aclk)) then
    51                                                       if (aresetn = lo) then
    52              1                          5                 pixel_locations_address <= wait_to_go;
    53              1                          5                 rgb_s_axis_tready       <=lo;
    54                                                       else
    55                                                       case (pixel_locations_address) is
    56                                                       when wait_to_go =>
    57              1                          6                 axis_tlast         <=lo;
    58              1                          6                 rgb_s_axis_tready  <=hi;--initiate
    59              1                          6                 maxis_mm2s_tvalid  <=lo;
    60                                                           if (rgb_s_axis_tvalid  = hi)then-- initiate response
    61              1                          2                     pixel_locations_address <= video_trans_in_progress;            
    62                                                           else
    63              1                          4                     pixel_locations_address <= wait_to_go;    
    64                                                           end if;        
    65                                                       when video_trans_in_progress =>
    66              1                        567                 maxis_mm2s_tuser   <= axis_tuser;
    67              1                        567                 maxis_mm2s_tdata   <= axis_tdata;
    68                                                           if (rgb_s_axis_tlast = hi)then
    69              1                    ***0***                     axis_tlast <=hi;
    70              1                    ***0***                     maxis_mm2s_tvalid  <=lo;
    71              1                    ***0***                     pixel_locations_address <= wait_to_go;
    72                                                           else
    73              1                        567                     axis_tlast <=lo;
    74              1                        567                     maxis_mm2s_tvalid  <=hi;
    75              1                        567                     pixel_locations_address <= video_trans_in_progress;
    76                                                           end if;
    77                                                       when others =>
    78              1                    ***0***                 pixel_locations_address <= wait_to_go;
    79                                                       end case;
    80                                                       end if;
    81                                                   end if;
    82                                               end process;
    83                                               process(aclk) begin
    84                                                   if rising_edge(aclk) then
    85              1                        388             m_axis_mm2s_tkeep      <= (others => hi);
    86              1                        388             m_axis_mm2s_tid        <= "0";
    87              1                        388             m_axis_mm2s_tdest      <= "0";
    88              1                        388             m_axis_mm2s_tstrb      <= (others => hi);
    89              1                        388             m_axis_mm2s_tdata      <= maxis_mm2s_tdata;
    90              1                        388             m_axis_mm2s_tlast      <= axis_tlast;
    91              1                        388             m_axis_mm2s_tuser      <= maxis_mm2s_tuser;
    92              1                        388             m_axis_mm2s_tvalid     <= maxis_mm2s_tvalid or maxis_mmss_tvalid;
    93                                                   end if;
    94                                               end process;
    95                                               process(aclk) begin
    96                                                   if rising_edge(aclk) then
    97              1                       2262             maxis_mmss_tvalid  <= maxis_mm2s_tvalid;
    98                                                   end if;
    99                                               end process;    
    100                                              end arch_imp;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        13        11         2      84.6

================================Branch Details================================

Branch Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

------------------------------------IF Branch------------------------------------
    42                                      2262     Count coming in to IF
    42              1                       2262         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    50                                       578     Count coming in to IF
    50              1                        578         if (rising_edge (aclk)) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    51                                       578     Count coming in to IF
    51              1                          5             if (aresetn = lo) then
    54              1                        573             else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------CASE Branch------------------------------------
    55                                       573     Count coming in to CASE
    56              1                          6             when wait_to_go =>
    65              1                        567             when video_trans_in_progress =>
    77              1                    ***0***             when others =>
Branch totals: 2 hits of 3 branches = 66.6%

------------------------------------IF Branch------------------------------------
    60                                         6     Count coming in to IF
    60              1                          2                 if (rgb_s_axis_tvalid  = hi)then-- initiate response
    62              1                          4                 else
Branch totals: 2 hits of 2 branches = 100.0%

------------------------------------IF Branch------------------------------------
    68                                       567     Count coming in to IF
    68              1                    ***0***                 if (rgb_s_axis_tlast = hi)then
    72              1                        567                 else
Branch totals: 1 hit of 2 branches = 50.0%

------------------------------------IF Branch------------------------------------
    84                                       388     Count coming in to IF
    84              1                        388         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    96                                      2262     Count coming in to IF
    96              1                       2262         if rising_edge(aclk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             2         1         1      50.0

================================Expression Details================================

Expression Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

----------------Focused Expression View-----------------
Line       92 Item    1  (maxis_mm2s_tvalid or maxis_mmss_tvalid)
Expression totals: 1 of 2 input terms covered = 50.0%

         Input Term   Covered  Reason for no coverage   Hint
        -----------  --------  -----------------------  --------------
  maxis_mm2s_tvalid         Y
  maxis_mmss_tvalid         N  '_1' not hit             Hit '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:          2  maxis_mm2s_tvalid_0   not maxis_mmss_tvalid         
  Row   2:          2  maxis_mm2s_tvalid_1   not maxis_mmss_tvalid         
  Row   3:          2  maxis_mmss_tvalid_0   not maxis_mm2s_tvalid         
  Row   4:    ***0***  maxis_mmss_tvalid_1   not maxis_mm2s_tvalid         


FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

================================FSM Details================================

FSM Coverage for file ../modules/dut/vfpMaxisMM2s.vhd --

FSM_ID: pixel_locations_address
    Current State Object : pixel_locations_address
    ----------------------
    State Value MapInfo :
    ---------------------
Line          State Name               Value
----          ----------               -----
  56          wait_to_go                   1
  65video_trans_in_progress                   0
    Covered States :
    ----------------
                   State           Hit_count
                   -----           ---------
              wait_to_go                   9
    video_trans_in_progress                 569
    Covered Transitions :
    ---------------------
Line            Trans_ID           Hit_count          Transition          
----            --------           ---------          ----------          
  61                   0                   2          wait_to_go -> video_trans_in_progress
  71                   1                   2          video_trans_in_progress -> wait_to_go


    Summary                     Active      Hits    Misses % Covered
    -------                     ------      ----    ------ ---------
        States                       2         2         0     100.0
        Transitions                  2         2         0     100.0

=================================================================================
=== File: ../modules/dut/videoSelect.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           61         7        54      11.4

================================Statement Details================================

Statement Coverage for file ../modules/dut/videoSelect.vhd --

    1                                                --02092019 [02-17-2019]
    2                                                library ieee;
    3                                                use ieee.std_logic_1164.all;
    4                                                use ieee.numeric_std.all;
    5                                                use work.constantspackage.all;
    6                                                use work.vpfRecords.all;
    7                                                use work.portspackage.all;
    8                                                entity videoSelect is
    9                                                generic (
    10                                                   i_data_width           : integer := 8;
    11                                                   b_data_width           : integer := 32;
    12                                                   s_data_width           : integer := 16);
    13                                               port (
    14                                                   clk               : in std_logic;
    15                                                   rst_l             : in std_logic;
    16                                                   videoChannel      : in std_logic_vector(b_data_width-1 downto 0);
    17                                                   dChannel          : in std_logic_vector(b_data_width-1 downto 0);
    18                                                   cChannel          : in std_logic_vector(b_data_width-1 downto 0);
    19                                                   cRgbOsharp        : in std_logic_vector(b_data_width-1 downto 0);
    20                                                   iFrameData        : in fcolors;
    21                                                   oEof              : out std_logic;
    22                                                   oSof              : out std_logic;
    23                                                   oCord             : out coord;
    24                                                   oRgb              : out channel);
    25                                               end videoSelect;
    26                                               architecture Behavioral of videoSelect is
    27                                                   signal vChannelSelect     : integer;
    28                                                   signal eChannelSelect     : integer;
    29                                                   signal ycbcr              : channel;
    30                                                   signal channels           : channel;
    31                                               begin
    32              1                          2     vChannelSelect    <= to_integer(unsigned(videoChannel));
    33              1                          2     eChannelSelect    <= to_integer(unsigned(dChannel));
    34              1                          2     oEof              <= iFrameData.pEof;
    35              1                          2     oSof              <= iFrameData.pSof;
    36                                               ---------------------------------------------------------------------------------
    37                                               -- oRgb.valid must be 2nd condition else valid value
    38                                               ---------------------------------------------------------------------------------
    39                                               videoOutP: process (clk) begin
    40                                                   if rising_edge(clk) then
    41                                                       if (vChannelSelect = soble) then
    42              1                          5                 channels     <= iFrameData.soble;
    43                                                       elsif(vChannelSelect = sobRgb)then
    44              1                    ***0***                     channels.valid <= iFrameData.rgbDetect.valid;
    45                                                           if (iFrameData.rgbDetectLock = hi) then 
    46              1                    ***0***                     channels.red   <= iFrameData.soble.red;
    47              1                    ***0***                     channels.green <= iFrameData.soble.green;
    48              1                    ***0***                     channels.blue  <= iFrameData.soble.blue;
    49                                                           else                   
    50              1                    ***0***                     channels.red   <= iFrameData.rgbDetect.red;
    51              1                    ***0***                     channels.green <= iFrameData.rgbDetect.green;
    52              1                    ***0***                     channels.blue  <= iFrameData.rgbDetect.blue;
    53                                                           end if;
    54                                                       elsif(vChannelSelect = sobPoi)then
    55              1                    ***0***                     channels.valid <= iFrameData.rgbPoi.valid;
    56                                                           if (iFrameData.rgbPoiLock = hi) then 
    57              1                    ***0***                     channels.red   <= iFrameData.soble.red;
    58              1                    ***0***                     channels.green <= iFrameData.soble.green;
    59              1                    ***0***                     channels.blue  <= iFrameData.soble.blue;
    60                                                           else                   
    61              1                    ***0***                     channels.red   <= iFrameData.rgbPoi.red;
    62              1                    ***0***                     channels.green <= iFrameData.rgbPoi.green;
    63              1                    ***0***                     channels.blue  <= iFrameData.rgbPoi.blue;
    64                                                           end if;
    65                                                       elsif(vChannelSelect = hsvPoi)then
    66              1                    ***0***                     channels.valid <= iFrameData.rgbPoi.valid;
    67                                                           if (iFrameData.rgbPoiLock = hi) then 
    68              1                    ***0***                     channels.red   <= iFrameData.hsv.red;
    69              1                    ***0***                     channels.green <= iFrameData.hsv.green;
    70              1                    ***0***                     channels.blue  <= iFrameData.hsv.blue;
    71                                                           else                   
    72              1                    ***0***                     channels.red   <= iFrameData.rgbPoi.red;
    73              1                    ***0***                     channels.green <= iFrameData.rgbPoi.green;
    74              1                    ***0***                     channels.blue  <= iFrameData.rgbPoi.blue;
    75                                                           end if;
    76                                                       elsif(vChannelSelect = sharp)then
    77              1                    ***0***                 channels    <= iFrameData.sharp;
    78                                                       elsif(vChannelSelect = blur1x)then
    79              1                    ***0***                 channels     <= iFrameData.blur1x;
    80                                                       elsif(vChannelSelect = blur2x)then
    81              1                    ***0***                 channels     <= iFrameData.blur2x;
    82                                                       elsif(vChannelSelect = blur3x)then
    83              1                    ***0***                 channels     <= iFrameData.blur3x;
    84                                                       elsif(vChannelSelect = blur4x)then
    85              1                    ***0***                 channels     <= iFrameData.blur4x;
    86                                                       elsif(vChannelSelect = hsv)then
    87              1                    ***0***                 channels      <= iFrameData.hsv;
    88                                                       elsif(vChannelSelect = rgb)then
    89              1                    ***0***                 channels     <= iFrameData.rgb;
    90                                                       elsif(vChannelSelect = rgbRemix)then
    91              1                    ***0***                 channels     <= iFrameData.rgbRemix;
    92                                                       elsif(vChannelSelect = tPatter1)then
    93              1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    94              1                    ***0***                 channels.red       <= iFrameData.rgbSum.red(i_data_width-1 downto 0);
    95              1                    ***0***                 channels.green     <= iFrameData.rgbSum.green(i_data_width-1 downto 0);
    96              1                    ***0***                 channels.blue      <= iFrameData.rgbSum.blue(i_data_width-1 downto 0);
    97                                                       elsif(vChannelSelect = tPatter2)then
    98              1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    99              1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    100             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    101             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    102                                                      elsif(vChannelSelect = tPatter3)then
    103             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    104             1                    ***0***                 channels.red       <= iFrameData.rgbSum.red(i_data_width-1 downto 0);
    105             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    106             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    107                                                      elsif(vChannelSelect = tPatter4)then
    108             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    109             1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    110             1                    ***0***                 channels.green     <= iFrameData.rgbSum.green(i_data_width-1 downto 0);
    111             1                    ***0***                 channels.blue      <= x"0" & iFrameData.rgbSum.blue(11 downto 8);
    112                                                      elsif(vChannelSelect = tPatter5)then
    113             1                    ***0***                 channels.valid     <= iFrameData.rgbSum.valid;
    114             1                    ***0***                 channels.red       <= x"0" & iFrameData.rgbSum.red(3 downto 0);
    115             1                    ***0***                 channels.green     <= x"0" & iFrameData.rgbSum.green(7 downto 4);
    116             1                    ***0***                 channels.blue      <= iFrameData.rgbSum.blue(i_data_width-1 downto 0);
    117                                                      elsif(vChannelSelect = rgbCorrect)then
    118             1                    ***0***                 channels           <= iFrameData.rgbCorrect;
    119                                                      elsif(vChannelSelect = hsl)then
    120             1                    ***0***                 channels           <= iFrameData.hsl;
    121                                                      elsif(vChannelSelect = hsvCcBl)then
    122             1                    ***0***                 channels           <= iFrameData.hsvCcBl;
    123                                                      else
    124             1                    ***0***                 channels           <= iFrameData.rgbCorrect;
    125                                                      end if;
    126                                                  end if;
    127                                              end process videoOutP;
    128                                              ycbcrInst: rgb_ycbcr
    129                                              generic map(
    130                                                  i_data_width         => i_data_width,
    131                                                  i_precision          => i_precision,
    132                                                  i_full_range         => FALSE)
    133                                              port map(
    134                                                  clk                  => clk,
    135                                                  rst_l                => rst_l,
    136                                                  iRgb                 => channels,
    137                                                  y                    => ycbcr.red,
    138                                                  cb                   => ycbcr.green,
    139                                                  cr                   => ycbcr.blue,
    140                                                  oValid               => ycbcr.valid);
    141                                              channelOutP: process (clk) begin
    142                                                  if rising_edge(clk) then
    143             1                          2             oCord <= iFrameData.cod;
    144                                                      if (eChannelSelect = 0) then
    145             1                          2                 oRgb     <= ycbcr;
    146                                                      else
    147             1                    ***0***                 oRgb     <= channels;
    148                                                      end if;
    149                                                  end if;
    150                                              end process channelOutP;
    151                                              end Behavioral;

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        31         4        27      12.9

================================Branch Details================================

Branch Coverage for file ../modules/dut/videoSelect.vhd --

------------------------------------IF Branch------------------------------------
    40                                         5     Count coming in to IF
    40              1                          5         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    41                                         5     Count coming in to IF
    41              1                          5             if (vChannelSelect = soble) then
    43              1                    ***0***             elsif(vChannelSelect = sobRgb)then
    54              1                    ***0***             elsif(vChannelSelect = sobPoi)then
    65              1                    ***0***             elsif(vChannelSelect = hsvPoi)then
    76              1                    ***0***             elsif(vChannelSelect = sharp)then
    78              1                    ***0***             elsif(vChannelSelect = blur1x)then
    80              1                    ***0***             elsif(vChannelSelect = blur2x)then
    82              1                    ***0***             elsif(vChannelSelect = blur3x)then
    84              1                    ***0***             elsif(vChannelSelect = blur4x)then
    86              1                    ***0***             elsif(vChannelSelect = hsv)then
    88              1                    ***0***             elsif(vChannelSelect = rgb)then
    90              1                    ***0***             elsif(vChannelSelect = rgbRemix)then
    92              1                    ***0***             elsif(vChannelSelect = tPatter1)then
    97              1                    ***0***             elsif(vChannelSelect = tPatter2)then
    102             1                    ***0***             elsif(vChannelSelect = tPatter3)then
    107             1                    ***0***             elsif(vChannelSelect = tPatter4)then
    112             1                    ***0***             elsif(vChannelSelect = tPatter5)then
    117             1                    ***0***             elsif(vChannelSelect = rgbCorrect)then
    119             1                    ***0***             elsif(vChannelSelect = hsl)then
    121             1                    ***0***             elsif(vChannelSelect = hsvCcBl)then
    123             1                    ***0***             else
Branch totals: 1 hit of 21 branches = 4.7%

------------------------------------IF Branch------------------------------------
    45                                   ***0***     Count coming in to IF
    45              1                    ***0***                 if (iFrameData.rgbDetectLock = hi) then 
    49              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    56                                   ***0***     Count coming in to IF
    56              1                    ***0***                 if (iFrameData.rgbPoiLock = hi) then 
    60              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    67                                   ***0***     Count coming in to IF
    67              1                    ***0***                 if (iFrameData.rgbPoiLock = hi) then 
    71              1                    ***0***                 else                   
Branch totals: 0 hits of 2 branches = 0.0%

------------------------------------IF Branch------------------------------------
    142                                        2     Count coming in to IF
    142             1                          2         if rising_edge(clk) then
                                            ECOP     All False Count
Branch totals: 1 hit of 1 branch = 100.0%

------------------------------------IF Branch------------------------------------
    144                                        2     Count coming in to IF
    144             1                          2             if (eChannelSelect = 0) then
    146             1                    ***0***             else
Branch totals: 1 hit of 2 branches = 50.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

=================================================================================
=== File: ../modules/top.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           34        34         0     100.0

================================Statement Details================================

Statement Coverage for file ../modules/top.sv --

    1                                                `include "uvm_macros.svh"
    2                                                package socTest_pkg;
    3                                                import uvm_pkg::*;
    4                                                //====================================================================================
    5                                                //------------------------------------------------------------------------------------
    6                                                //--------------------------------- DEFINES
    7                                                //------------------------------------------------------------------------------------
    8                                                //====================================================================================
    9                                                typedef struct packed {
    10                                                  byte unsigned addr_width;
    11                                                  byte unsigned data_width;
    12                                               } width_confg1_t;
    13                                               typedef struct packed {
    14                                                  int unsigned payload_length;
    15                                               } width_confg2_t;
    16                                               typedef struct packed {
    17                                                  width_confg1_t w_p1;
    18                                                  width_confg2_t w_p2;
    19                                               } set_config;
    20                                               typedef enum { READ, WRITE } axiLite_txn_e;
    21                                               parameter set_config par_1 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 2 } };
    22                                               parameter set_config par_2 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 4 } };
    23                                               parameter set_config par_3 = '{ '{ addr_width: 11, data_width: 8 }, '{ payload_length: 3 } };
    24                                               typedef enum bit [5:0] {
    25                                               	AX_FLOW_TYPE				= 6'h00,
    26                                               	AX_WRITE_TYPE				= 6'h08,
    27                                               	AX_MISC_WRITE_TYPE			= 6'h10,
    28                                               	AX_POSTED_WRITE_TYPE		= 6'h18,
    29                                               	AX_POSTED_MISC_WRITE_TYPE	= 6'h20,
    30                                               	AX_MODE_READ_TYPE			= 6'h28,
    31                                               	AX_READ_TYPE				= 6'h30,
    32                                               	AX_RESPONSE_TYPE			= 6'h38
    33                                               } ax_command_type;
    34                                               typedef enum bit [5:0] {
    35                                                   AX_NULL                = 6'h00,
    36                                                   AX_PRET                = 6'h01,
    37                                                   AX_TRET                = 6'h02,
    38                                                   AX_IRTRY                = 6'h03,
    39                                                   AX_WRITE_16            = 6'h08,
    40                                                   AX_WRITE_32            = 6'h09,
    41                                                   AX_WRITE_48            = 6'h0a,
    42                                                   AX_WRITE_64            = 6'h0b,
    43                                                   AX_WRITE_80            = 6'h0c,
    44                                                   AX_WRITE_96            = 6'h0d,
    45                                                   AX_WRITE_112            = 6'h0e,
    46                                                   AX_WRITE_128            = 6'h0f,
    47                                                   //-- misc write
    48                                                   AX_MODE_WRITE            = 6'h10,
    49                                                   AX_BIT_WRITE            = 6'h11,
    50                                                   AX_DUAL_8B_ADDI        = 6'h12,
    51                                                   AX_SINGLE_16B_ADDI        = 6'h13,
    52                                                   AX_POSTED_WRITE_16        = 6'h18,
    53                                                   AX_POSTED_WRITE_32        = 6'h19,
    54                                                   AX_POSTED_WRITE_48        = 6'h1a,
    55                                                   AX_POSTED_WRITE_64        = 6'h1b,
    56                                                   AX_POSTED_WRITE_80        = 6'h1c,
    57                                                   AX_POSTED_WRITE_96        = 6'h1d,
    58                                                   AX_POSTED_WRITE_112    = 6'h1e,
    59                                                   AX_POSTED_WRITE_128    = 6'h1f,
    60                                                   AX_POSTED_BIT_WRIT            = 6'h21,
    61                                                   AX_POSTED_DUAL_8B_ADDI        = 6'h22,
    62                                                   AX_POSTED_SINGLE_16B_ADDI    = 6'h23,
    63                                                   AX_MODE_READ            = 6'h28,
    64                                                   AX_READ_16                = 6'h30,
    65                                                   AX_READ_32                = 6'h31,
    66                                                   AX_READ_48                = 6'h32,
    67                                                   AX_READ_64                = 6'h33,
    68                                                   AX_READ_80                = 6'h34,
    69                                                   AX_READ_96                = 6'h35,
    70                                                   AX_READ_112            = 6'h36,
    71                                                   AX_READ_128            = 6'h37,
    72                                                   AX_READ_RESPONSE        = 6'h38,
    73                                                   AX_WRITE_RESPONSE        = 6'h39,
    74                                                   AX_MODE_READ_RESPONSE    = 6'h3A,
    75                                                   AX_MODE_WRITE_RESPONSE    = 6'h3B,
    76                                                   AX_ERROR_RESPONSE        = 6'h3E
    77                                               } ax_command_encoding;
    78                                               `define AX_TYPE_MASK 6'h38
    79                                               //====================================================================================
    80                                               //------------------------------------------------------------------------------------
    81                                               //--------------------------------- UVM_CONFIGURATIONS
    82                                               //------------------------------------------------------------------------------------
    83                                               //====================================================================================
    84                                               // UVM_OBJECT : TEMPLATE_CONFIGURATION [TEMPLATE]
    85                                               class template_configuration extends uvm_object;
    86                                                   `uvm_object_utils(template_configuration)
    87                                                   function new(string name = "");
    88                                                       super.new(name);
    89                                                   endfunction: new
    90                                               endclass: template_configuration
    91                                               // UVM_OBJECT : AXILITE_CONFIGURATION [AXI4_LITE]
    92                                               class axiLite_configuration extends uvm_object;
    93                                                   `uvm_object_utils(axiLite_configuration)
    94                                                   function new(string name = "");
    95                                                       super.new(name);
    96                                                   endfunction: new
    97                                               endclass: axiLite_configuration
    98                                               // UVM_OBJECT : RGB_CONFIGURATION [RGB]
    99                                               class rgb_configuration extends uvm_object;
    100                                                  `uvm_object_utils(rgb_configuration)
    101                                                  function new(string name = "");
    102                                                      super.new(name);
    103                                                  endfunction: new
    104                                                  rand int count;
    105                                                  constraint c_count    { count > 0; count < 128; }
    106                                              endclass: rgb_configuration
    107                                              // UVM_OBJECT : AXI4_STREAM_CONFIG [AXI4_STREAM]
    108                                              class axi4_stream_config extends uvm_object;
    109                                              	uvm_active_passive_enum master_active = UVM_ACTIVE;
    110                                              	uvm_active_passive_enum slave_active  = UVM_ACTIVE;
    111                                              	uvm_active_passive_enum open_rsp_mode = UVM_ACTIVE;
    112                                                  virtual axi4s_if axi4s_vif;
    113                                              	`uvm_object_utils_begin(axi4_stream_config)
    114                                              		`uvm_field_enum(uvm_active_passive_enum, master_active, UVM_DEFAULT)
    115                                              		`uvm_field_enum(uvm_active_passive_enum, slave_active,  UVM_DEFAULT)
    116                                              		`uvm_field_enum(uvm_active_passive_enum, open_rsp_mode,  UVM_DEFAULT)
    117                                              	`uvm_object_utils_end
    118                                                  function new(string name = "");
    119                                                      super.new(name);
    120                                                  endfunction: new
    121                                              	virtual function void do_print (uvm_printer printer);
    122                                              		super.do_print(printer);
    123                                              	endfunction : do_print
    124                                              endclass: axi4_stream_config
    125                                              // UVM_OBJECT : AXI4_STREAM_AGENTS_CONFIG [AXI4_STREAM]
    126                                              class axi4_stream_agents_config extends uvm_object;
    127                                                  `uvm_object_utils(axi4_stream_agents_config)
    128                                                  bit has_axi4_agent1 = 1; //switch to instantiate an agent #1
    129                                                  bit has_axi4_agent2 = 1; //switch to instantiate an agent #2
    130                                                  axi4_stream_config axi4_agent_handler1;
    131                                                  axi4_stream_config axi4_agent_handler2;
    132                                                  function new(string name = "");
    133                                                      super.new(name);
    134                                                  endfunction: new
    135                                              endclass: axi4_stream_agents_config
    136                                              //====================================================================================
    137                                              //------------------------------------------------------------------------------------
    138                                              //--------------------------------- UVM_SEQUENCE_ITEMES
    139                                              //------------------------------------------------------------------------------------
    140                                              //====================================================================================
    141                                              // UVM_SEQUENCE_ITEM : RGB_TRANSACTION [RGB]
    142                                              class rgb_transaction#(parameter set_config cfg = par_1) extends uvm_sequence_item;
    143                                                  rand bit[cfg.w_p1.data_width-1:0]       iRed;
    144                                                  rand bit[cfg.w_p1.data_width-1:0]       iGreen;
    145                                                  rand bit[cfg.w_p1.data_width-1:0]       iBlue;
    146                                                  rand bit            iPixelEn;
    147                                                  rand bit            iValid;
    148                                                  rand bit            iEof;
    149                                                  rand bit [cfg.w_p1.addr_width-1:0]      iX;
    150                                                  rand bit [cfg.w_p1.addr_width-1:0]      iY;
    151                                                  function new(string name = "");
    152                                                      super.new(name);
    153                                                  endfunction: new
    154                                                  `uvm_object_utils_begin(rgb_transaction#(cfg))
    155                                                      `uvm_field_int(iRed,         UVM_ALL_ON)
    156                                                      `uvm_field_int(iGreen,       UVM_ALL_ON)
    157                                                      `uvm_field_int(iBlue,        UVM_ALL_ON)
    158                                                      `uvm_field_int(iPixelEn,     UVM_ALL_ON)
    159                                                      `uvm_field_int(iEof,         UVM_ALL_ON)
    160                                                      `uvm_field_int(iValid,       UVM_ALL_ON)
    161                                                      `uvm_field_int(iX,           UVM_ALL_ON)
    162                                                      `uvm_field_int(iY,           UVM_ALL_ON)
    163                                                  `uvm_object_utils_end
    164                                              endclass: rgb_transaction
    165                                              // UVM_SEQUENCE_ITEM : AXILITE_TXN [AXI4_LITE]
    166                                              class axiLite_transaction extends uvm_sequence_item;
    167                                                  rand bit [15:0]     addr;
    168                                                  rand bit [31:0]     data;
    169                                                  rand bit [31:0]     WDATA;
    170                                                  rand bit [31:0]     RDATA;
    171                                                  rand axiLite_txn_e  reqWriteRead;
    172                                                  rand int unsigned   cycles;
    173                                                  constraint c_cycles { 
    174                                                  cycles <= 20; }
    175                                                  function new (string name = "");
    176                                                      super.new(name);
    177                                                  endfunction
    178                                                  function string convert2string();
    179                                                      return $sformatf("addr='h%h, data='h%0h, cycles='d%0d",addr, data, cycles);
    180                                                  endfunction
    181                                                  `uvm_object_utils_begin(axiLite_transaction)
    182                                                      `uvm_field_int  (addr,                          UVM_DEFAULT)
    183                                                      `uvm_field_int  (data,                          UVM_DEFAULT)
    184                                                      `uvm_field_int  (WDATA,                         UVM_DEFAULT)
    185                                                      `uvm_field_int  (RDATA,                         UVM_DEFAULT)
    186                                                      `uvm_field_enum (axiLite_txn_e, reqWriteRead,   UVM_DEFAULT)    
    187                                                      `uvm_field_int  (cycles,                        UVM_DEFAULT)
    188                                                  `uvm_object_utils_end
    189                                              endclass: axiLite_transaction
    190                                              // UVM_SEQUENCE_ITEM : TEMPLATE_TRANSACTION [TEMPLATE]
    191                                              class tp_transaction extends uvm_sequence_item;
    192                                                  rand bit[1:0] ina;
    193                                                  rand bit[1:0] inb;
    194                                                  bit[2:0]      outValTbs;
    195                                                  bit[2:0]      outValDut;
    196                                                  function new(string name = "");
    197                                                      super.new(name);
    198                                                  endfunction: new
    199                                                  `uvm_object_utils_begin(tp_transaction)
    200                                                      `uvm_field_int(ina, UVM_ALL_ON)
    201                                                      `uvm_field_int(inb, UVM_ALL_ON)
    202                                                      `uvm_field_int(outValTbs, UVM_ALL_ON)
    203                                                      `uvm_field_int(outValDut, UVM_ALL_ON)
    204                                                  `uvm_object_utils_end
    205                                              endclass: tp_transaction
    206                                              // UVM_SEQUENCE_ITEM : AXI4_STREAM_VALID_CYCLE [AXI4_STREAM]
    207                                              class axi4_stream_valid_cycle  extends uvm_sequence_item;
    208                                                  rand bit [15:0]    tdata;
    209                                                  rand bit               tuser;
    210                                                  rand int unsigned      delay = 0;
    211                                                  constraint c_packet_delay {
    212                                                      delay < 20 ;
    213                                                  }
    214                                                  function new(string name = "");
    215                                                      super.new(name);
    216                                                  endfunction: new
    217                                                  `uvm_object_utils_begin(axi4_stream_valid_cycle)
    218                                                      `uvm_field_int(tdata, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    219                                                      `uvm_field_int(tuser, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    220                                                      `uvm_field_int(delay, UVM_DEFAULT | UVM_DEC| UVM_NOPACK)
    221                                                  `uvm_object_utils_end
    222                                              endclass: axi4_stream_valid_cycle
    223                                              //====================================================================================
    224                                              //------------------------------------------------------------------------------------
    225                                              //--------------------------------- UVM_SEQUENCERS
    226                                              //------------------------------------------------------------------------------------
    227                                              //====================================================================================
    228                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCER [TEMPLATE]
    229                                              class template_sequencer extends uvm_sequencer #(tp_transaction);
    230                                                  `uvm_component_utils(template_sequencer)
    231                                                  function new(string name, uvm_component parent);
    232                                                      super.new(name, parent);
    233                                                  endfunction
    234                                              endclass: template_sequencer
    235                                              // UVM_SEQUENCE : AXILITE_SEQUENCER [AXI4_LITE]
    236                                              class axiLite_sequencer extends uvm_sequencer #(axiLite_transaction);
    237                                                  int id;
    238                                                  `uvm_component_utils_begin(axiLite_sequencer)
    239                                                      `uvm_field_int(id, UVM_DEFAULT)
    240                                                  `uvm_component_utils_end
    241                                                  function new (string name, uvm_component parent);
    242                                                      super.new(name, parent);
    243                                                  endfunction
    244                                              endclass: axiLite_sequencer
    245                                              // UVM_SEQUENCE : RGB_SEQUENCER [RGB]
    246                                              class rgb_sequencer#(parameter set_config cfg = par_1) extends uvm_sequencer#(rgb_transaction#(cfg));
    247                                                  `uvm_component_param_utils(rgb_sequencer#(cfg))
    248                                                  function new(string name, uvm_component parent);
    249                                                      super.new(name, parent);
    250                                                  endfunction
    251                                              endclass: rgb_sequencer
    252                                              // UVM_SEQUENCE : AXI4_STREAM_MASTER_SEQUENCER [AXI4_STREAM]
    253                                              class axi4_stream_master_sequencer extends uvm_sequencer #(axi4_stream_valid_cycle);
    254                                                  `uvm_component_utils(axi4_stream_master_sequencer)
    255                                                  function new(string name, uvm_component parent);
    256                                                      super.new(name, parent);
    257                                                  endfunction
    258                                              endclass: axi4_stream_master_sequencer
    259                                              //====================================================================================
    260                                              //------------------------------------------------------------------------------------
    261                                              //--------------------------------- UVM_SEQUENCES
    262                                              //------------------------------------------------------------------------------------
    263                                              //====================================================================================
    264                                              // UVM_SEQUENCE : RGB_RANDOM_SEQUENCE [RGB]
    265                                              class rgb_random_sequence#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    266                                                  `uvm_object_param_utils(rgb_random_sequence#(cfg));
    267                                                  function new(string name = "rgb_random_sequence");
    268                                                      super.new(name);
    269                                                  endfunction : new
    270                                                  task body();
    271                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    272                                                      repeat (100000) begin : random_loop
    273                                                          start_item(frame_tx);
    274                                                          assert(frame_tx.randomize());
    275                                                          finish_item(frame_tx);
    276                                                      end : random_loop
    277                                                  endtask : body
    278                                              endclass: rgb_random_sequence
    279                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R1 [RGB]
    280                                              class random_sequence_r1#(parameter set_config cfg = par_1) extends uvm_sequence#(rgb_transaction#(cfg));
    281                                                  `uvm_object_param_utils(random_sequence_r1#(cfg));
    282                                                  function new(string name = "random_sequence_r1");
    283                                                      super.new(name);
    284                                                  endfunction : new
    285                                                  task body();
    286                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    287                                                  `uvm_info("random_sequence_r1", "executing...", UVM_LOW)
    288                                                      repeat (100) begin : random_loop
    289                                                          start_item(frame_tx);
    290                                                          assert(frame_tx.randomize());
    291                                                          finish_item(frame_tx);
    292                                                      end : random_loop
    293                                                  endtask : body
    294                                              endclass: random_sequence_r1
    295                                              // UVM_SEQUENCE : RANDOM_SEQUENCE_R2 [RGB]
    296                                              class random_sequence_r2 extends random_sequence_r1;
    297                                                  `uvm_object_utils(random_sequence_r2);
    298                                                  function new(string name = "random_sequence_r2");
    299                                                      super.new(name);
    300                                                  endfunction : new
    301                                                  task body();
    302                                                  rgb_transaction#(cfg) frame_tx = rgb_transaction#(cfg)::type_id::create("frame_tx");
    303                                                  `uvm_info("random_sequence_r2", "executing...", UVM_LOW)
    304                                                      repeat (1) begin : random_loop
    305                                                          start_item(frame_tx);
    306                                                          assert(frame_tx.randomize());
    307                                                          finish_item(frame_tx);
    308                                                      end : random_loop
    309                                                  endtask : body
    310                                              endclass: random_sequence_r2
    311                                              // UVM_SEQUENCE : TOP_SEQUENCE [RGB]
    312                                              class top_sequence extends uvm_sequence #(rgb_transaction);
    313                                                  `uvm_object_utils(top_sequence)
    314                                                  `uvm_declare_p_sequencer(rgb_sequencer)
    315                                                  function new (string name = "");
    316                                                      super.new(name);
    317                                                  endfunction
    318                                                  task body;
    319                                                      rgb_configuration cfg;
    320                                                      int count;
    321                                                      if ( uvm_config_db #(rgb_configuration)::get(p_sequencer, "", "config", cfg) ) begin
    322                                                          count    = cfg.count;
    323                                                      end
    324                                                      else begin
    325                                                          count    = 1;
    326                                                      end
    327                                                      if (starting_phase != null)
    328                                                          starting_phase.raise_objection(this);
    329                                                      repeat(count) begin
    330                                                          random_sequence_r1#(par_1) seq;
    331                                                          seq = random_sequence_r1#(par_1)::type_id::create("seq");
    332                                                          seq.start(p_sequencer, this);
    333                                                      end
    334                                                      if (starting_phase != null)
    335                                                          starting_phase.drop_objection(this);
    336                                                  endtask: body
    337                                              endclass: top_sequence
    338                                              // UVM_SEQUENCE : AXILITE_BASE_SEQ [AXI4_LITE]
    339                                              virtual class axiLite_base_seq extends uvm_sequence #(axiLite_transaction);
    340                                                  function new (string name="axiLite_base_seq");
    341                                                      super.new(name);
    342                                                  endfunction
    343                                              endclass: axiLite_base_seq
    344                                              // UVM_SEQUENCE : AXILITE_NO_ACTIVITY_SEQ [AXI4_LITE]
    345                                              class axiLite_no_activity_sequence extends axiLite_base_seq;
    346                                                  `uvm_object_utils(axiLite_no_activity_sequence)
    347                                                  function new(string name="axiLite_no_activity_sequence");
    348                                                      super.new(name);
    349                                                  endfunction
    350                                                  virtual task body();
    351                                                      `uvm_info("SEQ", "executing", UVM_LOW)
    352                                                  endtask: body
    353                                              endclass: axiLite_no_activity_sequence
    354                                              // UVM_SEQUENCE : AXILITE_RANDOM_SEQ [AXI4_LITE]
    355                                              class axiLite_random_sequence extends axiLite_base_seq;
    356                                                  `uvm_object_utils(axiLite_random_sequence)
    357                                                  function new(string name="axiLite_random_sequence");
    358                                                      super.new(name);
    359                                                  endfunction
    360                                                  virtual task body();
    361                                                      axiLite_transaction item;
    362                                                      int num_txn;
    363                                                      bit typ_txn;
    364                                                      `uvm_info("SEQ", "executing...", UVM_LOW)
    365                                                      num_txn = $urandom_range(5,20);
    366                                                      repeat(num_txn) begin    
    367                                                      `uvm_create(item)
    368                                                      item.cycles         = $urandom_range(1,5);
    369                                                      item.addr           = $urandom();
    370                                                      item.data           = $urandom();
    371                                                      typ_txn             = $random();
    372                                                      item.reqWriteRead   = typ_txn ? WRITE : READ; 
    373                                                      `uvm_send(item);
    374                                                      end    
    375                                                  endtask: body
    376                                              endclass: axiLite_random_sequence
    377                                              // UVM_SEQUENCE : AXILITE_DIRECTED_SEQ [AXI4_LITE]
    378                                              class axiLite_directed_sequence extends axiLite_base_seq;
    379                                                  `uvm_object_utils(axiLite_directed_sequence)
    380                                                  function new(string name="axiLite_directed_sequence");
    381                                                      super.new(name);
    382                                                  endfunction
    383                                                  virtual task body();
    384                                                      axiLite_transaction item;
    385                                                      bit [8:0] addr;
    386                                                      `uvm_info("SEQ", "executing...WR->RD->WR->RD", UVM_LOW)
    387                                                      for(addr = 0; addr < 256; addr ++) begin
    388                                                          `uvm_create(item)
    389                                                          item.addr           = {14'h0,addr[7:0]};
    390                                                          item.reqWriteRead   = addr[0] ? READ : WRITE;
    391                                                          item.cycles         = 0;
    392                                                          item.data           = addr;
    393                                                          `uvm_send(item);
    394                                                      end
    395                                                      `uvm_info("SEQ", "executing...WR->WR->RD->RD", UVM_LOW)
    396                                                      for(addr = 0; addr < 255; addr ++) begin
    397                                                          `uvm_create(item)
    398                                                          item.addr           = {14'h0,addr[7:0]};
    399                                                          item.reqWriteRead   = addr[8] ? READ : WRITE;
    400                                                          item.cycles         = 5;
    401                                                          item.data           = addr;
    402                                                          `uvm_send(item);
    403                                                      end
    404                                                  endtask: body
    405                                              endclass: axiLite_directed_sequence
    406                                              // UVM_SEQUENCE : AXILITE_USEVAR_SEQ [AXI4_LITE]
    407                                              class axiLite_usevar_sequence extends axiLite_base_seq;
    408                                                  `uvm_object_utils(axiLite_usevar_sequence)
    409                                                  `uvm_declare_p_sequencer(axiLite_sequencer)
    410                                                  function new(string name="axiLite_usevar_sequence");
    411                                                      super.new(name);
    412                                                  endfunction
    413                                                  virtual task body();
    414                                                  axiLite_transaction item;
    415                                                  int id;
    416                                                  `uvm_info("SEQ", "executing...", UVM_LOW)
    417                                                  id = p_sequencer.id;
    418                                                  `uvm_info("SEQ", $sformatf("using id=%0hh from sequencer", id), UVM_LOW)
    419                                                  `uvm_create(item)
    420                                                  item.cycles = $urandom_range(1,5);
    421                                                  item.data = id;
    422                                                  `uvm_send(item);
    423                                                  endtask
    424                                              endclass: axiLite_usevar_sequence
    425                                              // UVM_SEQUENCE : TEMPLATE_BASE_SEQ [TEMPLATE]
    426                                              virtual class template_base_sequence extends uvm_sequence #(tp_transaction);
    427                                                  function new (string name="template_base_sequence");
    428                                                      super.new(name);
    429                                                  endfunction
    430                                              endclass: template_base_sequence
    431                                              // UVM_SEQUENCE : TEMPLATE_SEQUENCE [TEMPLATE]
    432                                              class template_sequence extends uvm_sequence#(tp_transaction);
    433                                                  `uvm_object_utils(template_sequence)
    434                                                  function new(string name = "");
    435                                                      super.new(name);
    436                                                  endfunction: new
    437                                                  task body();
    438                                                      tp_transaction tx;
    439                                                      repeat(100) begin
    440                                                      tx = tp_transaction::type_id::create(.name("tx"), .contxt(get_full_name()));
    441                                                      start_item(tx);
    442                                                          assert(tx.randomize());
    443                                                          //`uvm_info("sa_sequence", tx.sprint(), UVM_LOW);
    444                                                      finish_item(tx);
    445                                                      end
    446                                                  endtask: body
    447                                              endclass: template_sequence
    448                                              // UVM_SEQUENCE_ITEM : AX_PACKET [AXI4_STREAM]
    449                                              class ax_packet extends uvm_sequence_item;
    450                                              parameter AX_TYPE_MASK = 6'h38;
    451                                              	// request header fields
    452                                              	rand bit [2:0]			cube_ID;				// CUB
    453                                              	rand bit [33:0]		    address;				// ADRS
    454                                              	rand bit [8:0]			tag;					// TAG
    455                                              	rand bit [3:0]			packet_length;			// LNG 128-bit (16-byte) flits
    456                                              	rand bit [3:0]			duplicate_length;		// DLN
    457                                              	rand ax_command_encoding 	command;			// CMD
    458                                              	bit [127:0]				payload[$];				// 16-byte granularity
    459                                              	// request tail fields
    460                                              	rand bit [4:0]			return_token_count;		// RTC
    461                                              	rand bit [2:0]			source_link_ID;			// SLID
    462                                              	rand bit [2:0]			sequence_number;		// SEQ
    463                                              	rand bit [7:0]			forward_retry_pointer;	// FRP
    464                                              	rand bit [7:0]			return_retry_pointer;	// RRP
    465                                              	rand bit [31:0]		packet_crc;				// CRC
    466                                              	// response header fields not used before
    467                                              	rand bit [8:0]			return_tag;				// TGA (Optional)
    468                                              	// response tail fields not used before
    469                                              	rand bit [6:0]			error_status;			// ERRSTAT
    470                                              	rand bit				data_invalid;			// DINV
    471                                              	// special bits for IRTRY
    472                                              	rand bit				start_retry;
    473                                              	rand bit				clear_error_abort;
    474                                              	// CRC status fields
    475                                              	rand bit				poisoned;				// Inverted CRC
    476                                              	rand bit				crc_error;
    477                                              	// helper fields
    478                                              	rand int				flit_delay;
    479                                              	int						timestamp;
    480                                              	`uvm_object_utils_begin(ax_packet)
    481                                              		`uvm_field_int(flit_delay, UVM_ALL_ON | UVM_NOPACK | UVM_DEC | UVM_NOCOMPARE | UVM_DEC)
    482                                              		`uvm_field_int(cube_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    483                                              		`uvm_field_int(address, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    484                                              		`uvm_field_int(tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    485                                              		`uvm_field_int(packet_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    486                                              		`uvm_field_int(duplicate_length, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    487                                              		`uvm_field_enum(ax_command_encoding, command, UVM_ALL_ON | UVM_NOPACK )
    488                                              		`uvm_field_queue_int(payload, UVM_ALL_ON | UVM_NOPACK)
    489                                              		`uvm_field_int(return_token_count, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    490                                              		`uvm_field_int(source_link_ID, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    491                                              		`uvm_field_int(sequence_number, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    492                                              		`uvm_field_int(forward_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    493                                              		`uvm_field_int(return_retry_pointer, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    494                                              		`uvm_field_int(packet_crc, UVM_ALL_ON | UVM_NOPACK | UVM_HEX)
    495                                              		`uvm_field_int(return_tag, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    496                                              		`uvm_field_int(error_status, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    497                                              		`uvm_field_int(data_invalid, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    498                                              		`uvm_field_int(poisoned, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    499                                              		`uvm_field_int(crc_error, UVM_ALL_ON | UVM_NOPACK | UVM_DEC)
    500                                              	`uvm_object_utils_end
    501                                              	constraint c_poisoned { poisoned == 0; }
    502                                              	constraint c_cube_id {cube_ID ==0;}
    503                                              	constraint c_address {
    504                                              		soft address < 80000000;
    505                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> address == 0;	
    506                                              		soft address[3:0]==4'h0;
    507                                              	}
    508                                              	constraint c_source_link_ID {source_link_ID ==0;}
    509                                              	constraint c_crc_error { crc_error == 0; }
    510                                              	constraint c_matching_length { packet_length == duplicate_length; }
    511                                              	constraint c_return_tag { return_tag == 0; }
    512                                              	constraint c_packet_length { (
    513                                              						(packet_length == 2 && command == AX_POSTED_WRITE_16) ||
    514                                              						(packet_length == 3 && command == AX_POSTED_WRITE_32) ||
    515                                              						(packet_length == 4 && command == AX_POSTED_WRITE_48) ||
    516                                              						(packet_length == 5 && command == AX_POSTED_WRITE_64) ||
    517                                              						(packet_length == 6 && command == AX_POSTED_WRITE_80) ||
    518                                              						(packet_length == 7 && command == AX_POSTED_WRITE_96) ||
    519                                              						(packet_length == 8 && command == AX_POSTED_WRITE_112) ||
    520                                              						(packet_length == 9 && command == AX_POSTED_WRITE_128) ||
    521                                              						(packet_length == 2 && command == AX_WRITE_16) ||
    522                                              						(packet_length == 3 && command == AX_WRITE_32) ||
    523                                              						(packet_length == 4 && command == AX_WRITE_48) ||
    524                                              						(packet_length == 5 && command == AX_WRITE_64) ||
    525                                              						(packet_length == 6 && command == AX_WRITE_80) ||
    526                                              						(packet_length == 7 && command == AX_WRITE_96) ||
    527                                              						(packet_length == 8 && command == AX_WRITE_112) ||
    528                                              						(packet_length == 9 && command == AX_WRITE_128) ||
    529                                              						(packet_length > 1 && packet_length <= 9 && command == AX_READ_RESPONSE) ||
    530                                              						(packet_length == 1 && command == AX_WRITE_RESPONSE) ||
    531                                              						(packet_length == 1 && command == AX_MODE_WRITE_RESPONSE) ||
    532                                              						(packet_length == 1 && command == AX_ERROR_RESPONSE) ||
    533                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_MISC_WRITE_TYPE) ||
    534                                              						(packet_length == 2 && (command & AX_TYPE_MASK) == AX_POSTED_MISC_WRITE_TYPE) ||
    535                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_MODE_READ_TYPE) ||
    536                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_READ_TYPE) ||
    537                                              						(packet_length == 1 && (command & AX_TYPE_MASK) == AX_FLOW_TYPE)
    538                                              		); }
    539                                              	constraint c_flit_delay {
    540                                              		soft flit_delay dist{0:/90, [1:8]:/8, [8:200]:/2  };
    541                                              	}
    542                                              	constraint c_error_status {
    543                                              		soft error_status == 0;
    544                                              	}
    545                                              	constraint c_data_invalid {
    546                                              		soft data_invalid == 0;
    547                                              	}
    548                                              	constraint c_pret {
    549                                              		(command == AX_PRET)-> forward_retry_pointer	==0;
    550                                              		(command == AX_PRET)-> sequence_number			==0;
    551                                              	}
    552                                              	constraint c_irtry{
    553                                              		(command == AX_IRTRY) 							-> start_retry 			!= clear_error_abort;
    554                                              		((command == AX_IRTRY)&&(start_retry)) 		->forward_retry_pointer == 1;
    555                                              		((command == AX_IRTRY)&&(clear_error_abort))	->forward_retry_pointer == 2;
    556                                              		(command == AX_IRTRY)							-> sequence_number		== 0;
    557                                              	}
    558                                              	constraint c_flow {
    559                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> tag == 0;
    560                                              		((command & AX_TYPE_MASK) == AX_FLOW_TYPE) -> cube_ID == 0;
    561                                              	}
    562                                              	function new (string name = "ax_packet");
    563                                              		super.new(name);
    564                                              	endfunction : new
    565                                                  function void post_randomize();
    566                                              		bit [127:0] rand_flit;
    567                                                      super.post_randomize();
    568                                              		if (packet_length > 9)
    569                                              			`uvm_fatal(get_type_name(),$psprintf("post_randomize packet_length = %0d",packet_length))
    570                                              		`uvm_info("AXI Packet queued",$psprintf("%0s packet_length = %0d",command.name(), packet_length), UVM_HIGH)
    571                                              		if (packet_length < 2)
    572                                              			return;
    573                                              		for (int i=0; i<packet_length-1; i++) begin
    574                                              			randomize_flit_successful : assert (std::randomize(rand_flit));
    575                                              			payload.push_back(rand_flit);
    576                                              		end
    577                                              		if ((command == AX_POSTED_DUAL_8B_ADDI)||
    578                                              			(command == AX_DUAL_8B_ADDI)) begin
    579                                              			payload[0] [63:32] = 32'b0;
    580                                              			payload[0][127:96] = 32'b0;
    581                                              		end
    582                                              		if ((command == AX_MODE_WRITE)|| (command == AX_MODE_READ)) begin
    583                                              			payload[0][127:32] = 96'b0;
    584                                              		end
    585                                                  endfunction
    586                                              	function ax_command_type get_command_type();
    587                                              		case(command & AX_TYPE_MASK)
    588                                              			AX_FLOW_TYPE:				return AX_FLOW_TYPE;
    589                                              			AX_READ_TYPE:				return AX_READ_TYPE;
    590                                              			AX_MODE_READ_TYPE:			return AX_MODE_READ_TYPE;
    591                                              			AX_POSTED_WRITE_TYPE:		return AX_POSTED_WRITE_TYPE;
    592                                              			AX_POSTED_MISC_WRITE_TYPE:	return AX_POSTED_MISC_WRITE_TYPE;
    593                                              			AX_WRITE_TYPE:				return AX_WRITE_TYPE;
    594                                              			AX_MISC_WRITE_TYPE:		return AX_MISC_WRITE_TYPE;
    595                                              			AX_RESPONSE_TYPE:			return AX_RESPONSE_TYPE;
    596                                              			default: uvm_report_fatal(get_type_name(), $psprintf("command with an illegal command type='h%0h!", command));
    597                                              		endcase
    598                                              	endfunction : get_command_type
    599                                              /*
    600                                              		The CRC algorithm used on the AX is the Koopman CRC-32K. This algorithm was
    601                                              		chosen for the AX because of its balance of coverage and ease of implementation. The
    602                                              		polynomial for this algorithm is:
    603                                              		x32 + x30 + x29 + x28 + x26 + x20 + x19 + x17 + x16 + x15 + x11 + x10 + x7 + x6 + x4 + x2 + x + 1
    604                                              		bit [31:0] polynomial = 33'b1_0111_0100_0001_1011_1000_1100_1101_0111;	// Normal
    605                                              		The CRC calculation operates on the LSB of the packet first. The packet CRC calculation
    606                                              		must insert 0s in place of the 32-bits representing the CRC field before generating or
    607                                              		checking the CRC. For example, when generating CRC for a packet, bits [63: 32] of the
    608                                              		Tail presented to the CRC generator should be all zeros. The output of the CRC generator
    609                                              		will have a 32-bit CRC value that will then be inserted in bits [63:32] of the Tail before
    610                                              		forwarding that FLIT of the packet. When checking CRC for a packet, the CRC field
    611                                              		should be removed from bits [63:32] of the Tail and replaced with 32-bits of zeros, then
    612                                              		presented to the CRC checker. The output of the CRC checker will have a 32-bit CRC
    613                                              		value that can be compared with the CRC value that was removed from the tail. If the two
    614                                              		compare, the CRC check indicates no bit failures within the packet.
    615                                              */
    616                                              	function bit [31:0] calculate_crc();
    617                                              		bit bitstream[];
    618                                              		packer_succeeded : assert (pack(bitstream) > 0);
    619                                              		return calc_crc(bitstream);
    620                                              	endfunction : calculate_crc
    621                                              	function bit [31:0] calc_crc(bit bitstream[]);
    622                                              		bit [32:0] polynomial = 33'h1741B8CD7; // Normal
    623                                              		bit [32:0] remainder = 33'h0;
    624                                              		for( int i=0; i < bitstream.size()-32; i++ ) begin	// without the CRC
    625                                              			remainder = {remainder[31:0], bitstream[i]};
    626                                              			if( remainder[32] ) begin
    627                                              				remainder = remainder ^ polynomial;
    628                                              			end
    629                                              		end
    630                                              		for( int i=0; i < 64; i++ ) begin	// zeroes for CRC and remainder
    631                                              			remainder = {remainder[31:0], 1'b0};
    632                                              			if( remainder[32] ) begin
    633                                              				remainder = remainder ^ polynomial;
    634                                              			end
    635                                              		end
    636                                              		return remainder[31:0];
    637                                              	endfunction : calc_crc
    638                                              	virtual function void do_pack(uvm_packer packer);
    639                                              		super.do_pack(packer);
    640                                              		packer.big_endian = 0;
    641                                              		// pack header half flit
    642                                              		case(command & AX_TYPE_MASK)
    643                                              			AX_FLOW_TYPE:
    644                                              				case (command)
    645                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    646                                              					AX_PRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    647                                              					AX_TRET:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    648                                              					AX_IRTRY:		packer.pack_field ( {3'h0, 3'h0, 34'h0, 9'h0, duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    649                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal FLOW type='h%0h!", command));
    650                                              				endcase
    651                                              			AX_READ_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    652                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {cube_ID[2:0], 3'h0, 34'h0, tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    653                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    654                                              			AX_WRITE_TYPE:			packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    655                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    656                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {cube_ID[2:0], 3'h0, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    657                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {22'h0, source_link_ID[2:0], 6'h0, return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], 1'b0, command[5:0]}, 64);
    658                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function called for a ax_packet with an illegal command type='h%0h!", command));
    659                                              		endcase
    660                                              		// Allow for errors when packet_length != duplicate_length
    661                                              		if ((packet_length == duplicate_length) && payload.size() + 1 != packet_length && command != AX_NULL)
    662                                              			uvm_report_fatal(get_type_name(), $psprintf("pack function size mismatch payload.size=%0d packet_length=%0d!", payload.size(), packet_length));
    663                                              		// pack payload
    664                                              		for( int i=0; i<payload.size(); i++ ) packer.pack_field ( payload[i], 128);
    665                                              		// pack tail half flit
    666                                              		case(command & AX_TYPE_MASK)
    667                                              			AX_FLOW_TYPE:
    668                                              				case (command)
    669                                              					AX_NULL:		packer.pack_field( {64'h0}, 64);
    670                                              					AX_PRET:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 8'h0, return_retry_pointer[7:0]}, 64);
    671                                              					AX_TRET:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], 3'h0, 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    672                                              					AX_IRTRY:		packer.pack_field ( {packet_crc[31:0], 5'h0, 3'h0, 5'h0, 3'h0, 6'h0, clear_error_abort, start_retry, return_retry_pointer[7:0]}, 64);
    673                                              					default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal FLOW type='h%0h!", command));
    674                                              				endcase
    675                                              			AX_READ_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    676                                              			AX_POSTED_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    677                                              			AX_WRITE_TYPE:			packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    678                                              			AX_MODE_READ_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    679                                              			AX_POSTED_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    680                                              			AX_MISC_WRITE_TYPE:	packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], 5'h0, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    681                                              			AX_RESPONSE_TYPE:		packer.pack_field ( {packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}, 64);
    682                                              			default: uvm_report_fatal(get_type_name(), $psprintf("pack function (tail) called for a ax_packet with an illegal command type='h%0h!", command));
    683                                              		endcase
    684                                              	endfunction : do_pack
    685                                              	virtual function void do_unpack(uvm_packer packer);
    686                                              		bit [63:0]	header;
    687                                              		bit [63:0]	tail;
    688                                              		bit [31:0]	calculated_crc;
    689                                              		bit [21:0]	rsvd22;
    690                                              		bit [5:0]	rsvd6;
    691                                              		bit [4:0]	rsvd5;
    692                                              		bit [2:0]	rsvd3;
    693                                              		bit 		rsvd1;
    694                                              		bit bitstream[];
    695                                              		super.do_unpack(packer);
    696                                              		packer.big_endian = 0;
    697                                              		packer.get_bits(bitstream);
    698                                              		for (int i = 0; i <32; i++)begin
    699                                              			packet_crc[i] = bitstream[bitstream.size()-32 +i];
    700                                              		end
    701                                              		calculated_crc = calc_crc(bitstream);
    702                                              		// header
    703                                              		header = packer.unpack_field(64);
    704                                              		command[5:0] = header[5:0];//-- doppelt?
    705                                              		if (get_command_type != AX_RESPONSE_TYPE)
    706                                              			{cube_ID[2:0], rsvd3, address[33:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    707                                              		else
    708                                              			{rsvd22[21:0], source_link_ID[2:0], rsvd6[5:0], return_tag[8:0], tag[8:0], duplicate_length[3:0], packet_length[3:0], rsvd1, command[5:0]}	= header;
    709                                              		// Unpack should not be called with length errors
    710                                              		if (duplicate_length != packet_length || packet_length == 0)
    711                                              			`uvm_fatal(get_type_name(), $psprintf("do_unpack: length mismatch dln=%0d len=%0d cmd=%0d!", duplicate_length, packet_length, command));
    712                                              		// payload
    713                                              		for (int i = 0; i < packet_length-1; i++)
    714                                              			payload.push_back(packer.unpack_field(128));
    715                                              		// tail
    716                                              		tail = packer.unpack_field(64);
    717                                              		if (get_command_type != AX_RESPONSE_TYPE) 
    718                                              			{packet_crc[31:0], return_token_count[4:0], source_link_ID[2:0], rsvd5, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    719                                              		else
    720                                              			{packet_crc[31:0], return_token_count[4:0], error_status[6:0], data_invalid, sequence_number[2:0], forward_retry_pointer[7:0], return_retry_pointer[7:0]}	= tail;
    721                                              		start_retry			= (command == AX_IRTRY ? forward_retry_pointer[0] : 1'b0);
    722                                              		clear_error_abort	= (command == AX_IRTRY ? forward_retry_pointer[1] : 1'b0);
    723                                              		crc_error = 0;
    724                                              		poisoned = (packet_crc == ~calculated_crc) ? 1'b1 : 1'b0;
    725                                              		if (packet_crc != calculated_crc &&  !poisoned )
    726                                              		begin
    727                                              			crc_error = 1;
    728                                              		end
    729                                              	endfunction : do_unpack
    730                                              	virtual function bit compare_adaptive_packet(ax_packet rhs, uvm_comparer comparer);
    731                                              		string name_string;
    732                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    733                                              		compare_adaptive_packet &= comparer.compare_field("payload.size()", payload.size(), rhs.payload.size(), 64, UVM_DEC);
    734                                              		for (int i=0; i<packet_length; i++)
    735                                              		begin
    736                                              			if (!compare_adaptive_packet)
    737                                              				return 0;
    738                                              			$sformat(name_string, "payload[%0d]", i);
    739                                              			compare_adaptive_packet &= comparer.compare_field(name_string, payload[i], rhs.payload[i], 128, UVM_HEX);
    740                                              		end
    741                                              		compare_adaptive_packet &= comparer.compare_field("cube_ID", cube_ID, rhs.cube_ID, 64, UVM_DEC);
    742                                              		compare_adaptive_packet &= comparer.compare_field("address", address, rhs.address, 64, UVM_DEC);
    743                                              		compare_adaptive_packet &= comparer.compare_field("tag", tag, rhs.tag, 64, UVM_DEC);
    744                                              		compare_adaptive_packet &= comparer.compare_field("packet_length", packet_length, rhs.packet_length, 64, UVM_DEC);
    745                                              		compare_adaptive_packet &= comparer.compare_field("duplicate_length", duplicate_length, rhs.duplicate_length, 64, UVM_DEC);
    746                                              		compare_adaptive_packet &= comparer.compare_field("command", command, rhs.command, 64, UVM_DEC);
    747                                              		compare_adaptive_packet &= comparer.compare_field("return_token_count", return_token_count, rhs.return_token_count, 64, UVM_DEC);
    748                                              		compare_adaptive_packet &= comparer.compare_field("source_link_ID", source_link_ID, rhs.source_link_ID, 64, UVM_DEC);
    749                                              		compare_adaptive_packet &= comparer.compare_field("sequence_number", sequence_number, rhs.sequence_number, 64, UVM_DEC);
    750                                              		compare_adaptive_packet &= comparer.compare_field("forward_retry_pointer", forward_retry_pointer, rhs.forward_retry_pointer, 64, UVM_DEC);
    751                                              		compare_adaptive_packet &= comparer.compare_field("return_tag", return_tag, rhs.return_tag, 64, UVM_DEC);
    752                                              		compare_adaptive_packet &= comparer.compare_field("error_status", error_status, rhs.error_status, 64, UVM_DEC);
    753                                              		compare_adaptive_packet &= comparer.compare_field("data_invalid", data_invalid, rhs.data_invalid, 64, UVM_DEC);
    754                                              		compare_adaptive_packet &= comparer.compare_field("start_retry", start_retry, rhs.start_retry, 64, UVM_DEC);
    755                                              		compare_adaptive_packet &= comparer.compare_field("clear_error_abort", clear_error_abort, rhs.clear_error_abort, 64, UVM_DEC);
    756                                              	endfunction : compare_adaptive_packet
    757                                              endclass: ax_packet
    758                                              // UVM_SEQUENCE : AXI4_STREAM_MASTER_SEQUENCE [AXI4_STREAM]
    759                                              class axi4_stream_master_sequence extends uvm_sequence#(axi4_stream_valid_cycle);
    760                                              	`uvm_object_utils(axi4_stream_master_sequence)
    761                                              	rand int delay;
    762                                              	rand ax_packet response;
    763                                              	rand bit error_response;
    764                                                  event item_available;
    765                                              	constraint delay_c {
    766                                              		delay dist {0:=4, [0:9]:=8, [10:30]:=2, [31:100]:=1};
    767                                              	}
    768                                                  function new(string name = "");
    769                                                      super.new(name);
    770                                                  endfunction: new
    771                                                  task body();
    772                                                      axi4_stream_valid_cycle vc;
    773                                                      repeat(100) begin
    774                                                      vc = axi4_stream_valid_cycle::type_id::create(.name("vc"), .contxt(get_full_name()));
    775                                                      start_item(vc);
    776                                                          assert(vc.randomize());
    777                                                      finish_item(vc);
    778                                                      end
    779                                                  endtask : body
    780                                              endclass: axi4_stream_master_sequence
    781                                              //====================================================================================
    782                                              //------------------------------------------------------------------------------------
    783                                              //--------------------------------- UVM_DRIVERS
    784                                              //------------------------------------------------------------------------------------
    785                                              //====================================================================================
    786                                              // UVM_DRIVER : AXILITE_DRV [AXI4_LITE]
    787                                              class axiLite_driver extends uvm_driver #(axiLite_transaction);
    788                                                  protected virtual axi4l_if axi4l_vif;
    789                                                  protected int     id;
    790                                                  `uvm_component_utils_begin(axiLite_driver)
    791                                                      `uvm_field_int(id, UVM_DEFAULT)
    792                                                  `uvm_component_utils_end
    793                                                  function new (string name, uvm_component parent);
    794                                                      super.new(name, parent);
    795                                                  endfunction
    796                                                  function void build_phase (uvm_phase phase);
    797                                                      super.build_phase(phase);
    798                                                      if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    799                                                      `uvm_fatal("NOVIF", {"virtual interface must be set for: ",get_full_name(), ".axi4l_vif"});
    800                                                  endfunction
    801                                                  virtual task run_phase (uvm_phase phase);
    802                                                      fork
    803                                                          get_and_drive();
    804                                                          reset_signals();
    805                                                      join
    806                                                  endtask: run_phase
    807                                                  virtual protected task get_and_drive();
    808                                                      forever begin
    809                                                          @(posedge axi4l_vif.ACLK);
    810                                                          if (axi4l_vif.ARESETN == 1'b0) begin
    811                                                              @(posedge axi4l_vif.ARESETN);
    812                                                              @(posedge axi4l_vif.ACLK);
    813                                                          end
    814                                                          seq_item_port.get_next_item(req);
    815                                                          //`uvm_info("DRV", req.convert2string(), UVM_LOW)
    816                                                          repeat(req.cycles) begin
    817                                                              @(posedge axi4l_vif.ACLK);
    818                                                          end
    819                                                          drive_transfer(req);
    820                                                          seq_item_port.item_done();
    821                                                      end
    822                                                  endtask: get_and_drive
    823                                                  virtual protected task reset_signals();
    824                                                      forever begin
    825                                                          @(negedge axi4l_vif.ARESETN);
    826                                                          axi4l_vif.AWADDR  <=  8'h0;
    827                                                          axi4l_vif.AWPROT  <=  3'h0;
    828                                                          axi4l_vif.AWVALID <=  1'b0;
    829                                                          axi4l_vif.WDATA   <= 32'h0;
    830                                                          axi4l_vif.WSTRB   <=  4'h0;
    831                                                          axi4l_vif.WVALID  <=  1'b0;
    832                                                          axi4l_vif.BREADY  <=  1'b1;
    833                                                          axi4l_vif.ARADDR  <=  8'h0;
    834                                                          axi4l_vif.ARPROT  <=  3'h0;
    835                                                          axi4l_vif.ARVALID <=  1'b0;
    836                                                          axi4l_vif.RREADY  <=  1'b1;
    837                                                      end
    838                                                  endtask: reset_signals
    839                                                  virtual protected task drive_transfer (axiLite_transaction aL_txn);
    840                                                      drive_address_phase(aL_txn);
    841                                                      drive_data_phase(aL_txn);
    842                                                  endtask: drive_transfer
    843                                                  virtual protected task drive_address_phase (axiLite_transaction aL_txn);
    844                                                      //`uvm_info("axiLite_master_driver", "drive_address_phase",UVM_HIGH)
    845                                                      case (aL_txn.reqWriteRead)
    846                                                          READ : drive_read_address_channel(aL_txn);
    847                                                          WRITE: drive_write_address_channel(aL_txn);
    848                                                      endcase
    849                                                  endtask: drive_address_phase
    850                                                  virtual protected task drive_data_phase (axiLite_transaction aL_txn);
    851                                                      bit[31:0] rw_data;
    852                                                      bit err;
    853                                                      rw_data = aL_txn.data;
    854                                                      case (aL_txn.reqWriteRead)
    855                                                      READ : drive_read_data_channel(rw_data, err);
    856                                                      WRITE: drive_write_data_channel(rw_data, err);
    857                                                      endcase    
    858                                                  endtask: drive_data_phase
    859                                                  virtual protected task drive_write_address_channel (axiLite_transaction aL_txn);
    860                                                      int axiLite_ctr;
    861                                                      axi4l_vif.AWADDR  <= {8'h0, aL_txn.addr};
    862                                                      axi4l_vif.AWPROT  <= 3'h0;
    863                                                      axi4l_vif.AWVALID <= 1'b1;
    864                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    865                                                          @(posedge axi4l_vif.ACLK);
    866                                                          if (axi4l_vif.AWREADY) break;
    867                                                      end
    868                                                      if (axiLite_ctr == 31) begin
    869                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    870                                                      end    
    871                                                      @(posedge axi4l_vif.ACLK);
    872                                                      // axi4l_vif.AWADDR  <= 8'h0;
    873                                                      // axi4l_vif.AWPROT  <= 3'h0;
    874                                                      // axi4l_vif.AWVALID <= 1'b0;    
    875                                                  endtask: drive_write_address_channel
    876                                                  virtual protected task drive_read_address_channel (axiLite_transaction aL_txn);
    877                                                      int axiLite_ctr;
    878                                                      axi4l_vif.ARADDR  <= {8'h0, aL_txn.addr};
    879                                                      axi4l_vif.ARPROT  <= 3'h0;
    880                                                      axi4l_vif.ARVALID <= 1'b1;
    881                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    882                                                          @(posedge axi4l_vif.ACLK);
    883                                                          if (axi4l_vif.ARREADY) break;
    884                                                      end
    885                                                      if (axiLite_ctr == 31) begin
    886                                                          `uvm_error("axiLite_master_driver","ARVALID timeout");
    887                                                      end
    888                                                      @(posedge axi4l_vif.ACLK);
    889                                                      axi4l_vif.ARADDR  <= 8'h0;
    890                                                      axi4l_vif.ARPROT  <= 3'h0;
    891                                                      axi4l_vif.ARVALID <= 1'b0;    
    892                                                  endtask: drive_read_address_channel
    893                                                  virtual protected task drive_write_data_channel (bit[31:0] data, output bit error);
    894                                                      int axiLite_ctr;
    895                                                      axi4l_vif.WDATA  <= data;
    896                                                      axi4l_vif.WSTRB  <= 4'hf;
    897                                                      axi4l_vif.WVALID <= 1'b1;
    898                                                      @(posedge axi4l_vif.ACLK);
    899                                                          for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    900                                                          @(posedge axi4l_vif.ACLK);
    901                                                          if (axi4l_vif.WREADY) 
    902                                                                  axi4l_vif.AWADDR  <= 8'h0;
    903                                                      axi4l_vif.AWPROT  <= 3'h0;
    904                                                      axi4l_vif.AWVALID <= 1'b0; 
    905                                                          break;
    906                                                      end
    907                                                      if (axiLite_ctr == 31) begin
    908                                                          `uvm_error("axiLite_master_driver","AWVALID timeout");
    909                                                      end
    910                                                      @(posedge axi4l_vif.ACLK);
    911                                                      axi4l_vif.WDATA  <= 32'h0;
    912                                                      axi4l_vif.WSTRB  <= 4'h0;
    913                                                      axi4l_vif.WVALID <= 1'b0;
    914                                                      //wait for write response
    915                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    916                                                          @(posedge axi4l_vif.ACLK);
    917                                                          if (axi4l_vif.BVALID) break;
    918                                                      end
    919                                                      if (axiLite_ctr == 31) begin
    920                                                          `uvm_error("axiLite_master_driver","BVALID timeout");
    921                                                      end
    922                                                      else begin
    923                                                          if (axi4l_vif.BVALID == 1'b1 && axi4l_vif.BRESP != 2'h0)
    924                                                          `uvm_error("axiLite_master_driver","Received ERROR Write Response");
    925                                                          axi4l_vif.BREADY <= axi4l_vif.BVALID;
    926                                                       @(posedge axi4l_vif.ACLK);
    927                                                      end
    928                                                  endtask: drive_write_data_channel
    929                                                  // drive read data channel
    930                                                  virtual protected task drive_read_data_channel (output bit [31:0] data, output bit error);
    931                                                      int axiLite_ctr;
    932                                                      for(axiLite_ctr = 0; axiLite_ctr <= 31; axiLite_ctr ++) begin
    933                                                          @(posedge axi4l_vif.ACLK);
    934                                                          if (axi4l_vif.RVALID) break;
    935                                                      end
    936                                                      data = axi4l_vif.RDATA;
    937                                                      if (axiLite_ctr == 31) begin
    938                                                          `uvm_error("axiLite_master_driver","RVALID timeout");
    939                                                      end
    940                                                      else begin
    941                                                      if (axi4l_vif.RVALID == 1'b1 && axi4l_vif.RRESP != 2'h0)
    942                                                          `uvm_error("axiLite_master_driver","Received ERROR Read Response");
    943                                                          axi4l_vif.RREADY <= axi4l_vif.RVALID;
    944                                                          @(posedge axi4l_vif.ACLK);
    945                                                      end
    946                                                  endtask: drive_read_data_channel
    947                                              endclass: axiLite_driver
    948                                              // UVM_DRIVER : TEMPLATE_DRIVER [TEMPLATE]
    949                                              class template_driver extends uvm_driver#(tp_transaction);
    950                                                  `uvm_component_utils(template_driver)
    951                                                  virtual tp_if tp_vif;
    952                                                  function new(string name, uvm_component parent);
    953                                                      super.new(name, parent);
    954                                                  endfunction: new
    955                                                  function void build_phase(uvm_phase phase);
    956                                                      super.build_phase(phase);
    957                                                      void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    958                                                  endfunction: build_phase
    959                                                  task run_phase(uvm_phase phase);
    960                                                      drive();
    961                                                  endtask: run_phase
    962                                                  virtual task drive();
    963                                                      tp_transaction tx;
    964                                                      integer counter = 0, state = 0;
    965                                                      tp_vif.sig_ina  = 0'b0;
    966                                                      tp_vif.sig_inb  = 0'b0;
    967                                                      tp_vif.sig_en_i = 1'b0;
    968                                                      forever begin
    969                                                          if(counter==0)
    970                                                          begin
    971                                                              seq_item_port.get_next_item(tx);
    972                                                          end
    973                                                          @(posedge tp_vif.sig_clock)
    974                                                          begin
    975                                                              if(counter==0)
    976                                                              begin
    977                                                                  tp_vif.sig_en_i = 1'b1;
    978                                                                  state = 1;
    979                                                              end
    980                                                              if(counter==1)
    981                                                              begin
    982                                                                  tp_vif.sig_en_i = 1'b0;
    983                                                              end
    984                                                              case(state)
    985                                                                  1: begin
    986                                                                      tp_vif.sig_ina = tx.ina[1];
    987                                                                      tp_vif.sig_inb = tx.inb[1];
    988                                                                      tx.ina = tx.ina << 1;
    989                                                                      tx.inb = tx.inb << 1;
    990                                                                      counter = counter + 1;
    991                                                                      if(counter==2) state = 2;
    992                                                                  end
    993                                                                  2: begin
    994                                                                      tp_vif.sig_ina = 1'b0;
    995                                                                      tp_vif.sig_inb = 1'b0;
    996                                                                      counter = counter + 1;
    997                                                                      if(counter==6)
    998                                                                      begin
    999                                                                          counter = 0;
    1000                                                                         state = 0;
    1001                                                                         seq_item_port.item_done();
    1002                                                                     end
    1003                                                                 end
    1004                                                             endcase
    1005                                                         end
    1006                                                     end
    1007                                                 endtask: drive
    1008                                             endclass: template_driver
    1009                                             // UVM_DRIVER : RGB_DRIVER [RGB]
    1010                                             class rgb_driver#(parameter set_config cfg = par_1) extends uvm_driver#(rgb_transaction#(cfg));
    1011                                                 `uvm_component_param_utils(rgb_driver#(cfg))
    1012                                                 virtual rgb_if#(cfg) rgb_vi;
    1013                                                 function new(string name, uvm_component parent);
    1014                                                     super.new(name, parent);
    1015                                                 endfunction: new
    1016                                                 function void build_phase(uvm_phase phase);
    1017                                                     super.build_phase(phase);
    1018                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name(.scope("ifs"),.name("rgb_if"),.val(rgb_vi)));
    1019                                                 endfunction: build_phase
    1020                                                 task run_phase(uvm_phase phase);
    1021                                                     rgb_transaction#(cfg) frame_tx;
    1022                                                     forever begin
    1023                                                         @rgb_vi.master_cb;
    1024                                                         seq_item_port.get_next_item(frame_tx);
    1025                                                         @rgb_vi.master_cb;
    1026                                                         rgb_vi.master_cb.iRed        <= frame_tx.iRed;
    1027                                                         rgb_vi.master_cb.iGreen      <= frame_tx.iGreen;
    1028                                                         rgb_vi.master_cb.iBlue       <= frame_tx.iBlue;
    1029                                                         rgb_vi.master_cb.iX          <= frame_tx.iX;
    1030                                                         rgb_vi.master_cb.iY          <= frame_tx.iY;
    1031                                                         rgb_vi.master_cb.iPixelEn    <= frame_tx.iPixelEn;
    1032                                                         rgb_vi.master_cb.iValid      <= frame_tx.iValid;
    1033                                                         rgb_vi.master_cb.iEof        <= frame_tx.iEof;
    1034                                                         seq_item_port.item_done();
    1035                                                     end
    1036                                                 endtask: run_phase
    1037                                             endclass: rgb_driver
    1038                                             // UVM_DRIVER : AXI4_STREAM_MASTER_DRIVER 
    1039                                             class axi4_stream_master_driver  extends uvm_driver #(axi4_stream_valid_cycle);
    1040                                                 `uvm_component_utils(axi4_stream_master_driver)
    1041                                                 	axi4_stream_config axi4_stream_cfg;
    1042                                                 virtual interface axi4s_if  axi4s_vif;
    1043                                                 function new(string name, uvm_component parent);
    1044                                                     super.new(name, parent);
    1045                                                 endfunction: new
    1046                                                 function void build_phase(uvm_phase phase);
    1047                                                     super.build_phase(phase);
    1048                                                 endfunction : build_phase
    1049                                             	task run_phase(uvm_phase phase);
    1050                                             		super.run_phase(phase);
    1051                                             		forever begin
    1052                                             			if(axi4s_vif.ARESET_N !== 1) begin
    1053                                             				axi4s_vif.TVALID <= 0;
    1054                                             				//`uvm_info(get_type_name(),$psprintf("reset"), UVM_HIGH)
    1055                                             				@(posedge axi4s_vif.ARESET_N);
    1056                                             			//	`uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_HIGH)
    1057                                             			end
    1058                                             			fork
    1059                                             				begin //-- Asynchronous reset
    1060                                             					@(negedge axi4s_vif.ARESET_N);
    1061                                             				end
    1062                                             				begin
    1063                                             					drive_valid_cycles();
    1064                                             				end
    1065                                             			join_any
    1066                                             			disable fork;
    1067                                             		end
    1068                                             	endtask : run_phase
    1069                                             	task drive_valid_cycles();
    1070                                             		@(posedge axi4s_vif.ACLK);
    1071                                             		forever begin
    1072                                             			axi4_stream_valid_cycle  vc;
    1073                                             			//-- Try next AXI4 item
    1074                                             			seq_item_port.try_next_item(vc);
    1075                                             			if( vc != null) begin
    1076                                             				//`uvm_info(get_type_name(),$psprintf("There is an item to sent"), UVM_MEDIUM)
    1077                                             				//`uvm_info(get_type_name(),$psprintf("send %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1078                                             				//-- Wait until delay
    1079                                             				repeat(vc.delay)
    1080                                             					@(posedge axi4s_vif.ACLK);
    1081                                             				//-- Send AXI4 cycle
    1082                                             				axi4s_vif.TDATA  <= vc.tdata;
    1083                                             				axi4s_vif.TUSER  <= vc.tuser;
    1084                                             				axi4s_vif.TVALID <= 1;
    1085                                             				@(posedge axi4s_vif.ACLK)
    1086                                             				while(axi4s_vif.TREADY == 0)
    1087                                             					@(posedge axi4s_vif.ACLK);
    1088                                             				axi4s_vif.TUSER  <= 0;
    1089                                             				axi4s_vif.TDATA  <= 0;
    1090                                             				axi4s_vif.TVALID <= 0;
    1091                                             				//`uvm_info(get_type_name(),$psprintf("send done: %0x %0x", vc.tuser, vc.tdata), UVM_MEDIUM)
    1092                                             				seq_item_port.item_done();
    1093                                             			end else //-- Else wait 1 cycle
    1094                                             				@(posedge axi4s_vif.ACLK);
    1095                                             		end
    1096                                             	endtask : drive_valid_cycles
    1097                                             endclass: axi4_stream_master_driver
    1098                                             // UVM_DRIVER : AXI4_STREAM_SLAVE_DRIVER 
    1099                                             class axi4_stream_slave_driver  extends uvm_driver #(ax_packet);
    1100                                                 `uvm_component_utils(axi4_stream_slave_driver)
    1101                                             	virtual interface axi4s_if axi4s_vif;
    1102                                             	rand int block_cycles;
    1103                                             	constraint c_block_cycles {
    1104                                             		soft block_cycles dist{0:/30,[1:5]:/41, [6:15]:/25, [16:10000]:/4};
    1105                                             	}
    1106                                                 function new(string name, uvm_component parent);
    1107                                                     super.new(name, parent);
    1108                                                 endfunction: new
    1109                                             	function void build_phase(uvm_phase phase);
    1110                                             		super.build_phase(phase);
    1111                                             	endfunction : build_phase
    1112                                                 task run_phase(uvm_phase phase);
    1113                                                     super.run_phase(phase);
    1114                                                     forever begin
    1115                                             			if(axi4s_vif.ARESET_N !== 1) begin
    1116                                             				axi4s_vif.TVALID <= 0;
    1117                                             				@(posedge axi4s_vif.ARESET_N);
    1118                                             			end
    1119                                             			begin //-- Asynchronous reset
    1120                                             				@(negedge axi4s_vif.ARESET_N);
    1121                                             			end
    1122                                             			begin
    1123                                             			@(posedge axi4s_vif.ACLK);
    1124                                             			forever begin
    1125                                                             if (axi4s_vif.TVALID)
    1126                                                                 randcase
    1127                                                                     3 : axi4s_vif.TREADY <= 1;
    1128                                                                     1 : axi4s_vif.TREADY <= 0;
    1129                                                                 endcase
    1130                                                             else 
    1131                                                                 randcase
    1132                                                                     1 : axi4s_vif.TREADY <= 1;
    1133                                                                     1 : axi4s_vif.TREADY <= 0;
    1134                                                                     1 : begin		//-- hold tready at least until tvalid is set
    1135                                                                     axi4s_vif.TREADY <= 0;
    1136                                                                     void'(this.randomize());
    1137                                                                     while (axi4s_vif.TVALID == 0)
    1138                                                                     @(posedge axi4s_vif.ACLK);
    1139                                                                     repeat(block_cycles) @(posedge axi4s_vif.ACLK); //-- wait 2 additional cycles
    1140                                                                     end
    1141                                                                 endcase
    1142                                             			end
    1143                                             			end
    1144                                                     end
    1145                                                 endtask : run_phase
    1146                                             endclass: axi4_stream_slave_driver
    1147                                             //====================================================================================
    1148                                             //------------------------------------------------------------------------------------
    1149                                             //--------------------------------- UVM_MONITORS
    1150                                             //------------------------------------------------------------------------------------
    1151                                             //====================================================================================
    1152                                             // UVM_MONITOR : AXILITE_MONITOR [AXI4_LITE]
    1153                                             class axiLite_monitor extends uvm_monitor;
    1154                                                 protected virtual   axi4l_if axi4l_vif;
    1155                                                 protected int       id;
    1156                                                 uvm_analysis_port #(axiLite_transaction) item_collected_port;
    1157                                                 uvm_analysis_port #(axiLite_transaction) dut_inputs_port; // analysis port for DUT inputs
    1158                                                 uvm_analysis_port #(axiLite_transaction) dut_outputs_port; // analysis port for DUT outputs
    1159                                                 protected axiLite_transaction aL_txn;
    1160                                                 `uvm_component_utils_begin(axiLite_monitor)
    1161                                                     `uvm_field_int(id, UVM_DEFAULT)
    1162                                                 `uvm_component_utils_end
    1163                                                 function new (string name, uvm_component parent);
    1164                                                     super.new(name, parent);
    1165                                                     aL_txn = new();
    1166                                                     item_collected_port = new("item_collected_port", this);
    1167                                                    // dut_inputs_port = new("dut_inputs_port", this); // construct the analysis port
    1168                                                     //dut_outputs_port = new("dut_outputs_port", this); // construct the analysis port
    1169                                                 endfunction
    1170                                                 function void build_phase (uvm_phase phase);
    1171                                                     super.build_phase(phase);
    1172                                                     if(!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1173                                                     `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(), ".axi4l_vif"});
    1174                                                     dut_inputs_port = new(.name("dut_inputs_port"),.parent(this));
    1175                                                     dut_outputs_port = new(.name("dut_outputs_port"),.parent(this));
    1176                                                 endfunction // build_phase
    1177                                                 virtual task run_phase (uvm_phase phase);
    1178                                                     fork
    1179                                                         collect_transactions();
    1180                                                     join
    1181                                                 endtask: run_phase
    1182                                                 virtual protected task collect_transactions();
    1183                                                     bit valid_txn = 0;
    1184                                                     forever begin
    1185                                                         axiLite_transaction tx_in,tx_out,tx_copy;
    1186                                                         tx_in       = axiLite_transaction::type_id::create("tx_in"); 
    1187                                                         tx_out      = axiLite_transaction::type_id::create("tx_out");
    1188                                                         aL_txn      = new();
    1189                                                         if (axi4l_vif.ARESETN == 'b0)
    1190                                                         @(posedge axi4l_vif.ARESETN);
    1191                                                             if (axi4l_vif.AWVALID == 'b1) begin
    1192                                                                 tx_in.WDATA = axi4l_vif.WDATA; 
    1193                                                                 aL_txn.reqWriteRead = WRITE;    
    1194                                                                 aL_txn.addr  = axi4l_vif.AWADDR[7:0];
    1195                                                                 @(posedge axi4l_vif.WVALID);
    1196                                                                 aL_txn.data  = axi4l_vif.WDATA;
    1197                                                                 @(negedge axi4l_vif.WVALID);
    1198                                                                 valid_txn = 1;
    1199                                                             end
    1200                                                         else if (axi4l_vif.ARVALID == 'b1) begin
    1201                                                             tx_out.RDATA = axi4l_vif.RDATA; 
    1202                                                             aL_txn.reqWriteRead = READ;    
    1203                                                             aL_txn.addr  = axi4l_vif.ARADDR[7:0];
    1204                                                             @(posedge axi4l_vif.RVALID);
    1205                                                             aL_txn.data  = axi4l_vif.RDATA;
    1206                                                             @(negedge axi4l_vif.RVALID);
    1207                                                             valid_txn = 1;
    1208                                                         end
    1209                                                         @(posedge axi4l_vif.ACLK);
    1210                                                         //aL_txn.data = axi4l_vif.data;
    1211                                                         //while (axi4l_vif.valid == 'b1) begin
    1212                                                         //@(posedge axi4l_vif.ACLK);
    1213                                                         //aL_txn.cycles++;
    1214                                                         //end
    1215                                                         //aL_txn.cycles--;
    1216                                                          //`uvm_info("axi4l_vif data", aL_txn.sprint(), UVM_LOW);
    1217                                                             if (valid_txn == 'b1 ) begin
    1218                                                                 //`uvm_info("MON", aL_txn.convert2string(), UVM_LOW) 
    1219                                                                 item_collected_port.write(aL_txn);
    1220                                                                 //item_collected_port.write(aL_txn);
    1221                                                             end
    1222                                                         dut_inputs_port.write(tx_in);  
    1223                                                         $cast(tx_copy, tx_out.clone());
    1224                                                         dut_outputs_port.write(tx_copy);             
    1225                                                         valid_txn = 0;
    1226                                                     end
    1227                                                 endtask: collect_transactions
    1228                                             endclass: axiLite_monitor
    1229                                             // UVM_MONITOR : TEMPLATE_MONITOR_PREDICT [TEMPLATE]
    1230                                             //The second axi4_monitor, monitor_afterToDut, will get both inputs 
    1231                                             //and make a prediction of the expected result. 
    1232                                             //The scoreboard will get this predicted result as well and make a comparison between the two values.
    1233                                             class template_monitor_predict extends uvm_monitor;
    1234                                                 `uvm_component_utils(template_monitor_predict)
    1235                                                 uvm_analysis_port#(tp_transaction)  mon_ap_afterToDut;
    1236                                                 virtual tp_if                       tp_vif;
    1237                                                 tp_transaction                      tx_pred;
    1238                                                 tp_transaction                      sa_tx_cg;
    1239                                                 covergroup template_cg;
    1240                                                           ina_cp:     coverpoint sa_tx_cg.ina;
    1241                                                           inb_cp:     coverpoint sa_tx_cg.inb;
    1242                                                     cross ina_cp, inb_cp;
    1243                                                 endgroup: template_cg
    1244                                                 function new(string name, uvm_component parent);
    1245                                                     super.new(name, parent);
    1246                                                     template_cg = new;
    1247                                                 endfunction: new
    1248                                                 function void build_phase(uvm_phase phase);
    1249                                                     super.build_phase(phase);
    1250                                                     void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    1251                                                     mon_ap_afterToDut= new(.name("mon_ap_afterToDut"), .parent(this));
    1252                                                 endfunction: build_phase
    1253                                                 task run_phase(uvm_phase phase);
    1254                                                     integer counter_mon = 0, state = 0;
    1255                                                     tx_pred = tp_transaction::type_id::create(.name("tx_pred"), .contxt(get_full_name()));
    1256                                                     forever begin
    1257                                                         @(posedge tp_vif.sig_clock)
    1258                                                         begin
    1259                                                             if(tp_vif.sig_en_i==1'b1)
    1260                                                             begin
    1261                                                                 state  = 1;
    1262                                                                 tx_pred.ina = 2'b00;
    1263                                                                 tx_pred.inb = 2'b00;
    1264                                                                 tx_pred.outValTbs = 3'b000;
    1265                                                             end
    1266                                                             if(state==1)
    1267                                                             begin
    1268                                                                 tx_pred.ina    = tx_pred.ina << 1;
    1269                                                                 tx_pred.inb    = tx_pred.inb << 1;
    1270                                                                 tx_pred.ina[0] = tp_vif.sig_ina;
    1271                                                                 tx_pred.inb[0] = tp_vif.sig_inb;
    1272                                                                 counter_mon = counter_mon + 1;
    1273                                                                 if(counter_mon==3)
    1274                                                                 begin
    1275                                                                     state = 0;
    1276                                                                     counter_mon = 1;
    1277                                                                     //Predict the result
    1278                                                                     predictor();
    1279                                                                     sa_tx_cg = tx_pred;
    1280                                                                     //Coverage
    1281                                                                     template_cg.sample();
    1282                                                                     //Send the transaction to the analysis port
    1283                                                                     mon_ap_afterToDut.write(tx_pred);
    1284                                                                 end
    1285                                                             end
    1286                                                         end
    1287                                                     end
    1288                                                 endtask: run_phase
    1289                                                 virtual function void predictor();
    1290                                                     tx_pred.outValTbs = tx_pred.ina + tx_pred.inb;//Predicted value
    1291                                                 endfunction: predictor
    1292                                             endclass: template_monitor_predict
    1293                                             // UVM_MONITOR : TEMPLATE_MONITOR_FDUT [TEMPLATE]
    1294                                             //monitor_beforeFromDut, will look solely for the output of the device 
    1295                                             //and it will pass the result to the scoreboard.
    1296                                             class template_monitor_fdut extends uvm_monitor; 
    1297                                                 `uvm_component_utils(template_monitor_fdut)
    1298                                                 uvm_analysis_port#(tp_transaction)  mon_ap_fdut;
    1299                                                 virtual tp_if                       tp_vif;
    1300                                                 function new(string name, uvm_component parent);
    1301                                                     super.new(name, parent);
    1302                                                 endfunction: new
    1303                                                 function void build_phase(uvm_phase phase);
    1304                                                     super.build_phase(phase);
    1305                                                     void'(uvm_resource_db#(virtual tp_if)::read_by_name(.scope("ifs"), .name("tp_if"), .val(tp_vif)));
    1306                                                     mon_ap_fdut = new(.name("mon_ap_fdut"), .parent(this));
    1307                                                 endfunction: build_phase
    1308                                                 task run_phase(uvm_phase phase);
    1309                                                     integer counter_mon = 0, state = 0;
    1310                                                     tp_transaction rx_fdut;
    1311                                                     rx_fdut = tp_transaction::type_id::create(.name("rx_fdut"), .contxt(get_full_name()));
    1312                                                     forever begin
    1313                                                         @(posedge tp_vif.sig_clock)
    1314                                                         begin
    1315                                                             if(tp_vif.sig_en_o==1'b1)begin
    1316                                                                 state = 3;
    1317                                                             end
    1318                                                             if(state==3)begin
    1319                                                                 rx_fdut.outValDut = rx_fdut.outValDut << 1;
    1320                                                                 counter_mon = counter_mon + 1;
    1321                                                                 if (counter_mon==3)begin
    1322                                                                     rx_fdut.outValDut[0]=tp_vif.sig_out;
    1323                                                                 end
    1324                                                                 if(counter_mon==4)begin
    1325                                                                     state       = 0;
    1326                                                                     counter_mon = 0;
    1327                                                                     //Send the transaction to the analysis port
    1328                                                                     mon_ap_fdut.write(rx_fdut);
    1329                                                                 end
    1330                                                             end
    1331                                                         end
    1332                                                     end
    1333                                                 endtask: run_phase
    1334                                             endclass: template_monitor_fdut
    1335                                             // UVM_MONITOR : RGB_MONITOR [RGB]
    1336                                             class rgb_monitor#(parameter set_config cfg = par_1) extends uvm_monitor;
    1337                                                 `uvm_component_param_utils(rgb_monitor#(cfg))
    1338                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1339                                                 int unsigned agent_id = 1;
    1340                                                 virtual rgb_if#(cfg) rgb_vi;
    1341                                                 function new(string name, uvm_component parent);
    1342                                                     super.new(name, parent);
    1343                                                 endfunction: new
    1344                                                 function void build_phase(uvm_phase phase);
    1345                                                     super.build_phase(phase);
    1346                                                     void'(uvm_resource_db#(virtual rgb_if#(cfg))::read_by_name(.scope("ifs"),.name("rgb_if"),.val(rgb_vi)));
    1347                                                     frame_ap = new(.name("frame_ap"),.parent(this));
    1348                                                 endfunction: build_phase
    1349                                                 task run_phase(uvm_phase phase);
    1350                                                 $display("Detected new frame_tx on interface #%d\n", agent_id);
    1351                                                     forever begin
    1352                                                         rgb_transaction#(cfg) frame_tx;
    1353                                                         @rgb_vi.slave_cb;
    1354                                                         frame_tx               = rgb_transaction#(cfg)::type_id::create(.name("frame_tx"));
    1355                                                         frame_tx.iRed          = rgb_vi.slave_cb.iRed;
    1356                                                         frame_tx.iGreen        = rgb_vi.slave_cb.iGreen;
    1357                                                         frame_tx.iBlue         = rgb_vi.slave_cb.iBlue;
    1358                                                         frame_tx.iPixelEn      = rgb_vi.slave_cb.iPixelEn;
    1359                                                         frame_tx.iValid        = rgb_vi.slave_cb.iValid;
    1360                                                         frame_tx.iEof          = rgb_vi.slave_cb.iEof;
    1361                                                         frame_tx.iX            = rgb_vi.slave_cb.iX;
    1362                                                         frame_tx.iY            = rgb_vi.slave_cb.iY;
    1363                                                         frame_ap.write(frame_tx);
    1364                                                     end
    1365                                                 endtask: run_phase
    1366                                             endclass: rgb_monitor
    1367                                                 parameter DATA_BYTES = 16;
    1368                                             // UVM_MONITOR : AX_MODULE_MON [AXI4_STREAM]
    1369                                             class ax_module_mon extends uvm_monitor;
    1370                                             	//-- Basic Module monitor
    1371                                             	ax_packet packet;
    1372                                             	covergroup ax_pkt_cg;
    1373                                             		option.per_instance = 1;
    1374                                             		AX_PACKET_LENGTH : coverpoint packet.packet_length{
    1375                                             			illegal_bins zero_flit_pkt = {0};
    1376                                             			bins pkt_length[] = {[1:9]};
    1377                                             		}
    1378                                             		AX_COMMAND: coverpoint packet.command {
    1379                                             			bins requests[] = {
    1380                                             				AX_WRITE_16,
    1381                                             				AX_WRITE_32,
    1382                                             				AX_WRITE_48,
    1383                                             				AX_WRITE_64,
    1384                                             				AX_WRITE_80,
    1385                                             				AX_WRITE_96,
    1386                                             				AX_WRITE_112,
    1387                                             				AX_WRITE_128,
    1388                                             				AX_MODE_WRITE,
    1389                                             				AX_BIT_WRITE,
    1390                                             				AX_DUAL_8B_ADDI,
    1391                                             				AX_SINGLE_16B_ADDI,
    1392                                             				AX_POSTED_WRITE_16,
    1393                                             				AX_POSTED_WRITE_32,
    1394                                             				AX_POSTED_WRITE_48,
    1395                                             				AX_POSTED_WRITE_64,
    1396                                             				AX_POSTED_WRITE_80,
    1397                                             				AX_POSTED_WRITE_96,
    1398                                             				AX_POSTED_WRITE_112,
    1399                                             				AX_POSTED_WRITE_128,
    1400                                             				AX_POSTED_BIT_WRIT,
    1401                                             				AX_POSTED_BIT_WRIT,
    1402                                             				AX_POSTED_DUAL_8B_ADDI,
    1403                                             				AX_POSTED_SINGLE_16B_ADDI,
    1404                                             				AX_MODE_READ,
    1405                                             				AX_READ_16,
    1406                                             				AX_READ_32,
    1407                                             				AX_READ_48,
    1408                                             				AX_READ_64,
    1409                                             				AX_READ_80,
    1410                                             				AX_READ_96,
    1411                                             				AX_READ_112, 
    1412                                             				AX_READ_128};
    1413                                             			bins response[] = {
    1414                                             				AX_READ_RESPONSE,
    1415                                             				AX_WRITE_RESPONSE,
    1416                                             				AX_MODE_READ_RESPONSE,
    1417                                             				AX_MODE_WRITE_RESPONSE,
    1418                                             				AX_ERROR_RESPONSE
    1419                                             			};
    1420                                             			illegal_bins n_used = default;
    1421                                             		}
    1422                                             		FLIT_DELAY: coverpoint packet.flit_delay{
    1423                                             			bins zero_delay = {0};
    1424                                             			bins small_delay = {[1:3]};
    1425                                             			bins big_delay = {[4:20]};
    1426                                             			bins huge_delay = {[21:$]};
    1427                                             		}
    1428                                             		FLIT_DELAY_COMMAND : cross AX_COMMAND, FLIT_DELAY;
    1429                                             	endgroup
    1430                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1431                                             	int req_rcvd = 0;
    1432                                             	int rsp_rcvd = 0;
    1433                                             	`uvm_component_utils(ax_module_mon)
    1434                                             	function new ( string name = "ax_module_mon", uvm_component parent );
    1435                                             		super.new(name, parent);
    1436                                             		item_collected_port = new("item_collected_port", this);
    1437                                             	endfunction : new
    1438                                             	function void build_phase(uvm_phase phase);
    1439                                             		super.build_phase(phase);
    1440                                             	endfunction : build_phase
    1441                                             endclass: ax_module_mon
    1442                                             // UVM_MONITOR : AXI4_STREAM_MONITOR [AXI4_STREAM]
    1443                                             class axi4_stream_monitor extends uvm_monitor;
    1444                                                 `uvm_component_utils(axi4_stream_monitor)
    1445                                                 virtual interface axi4s_if axi4s_vif;
    1446                                                 uvm_analysis_port #(axi4_stream_valid_cycle)    item_collected_port;
    1447                                                 function new(string name, uvm_component parent);
    1448                                                     super.new(name, parent);
    1449                                                     item_collected_port = new("item_collected_port", this);
    1450                                                 endfunction: new
    1451                                                 function void build_phase(uvm_phase phase);
    1452                                                     super.build_phase(phase);
    1453                                                 endfunction : build_phase
    1454                                                 task run();
    1455                                                     axi4_stream_valid_cycle  vc;
    1456                                                     forever begin
    1457                                                         if (axi4s_vif.ARESET_N !== 1)
    1458                                                         begin
    1459                                                             @(posedge axi4s_vif.ARESET_N);
    1460                                                             `uvm_info(get_type_name(),$psprintf("coming out of reset"), UVM_LOW)
    1461                                                         end
    1462                                                         //fork
    1463                                                             begin //-- Asynchronous reset
    1464                                                                 @(negedge axi4s_vif.ARESET_N);
    1465                                                             end
    1466                                                             forever begin
    1467                                                                 //-- At the positive edge of ACLK
    1468                                                                 @(posedge axi4s_vif.ACLK);
    1469                                                                 //-- Capture valid bus cycles
    1470                                                                 vc = new();
    1471                                                                 if (axi4s_vif.TVALID == 1 && axi4s_vif.TREADY == 1) begin
    1472                                                                     vc.tuser     = axi4s_vif.TUSER;
    1473                                                                     vc.tdata     = axi4s_vif.TDATA;
    1474                                                                     item_collected_port.write(vc);
    1475                                                                     `uvm_info(get_type_name(),$psprintf("valid cycle tuser %0x tdata %0x", vc.tuser, vc.tdata), UVM_HIGH)
    1476                                                                 end
    1477                                                                 //-- used to detect the ax_pkt_delay between packets
    1478                                                                 if (axi4s_vif.TVALID == 0) begin
    1479                                                                     vc.tuser    = 0;
    1480                                                                     vc.tdata    = {DATA_BYTES{16'b0}};;
    1481                                                                     item_collected_port.write(vc);
    1482                                                                 end
    1483                                                             end
    1484                                                         //join_any
    1485                                                         //disable fork;
    1486                                                     end
    1487                                                 endtask : run
    1488                                             endclass: axi4_stream_monitor
    1489                                             // UVM_MONITOR : AXI4_STREAM_AX_MONITOR [AXI4_STREAM]
    1490                                             class axi4_stream_ax_monitor extends  ax_module_mon ;
    1491                                                 `uvm_component_utils(axi4_stream_ax_monitor)
    1492                                             	int FPW ;
    1493                                             	int HEADERS ;
    1494                                             	int TAILS ;
    1495                                             	int VALIDS ;
    1496                                             	int valids_per_cycle 		= 0;
    1497                                             	int current_packet_length 	= 0;
    1498                                             	bit request = 1;
    1499                                             	int flit_delay [$];
    1500                                             	uvm_analysis_port #(ax_packet) item_collected_port;
    1501                                             	uvm_analysis_imp #(axi4_stream_valid_cycle,axi4_stream_ax_monitor) axi4_port;
    1502                                             	int n_valids 				= 0;
    1503                                             	int headers_seen 	= 0;
    1504                                             	int tails_seen 	 	= 0;
    1505                                             	typedef bit [127:0] flit_t;
    1506                                             	flit_t flit_queue[$];
    1507                                             	int packets_per_cycle = 0;
    1508                                             	ax_packet packet_queue[$];
    1509                                             	//-- covergroup definition
    1510                                                 function new(string name, uvm_component parent);
    1511                                                     super.new(name, parent);
    1512                                                     axi4_port = new("axi4_port",this);
    1513                                                 endfunction: new
    1514                                             	function void build_phase(uvm_phase phase);
    1515                                             		super.build_phase(phase);
    1516                                             		FPW 	= DATA_BYTES/16;//-- convert to variables!
    1517                                             		HEADERS = FPW;
    1518                                             		TAILS 	= 2*FPW;
    1519                                             		VALIDS 	= 0;
    1520                                             	endfunction : build_phase
    1521                                             	//-- Stuff FLITs into a FIFO, separate control signals
    1522                                             	function void collect_flits(input axi4_stream_valid_cycle vc);
    1523                                             		//-- read tuser flags for valid flags
    1524                                             		flit_t tmp_flit;
    1525                                             		flit_t current_flit;
    1526                                             		packets_per_cycle = 0;
    1527                                             		valids_per_cycle =0;
    1528                                             		for (int i = 0; i<FPW; i++) begin //-- Check bitvector
    1529                                             		//-- Check if valid
    1530                                             			if (vc.tuser == 1) begin
    1531                                             				valids_per_cycle ++;
    1532                                             				//-- Write 2 flit queue
    1533                                             				for (int b=0; b<16; b++)
    1534                                             					tmp_flit[b] = vc.tdata[16*i+b];
    1535                                             				flit_queue.push_back(tmp_flit);
    1536                                             				if (vc.tuser == 1'b1) begin
    1537                                             					headers_seen++; //-- Complete ax_packets to assemble
    1538                                             					packets_per_cycle++;
    1539                                             					flit_delay.push_back(n_valids);
    1540                                             					n_valids = 0;
    1541                                             				end
    1542                                             				//-- Check if tail for complete ax packet
    1543                                             				if (vc.tuser == 1'b1) begin
    1544                                             					tails_seen++; //-- Complete ax_packets to assemble
    1545                                             					assert (n_valids == 0)
    1546                                             					else `uvm_fatal(get_type_name(), $psprintf("Non valid flits in pkt detected!"))
    1547                                             				end
    1548                                             				//-- Check complete ax packets
    1549                                             				assert (tails_seen<= headers_seen) 
    1550                                             				else  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1551                                             				assert (headers_seen <= tails_seen+1)
    1552                                             				else  `uvm_fatal(get_type_name(), $psprintf("Packet without Tail detected"))
    1553                                             			end
    1554                                             			else begin
    1555                                             				n_valids ++;
    1556                                             			end
    1557                                             		end
    1558                                             		if(|vc.tuser)
    1559                                             			`uvm_info(get_type_name(),$psprintf("%d header and %d tails available", headers_seen, tails_seen)  ,UVM_HIGH)
    1560                                             	endfunction : collect_flits
    1561                                             	//-- Use FLITs to form packets
    1562                                             	function void collect_packet();
    1563                                             		flit_t current_flit;
    1564                                             		bit bitstream[];
    1565                                             		//-- Assemble 1 ax packet
    1566                                             		flit_queue_underflow : assert (flit_queue.size() > 0);
    1567                                             		//-- First flit is always header
    1568                                             		current_flit = flit_queue.pop_front();
    1569                                             		no_length_mismatches_allowed : assert (current_flit[14:11] == current_flit[10:7]); 	//--check internal ax_packet length
    1570                                             		current_packet_length = current_flit[10:7];
    1571                                             		`uvm_info(get_type_name(),$psprintf("packet length %0d ", current_packet_length), UVM_HIGH)
    1572                                             		`uvm_info(get_type_name(),$psprintf("queue size %0d ", flit_queue.size()), UVM_HIGH)
    1573                                             		flit_queue_underflow2 : assert (flit_queue.size() >= current_packet_length - 1);		//--check check ax_packet complete received
    1574                                             		//-- pack flits 2 bitstream
    1575                                             		bitstream = new[current_packet_length*16];
    1576                                             		//-- Pack first flit
    1577                                             		for (int i=0; i<16; i=i+1)
    1578                                             			bitstream[i] = current_flit[i];
    1579                                             		//-- Get and pack the remaining flits
    1580                                             		for (int flit=1; flit < current_packet_length; flit ++) begin
    1581                                             			current_flit = flit_queue.pop_front();
    1582                                             			`uvm_info(get_type_name(),$psprintf("pop flit %0d (%0x)", flit, current_flit), UVM_HIGH)
    1583                                             			for (int i=0; i<16; i=i+1) begin
    1584                                             				bitstream[flit*16+i] = current_flit[i];
    1585                                             			end
    1586                                             		end
    1587                                             		packet = ax_packet::type_id::create("packet", this);
    1588                                             		void'(packet.unpack(bitstream));
    1589                                             		packet.flit_delay = flit_delay.pop_front();
    1590                                             		ax_pkt_cg.sample(); 
    1591                                             		//-- assembled a packet
    1592                                             		headers_seen--;
    1593                                             		tails_seen--; 
    1594                                             		if (packet == null) begin
    1595                                             		  `uvm_fatal(get_type_name(), $psprintf("packet is null"))
    1596                                             		end
    1597                                             		packet_queue.push_back(packet);
    1598                                             		if(packet.get_command_type() == AX_RESPONSE_TYPE)begin
    1599                                             		`uvm_info("RESPONSE collected",$psprintf("Rsp %0d : %s",rsp_rcvd, packet.command.name()), UVM_LOW)
    1600                                             		rsp_rcvd++;
    1601                                             		end else begin
    1602                                             		`uvm_info("REQUEST collected",$psprintf("Req %0d : %s",req_rcvd, packet.command.name()), UVM_LOW)
    1603                                             		req_rcvd++;
    1604                                             		end
    1605                                             		`uvm_info("AXI4 to AX Monitor",$psprintf("\n%s", packet.sprint()), UVM_HIGH)
    1606                                             	endfunction : collect_packet
    1607                                             	function void write(input axi4_stream_valid_cycle vc);
    1608                                             		ax_packet packet;
    1609                                             		collect_flits(vc);
    1610                                             		//`uvm_info(get_type_name(),$psprintf("got %0d tails and %0d flits",tails_seen, flit_queue.size() ), UVM_HIGH)
    1611                                             		//-- Convert flit_queue to ax_packets
    1612                                             		while (tails_seen >0) begin
    1613                                             			collect_packet();		
    1614                                             		end
    1615                                             		//-- If flit queue is not empty -> ax packet striped over 2 axi cycles
    1616                                             		while (packet_queue.size()>0) begin
    1617                                             			packet = packet_queue.pop_front();
    1618                                             			//if (packet.command != AX_ERROR_RESPONSE)
    1619                                             				item_collected_port.write(packet);
    1620                                             		end
    1621                                             	endfunction
    1622                                             	function void check_phase(uvm_phase phase);
    1623                                             		if (flit_queue.size() >0)
    1624                                             			`uvm_fatal(get_type_name(),$psprintf("flit_queue is not empty: %0d", flit_queue.size()))
    1625                                             	endfunction : check_phase
    1626                                             endclass: axi4_stream_ax_monitor
    1627                                             //====================================================================================
    1628                                             //------------------------------------------------------------------------------------
    1629                                             //--------------------------------- UVM_AGENTS
    1630                                             //------------------------------------------------------------------------------------
    1631                                             //====================================================================================
    1632                                             // UVM_AGENT : AXILITE_AGT [AXI4_LITE]
    1633                                             class axiLite_agent extends uvm_agent;
    1634                                                 `uvm_component_utils(axiLite_agent)
    1635                                                 uvm_analysis_port#(axiLite_transaction) item_collected_port;
    1636                                                 axiLite_sequencer       aL_sqr;
    1637                                                 axiLite_driver          aL_drv;
    1638                                                 axiLite_monitor         aL_mon;
    1639                                                 function new (string name, uvm_component parent);
    1640                                                     super.new(name, parent);
    1641                                                 endfunction
    1642                                                 function void build_phase(uvm_phase phase);
    1643                                                     super.build_phase(phase);
    1644                                                     item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1645                                                     aL_mon                 = axiLite_monitor::type_id::create("aL_mon", this);
    1646                                                     if (get_is_active() == UVM_ACTIVE) begin
    1647                                                         aL_sqr = axiLite_sequencer::type_id::create("aL_sqr", this);
    1648                                                         aL_drv = axiLite_driver::type_id::create("aL_drv", this);
    1649                                                     end
    1650                                                 endfunction
    1651                                                 function void connect_phase(uvm_phase phase);
    1652                                                     if (get_is_active() == UVM_ACTIVE) begin
    1653                                                         aL_drv.seq_item_port.connect(aL_sqr.seq_item_export);
    1654                                                         aL_mon.item_collected_port.connect(item_collected_port);
    1655                                                     end
    1656                                                 endfunction
    1657                                             endclass: axiLite_agent
    1658                                             // UVM_AGENT : RGB_AGENT [RGB]
    1659                                             class rgb_agent#(parameter set_config cfg = par_1) extends uvm_agent;
    1660                                                 `uvm_component_param_utils(rgb_agent#(cfg))
    1661                                                 uvm_analysis_port#(rgb_transaction#(cfg)) frame_ap;
    1662                                                 rgb_sequencer   #(cfg)               frame_seqr;
    1663                                                 rgb_driver      #(cfg)               frame_drvr;
    1664                                                 rgb_monitor     #(cfg)               frame_mon;
    1665                                                 function new(string name, uvm_component parent);
    1666                                                     super.new(name, parent);
    1667                                                 endfunction: new
    1668                                                 function void build_phase(uvm_phase phase);
    1669                                                     super.build_phase(phase);
    1670                                                     frame_ap    = new(.name("frame_ap"),.parent(this));
    1671                                                     frame_seqr  = rgb_sequencer#(cfg)  ::type_id::create(.name("frame_seqr"),.parent(this));
    1672                                                     frame_drvr  = rgb_driver   #(cfg)  ::type_id::create(.name("frame_drvr"),.parent(this));
    1673                                                     frame_mon   = rgb_monitor  #(cfg)  ::type_id::create(.name("frame_mon"),.parent(this));
    1674                                                 endfunction: build_phase
    1675                                                 function void connect_phase(uvm_phase phase);
    1676                                                     super.connect_phase(phase);
    1677                                                     frame_drvr.seq_item_port.connect(frame_seqr.seq_item_export);
    1678                                                     frame_mon.frame_ap.connect(frame_ap);
    1679                                                 endfunction: connect_phase
    1680                                             endclass: rgb_agent
    1681                                             // UVM_AGENT : TEMPLATE_AGENT [TEMPLATE]
    1682                                             class template_agent extends uvm_agent;
    1683                                                 `uvm_component_utils(template_agent)
    1684                                                 uvm_analysis_port#(tp_transaction) agent_ap_fdut;
    1685                                                 uvm_analysis_port#(tp_transaction) agent_ap_afterToDut;
    1686                                                 template_sequencer                       sa_seqr;
    1687                                                 template_driver                          sa_drvr;
    1688                                                 template_monitor_fdut                sa_mon_fdut;
    1689                                                 template_monitor_predict              sa_mon_afterToDut;
    1690                                                 function new(string name, uvm_component parent);
    1691                                                     super.new(name, parent);
    1692                                                 endfunction: new
    1693                                                 function void build_phase(uvm_phase phase);
    1694                                                     super.build_phase(phase);
    1695                                                     agent_ap_fdut               = new(.name("agent_ap_fdut"), .parent(this));
    1696                                                     agent_ap_afterToDut         = new(.name("agent_ap_afterToDut"), .parent(this));
    1697                                                     sa_seqr                     = template_sequencer            ::type_id::create(.name("sa_seqr"), .parent(this));
    1698                                                     sa_drvr                     = template_driver               ::type_id::create(.name("sa_drvr"), .parent(this));
    1699                                                     sa_mon_fdut                 = template_monitor_fdut::type_id::create(.name("sa_mon_fdut"), .parent(this));
    1700                                                     sa_mon_afterToDut           = template_monitor_predict   ::type_id::create(.name("sa_mon_afterToDut"), .parent(this));
    1701                                                 endfunction: build_phase
    1702                                                 function void connect_phase(uvm_phase phase);
    1703                                                     super.connect_phase(phase);
    1704                                                     sa_drvr.seq_item_port.connect(sa_seqr.seq_item_export);
    1705                                                     sa_mon_fdut.mon_ap_fdut.connect(agent_ap_fdut);
    1706                                                     sa_mon_afterToDut.mon_ap_afterToDut.connect(agent_ap_afterToDut);
    1707                                                 endfunction: connect_phase
    1708                                             endclass: template_agent
    1709                                             // UVM_AGENT : AXI4_STREAM_MASTER_AGENT [AXI4_STREAM]
    1710                                             class axi4_stream_master_agent extends uvm_agent;
    1711                                                 `uvm_component_utils(axi4_stream_master_agent)
    1712                                                 axi4_stream_config                  axi4_stream_master_cfg;
    1713                                                 axi4_stream_master_driver           axi4_master_driver;
    1714                                                 axi4_stream_master_sequencer        axi_sequencer;
    1715                                                 //axi4_stream_monitor                 axi4_monitor;
    1716                                                 function new(string name, uvm_component parent);
    1717                                                     super.new(name, parent);
    1718                                                 endfunction: new
    1719                                                 function void build_phase(uvm_phase phase);
    1720                                                     super.build_phase(phase);
    1721                                                     if (! uvm_config_db#(axi4_stream_config)::get(.cntxt(this),.inst_name (""),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_master_cfg))) begin
    1722                                                     `uvm_error("axi4_stream_master_agent", "axi4_stream_master_cfg not found")
    1723                                                     end
    1724                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1725                                                         axi_sequencer = axi4_stream_master_sequencer    ::type_id::create(.name("axi_sequencer"),.parent(this));
    1726                                                         axi4_master_driver = axi4_stream_master_driver  ::type_id::create(.name("axi4_master_driver"),.parent(this));
    1727                                                     end
    1728                                                     //axi4_monitor = axi4_stream_monitor::type_id::create(.name("axi4_monitor"),.parent(this));
    1729                                                 endfunction: build_phase
    1730                                                 function void connect_phase(uvm_phase phase);
    1731                                                     super.connect_phase(phase);
    1732                                                     //axi4_monitor.axi4s_vif    = axi4_stream_master_cfg.axi4s_vif;
    1733                                                     if (axi4_stream_master_cfg.master_active == UVM_ACTIVE) begin
    1734                                                         axi4_master_driver.seq_item_port.connect(axi_sequencer.seq_item_export);
    1735                                                         axi4_master_driver.axi4s_vif = axi4_stream_master_cfg.axi4s_vif;
    1736                                                     end
    1737                                                 endfunction: connect_phase
    1738                                             endclass: axi4_stream_master_agent
    1739                                             // UVM_AGENT : AXI4_STREAM_SLAVE_AGENT [AXI4_STREAM]
    1740                                             class axi4_stream_slave_agent extends uvm_agent;
    1741                                                 `uvm_component_utils(axi4_stream_slave_agent)
    1742                                                 axi4_stream_config                  axi4_stream_slave_cfg;
    1743                                                 axi4_stream_slave_driver            axi4_slave_driver;
    1744                                                 function new(string name, uvm_component parent);
    1745                                                     super.new(name, parent);
    1746                                                 endfunction: new
    1747                                                 function void build_phase(uvm_phase phase);
    1748                                                     super.build_phase(phase);
    1749                                                     if (! uvm_config_db#(axi4_stream_config)::get(.cntxt(this),.inst_name (""),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_slave_cfg))) begin
    1750                                                     `uvm_error("axi4_stream_slave_agent", "axi4_stream_slave_cfg not found")
    1751                                                     end
    1752                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1753                                                         axi4_slave_driver = axi4_stream_slave_driver         ::type_id::create(.name("axi4_slave_driver"),.parent(this));
    1754                                                     end
    1755                                                 endfunction: build_phase
    1756                                                 function void connect_phase(uvm_phase phase);
    1757                                                     super.connect_phase(phase);
    1758                                                     if (axi4_stream_slave_cfg.slave_active == UVM_ACTIVE) begin
    1759                                                         axi4_slave_driver.axi4s_vif = axi4_stream_slave_cfg.axi4s_vif;
    1760                                                     end
    1761                                                 endfunction: connect_phase
    1762                                             endclass: axi4_stream_slave_agent
    1763                                             //====================================================================================
    1764                                             //------------------------------------------------------------------------------------
    1765                                             //--------------------------------- UVM_SUBSCRIBERS
    1766                                             //------------------------------------------------------------------------------------
    1767                                             //====================================================================================
    1768                                             // UVM_SUBSCRIBER : AXILITE_FC_SUBSCRIBER [AXI4_LITE]
    1769                                             class axiLite_fc_subscriber extends uvm_subscriber#(axiLite_transaction);
    1770                                                 `uvm_component_utils(axiLite_fc_subscriber)
    1771                                                 axiLite_transaction aL_txn;
    1772                                                 covergroup aL_cg;
    1773                                                     WDATA_cp:            coverpoint aL_txn.WDATA;
    1774                                                     AWADDR_cp:           coverpoint aL_txn.RDATA;
    1775                                                     // cross WDATA_cp, AWADDR_cp;
    1776                                                 endgroup: aL_cg
    1777                                                 function new(string name, uvm_component parent);
    1778                                                     super.new(name, parent);
    1779                                                     aL_cg = new;
    1780                                                 endfunction: new
    1781                                                 function void write(axiLite_transaction t);
    1782                                                     aL_txn = t;
    1783                                                     aL_cg.sample();
    1784                                                 endfunction: write
    1785                                             endclass: axiLite_fc_subscriber
    1786                                             // UVM_SUBSCRIBER : RGB_FC_SUBSCRIBER [RGB]
    1787                                             //The functional coverage subscriber (fc_sucbscriber) identifies 
    1788                                             //the generated frame_tx. 
    1789                                             //The rgb_transaction sent from the axi4_monitor is sampled by the write function.
    1790                                             class rgb_fc_subscriber extends uvm_subscriber#(rgb_transaction);
    1791                                                 `uvm_component_utils(rgb_fc_subscriber)
    1792                                                 rgb_transaction frame_tx;
    1793                                                 covergroup rgb_cg;
    1794                                                     iRed_cp:            coverpoint frame_tx.iRed;
    1795                                                     iGreen_cp:          coverpoint frame_tx.iGreen;
    1796                                                     iBlue_cp:           coverpoint frame_tx.iBlue;
    1797                                                     iPixelEn_cp:        coverpoint frame_tx.iPixelEn;
    1798                                                     iValid_cp:          coverpoint frame_tx.iValid;
    1799                                                     iEof_cp:            coverpoint frame_tx.iEof;
    1800                                                     iX_cp:              coverpoint frame_tx.iX;
    1801                                                     iY_cp:              coverpoint frame_tx.iY;
    1802                                                     cross iRed_cp, iEof_cp;
    1803                                                 endgroup: rgb_cg
    1804                                                 function new(string name, uvm_component parent);
    1805                                                     super.new(name, parent);
    1806                                                     rgb_cg = new;
    1807                                                 endfunction: new
    1808                                                 function void write(rgb_transaction t);
    1809                                                     frame_tx = t;
    1810                                                     rgb_cg.sample();
    1811                                                 endfunction: write
    1812                                             endclass: rgb_fc_subscriber
    1813                                             typedef class rgb_scoreboard;
    1814                                             // UVM_SUBSCRIBER : RGB_SB_SUBSCRIBER [RGB]
    1815                                             class rgb_sb_subscriber extends uvm_subscriber#(rgb_transaction);
    1816                                                 `uvm_component_utils(rgb_sb_subscriber)
    1817                                                 function new(string name, uvm_component parent);
    1818                                                     super.new(name, parent);
    1819                                                 endfunction: new
    1820                                                 function void write(rgb_transaction t);
    1821                                                     rgb_scoreboard frame_sb;
    1822                                                     $cast(frame_sb, m_parent);
    1823                                                     frame_sb.check_rgb_data(t);
    1824                                                 endfunction: write
    1825                                             endclass: rgb_sb_subscriber
    1826                                             //====================================================================================
    1827                                             //------------------------------------------------------------------------------------
    1828                                             //--------------------------------- UVM_SCORECARDS
    1829                                             //------------------------------------------------------------------------------------
    1830                                             //====================================================================================
    1831                                             // UVM_SCORECARD : RGB_SCOREBOARD [RGB]
    1832                                             class rgb_scoreboard extends uvm_scoreboard;
    1833                                                 `uvm_component_utils(rgb_scoreboard)
    1834                                                 uvm_analysis_export#(rgb_transaction)    frame_analysis_export;
    1835                                                 local rgb_sb_subscriber                  frame_sb_sub;
    1836                                                 function new(string name, uvm_component parent);
    1837                                                     super.new(name, parent);
    1838                                                 endfunction: new
    1839                                                 function void build_phase(uvm_phase phase);
    1840                                                     super.build_phase(phase);
    1841                                                     frame_analysis_export = new(.name("frame_analysis_export"),.parent(this));
    1842                                                     frame_sb_sub = rgb_sb_subscriber::type_id::create(.name("frame_sb_sub"),.parent(this));
    1843                                                 endfunction: build_phase
    1844                                                 function void connect_phase(uvm_phase phase);
    1845                                                     super.connect_phase(phase);
    1846                                                     frame_analysis_export.connect(frame_sb_sub.analysis_export);
    1847                                                 endfunction: connect_phase
    1848                                                 virtual function void check_rgb_data(rgb_transaction frame_tx);
    1849                                                     uvm_table_printer p = new;
    1850                                                 endfunction: check_rgb_data
    1851                                             endclass: rgb_scoreboard
    1852                                             // UVM_SCORECARD : TEMPLATE_SCOREBOARD [TEMPLATE]
    1853                                             class template_scoreboard extends uvm_scoreboard;
    1854                                                 `uvm_component_utils(template_scoreboard)
    1855                                                 uvm_analysis_export   #(tp_transaction)     tp_fdut_sb_export;
    1856                                                 uvm_analysis_export   #(tp_transaction)     tp_predict_sb_export;
    1857                                                 uvm_tlm_analysis_fifo #(tp_transaction)     tp_fdut_analysis_fifo;
    1858                                                 uvm_tlm_analysis_fifo #(tp_transaction)     tp_predict_analysis_fifo;
    1859                                                 tp_transaction                              tp_trans_fdut;
    1860                                                 tp_transaction                              tp_trans_predict;
    1861                                                 function new(string name, uvm_component parent);
    1862                                                     super.new(name, parent);
    1863                                                     tp_trans_fdut       = new("tp_trans_fdut");
    1864                                                     tp_trans_predict    = new("tp_trans_predict");
    1865                                                 endfunction: new
    1866                                                 function void build_phase(uvm_phase phase);
    1867                                                     super.build_phase(phase);
    1868                                                     tp_fdut_sb_export               = new("tp_fdut_sb_export", this);
    1869                                                     tp_predict_sb_export            = new("tp_predict_sb_export", this);
    1870                                                     tp_fdut_analysis_fifo           = new("tp_fdut_analysis_fifo", this);
    1871                                                     tp_predict_analysis_fifo        = new("tp_predict_analysis_fifo", this);
    1872                                                 endfunction: build_phase
    1873                                                 function void connect_phase(uvm_phase phase);
    1874                                                     tp_fdut_sb_export.connect(tp_fdut_analysis_fifo.analysis_export);
    1875                                                     tp_predict_sb_export.connect(tp_predict_analysis_fifo.analysis_export);
    1876                                                 endfunction: connect_phase
    1877                                                 task run();
    1878                                                     forever begin
    1879                                                         tp_fdut_analysis_fifo.get(tp_trans_fdut);
    1880                                                         tp_predict_analysis_fifo.get(tp_trans_predict);
    1881                                                         compare();
    1882                                                     end
    1883                                                 endtask: run
    1884                                                 virtual function void compare();
    1885                                                     if(tp_trans_fdut.outValDut == tp_trans_predict.outValTbs) begin
    1886                                                         `uvm_info("Test: OK",$sformatf("DUT = %d PRED = %d",tp_trans_fdut.outValDut,tp_trans_predict.outValTbs), UVM_LOW)
    1887                                                     end else begin
    1888                                                         `uvm_info("Test: Fail",$sformatf("DUT = %d PRED = %d",tp_trans_fdut.outValDut,tp_trans_predict.outValTbs), UVM_LOW)
    1889                                                     end
    1890                                                 endfunction: compare
    1891                                             endclass: template_scoreboard
    1892                                             `uvm_analysis_imp_decl(_beforeFromDut)
    1893                                             `uvm_analysis_imp_decl(_afterToDut)
    1894                                             parameter OPEN_RSP_MODE = 1;
    1895                                             //====================================================================================
    1896                                             //------------------------------------------------------------------------------------
    1897                                             //--------------------------------- UVM_ENVS
    1898                                             //------------------------------------------------------------------------------------
    1899                                             //====================================================================================
    1900                                             // UVM_ENV : TEMPLATE_ENV
    1901                                             class template_env extends uvm_env;
    1902                                                 `uvm_component_utils(template_env)
    1903                                                 protected virtual interface axi4l_if axi4l_vif;
    1904                                                 template_agent              sa_agent;
    1905                                                 template_scoreboard         sa_sb;
    1906                                                 axiLite_agent               aL_agt;
    1907                                                 axiLite_fc_subscriber       aL_fc_sub;
    1908                                                 rgb_agent#(par_1)           frame_agent;
    1909                                                 rgb_fc_subscriber           frame_fc_sub;
    1910                                                 rgb_scoreboard              frame_sb;
    1911                                                 function new(string name, uvm_component parent);
    1912                                                     super.new(name, parent);
    1913                                                 endfunction: new
    1914                                                 function void build_phase(uvm_phase phase);
    1915                                                     super.build_phase(phase);
    1916                                                     sa_agent        = template_agent            ::type_id::create(.name("sa_agent"), .parent(this));
    1917                                                     sa_sb           = template_scoreboard       ::type_id::create(.name("sa_sb"), .parent(this));
    1918                                                     frame_agent     = rgb_agent#(par_1)         ::type_id::create(.name("frame_agent"),.parent(this));
    1919                                                     frame_fc_sub    = rgb_fc_subscriber         ::type_id::create(.name("frame_fc_sub"),.parent(this));
    1920                                                     frame_sb        = rgb_scoreboard            ::type_id::create(.name("frame_sb"),.parent(this));
    1921                                                     if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1922                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axi4l_vif"});
    1923                                                     aL_agt          = axiLite_agent::type_id::create("aL_agt", this);
    1924                                                     if (!uvm_config_db#(virtual axi4l_if)::get(this, "", "axi4l_vif", axi4l_vif))
    1925                                                         `uvm_fatal("NOVIF",{"virtual interface must be set for: ",get_full_name(),".axi4l_vif"});
    1926                                                     aL_fc_sub       = axiLite_fc_subscriber::type_id::create("aL_fc_sub", this);
    1927                                                 endfunction: build_phase
    1928                                                 function void connect_phase(uvm_phase phase);
    1929                                                     super.connect_phase(phase);
    1930                                                     sa_agent.agent_ap_fdut.connect(sa_sb.tp_fdut_sb_export);
    1931                                                     sa_agent.agent_ap_afterToDut.connect(sa_sb.tp_predict_sb_export);
    1932                                                     aL_agt.item_collected_port.connect(aL_fc_sub.analysis_export);
    1933                                                     frame_agent.frame_ap.connect(frame_fc_sub.analysis_export);
    1934                                                     frame_agent.frame_ap.connect(frame_sb.frame_analysis_export);
    1935                                                 endfunction: connect_phase
    1936                                             endclass: template_env
    1937                                             // UVM_ENV : TEMPLATE_ENV
    1938                                             class axi4_stream_env extends uvm_env;
    1939                                                 axi4_stream_agents_config   axi4_stream_cfg;
    1940                                             	axi4_stream_config          axi4_stream_slave_cfg;
    1941                                                 axi4_stream_config          axi4_stream_master_cfg;
    1942                                                 axi4_stream_config          axi4_stream_monitor_cfg;
    1943                                                 axi4_stream_master_agent    axi4_stream_master_agt;
    1944                                                 axi4_stream_slave_agent     axi4_stream_slave_agt;
    1945                                             	axi4_stream_monitor 		monitor;
    1946                                             	axi4_stream_ax_monitor 		axi4_req;
    1947                                                 int id;
    1948                                                 `uvm_component_utils_begin(axi4_stream_env)
    1949                                                     `uvm_field_int(id, UVM_DEFAULT)
    1950                                             		`uvm_field_object(axi4_stream_cfg, UVM_DEFAULT)
    1951                                             		`uvm_field_object(axi4_stream_master_agt, UVM_DEFAULT)
    1952                                             		`uvm_field_object(axi4_stream_slave_agt, UVM_DEFAULT)
    1953                                             		`uvm_field_object(monitor, UVM_DEFAULT)
    1954                                             		`uvm_field_object(axi4_req, UVM_DEFAULT)
    1955                                                 `uvm_component_utils_end
    1956                                                     uvm_analysis_port#(axi4_stream_ax_monitor) item_collected_port;
    1957                                                 function new(string name, uvm_component parent);
    1958                                                     super.new(name, parent);
    1959                                                 endfunction: new
    1960                                                 function void build_phase(uvm_phase phase);
    1961                                                     super.build_phase(phase);
    1962                                                             item_collected_port    = new(.name("item_collected_port"),.parent(this));
    1963                                                     if (!uvm_config_db#(axi4_stream_agents_config)::get(.cntxt(this),.inst_name(""),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg)))begin
    1964                                                         `uvm_error("axi4_stream_agents_config", "axi4_stream_cfg not found")
    1965                                                     end
    1966                                                     if (axi4_stream_cfg.has_axi4_agent1) begin
    1967                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_master_agt"),.field_name("axi4_stream_master_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1968                                                         axi4_stream_master_agt=axi4_stream_master_agent::type_id::create(.name("axi4_stream_master_agt"),.parent(this));
    1969                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_stream_slave_agt"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1970                                                         axi4_stream_slave_agt=axi4_stream_slave_agent::type_id::create(.name("axi4_stream_slave_agt"),.parent(this));
    1971                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1972                                                         monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1973                                                         uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("axi4_req"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1974                                                         axi4_req=axi4_stream_ax_monitor::type_id::create(.name("axi4_req"),.parent(this));
    1975                                                         //uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1976                                                         //monitor=axi4_stream_slave_agent::type_id::create(.name("monitor"),.parent(this));
    1977                                                         //uvm_config_db#(axi4_stream_config)::set(.cntxt(this),.inst_name("monitor"),.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1978                                                         //monitor=axi4_stream_monitor::type_id::create(.name("monitor"),.parent(this));
    1979                                                         //uvm_config_db#(axi4_stream_config)::set(this, "monitor",.field_name("axi4_stream_slave_cfg"),.value(axi4_stream_cfg.axi4_agent_handler1));
    1980                                                     end
    1981                                                 endfunction: build_phase
    1982                                                 function void connect_phase(uvm_phase phase);
    1983                                                    // axi4_stream_ax_monitor	 axi4_ax_req_mon;
    1984                                                     super.connect_phase(phase);
    1985                                                     monitor.axi4s_vif    = axi4_stream_cfg.axi4_agent_handler1.axi4s_vif;
    1986                                                     //axi4_req    = axi4_stream_cfg.axi4_agent_handler1.axi4s_vif;
    1987                                                     //monitor.item_collected_port.connect(item_collected_port);
    1988                                                     //axi4_req.item_collected_port.connect(axi4_ax_req_mon.axi4_port);	
    1989                                                     //axi4_req.item_collected_port.connect(axi4_stream_cfg.axi4_agent_handler1.axi4s_vif);
    1990                                                     //monitor.axi4s_vif    = axi4_stream_master_agt.axi4s_vif;
    1991                                                 endfunction: connect_phase
    1992                                             endclass: axi4_stream_env
    1993                                             //====================================================================================
    1994                                             //------------------------------------------------------------------------------------
    1995                                             //--------------------------------- UVM_TESTS
    1996                                             //------------------------------------------------------------------------------------
    1997                                             //====================================================================================
    1998                                             // UVM_TEST : TEMPLATE_TEST [TEMPLATE]
    1999                                             class template_test extends uvm_test;
    2000                                                 `uvm_component_utils(template_test)
    2001                                                 template_env sa_env;
    2002                                                 function new(string name, uvm_component parent);
    2003                                                     super.new(name, parent);
    2004                                                 endfunction: new
    2005                                                 function void build_phase(uvm_phase phase);
    2006                                                     super.build_phase(phase);
    2007                                                     sa_env = template_env::type_id::create(.name("sa_env"), .parent(this));
    2008                                                 endfunction: build_phase
    2009                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2010                                                     super.end_of_elaboration_phase(phase);
    2011                                                     this.print();
    2012                                                     factory.print();
    2013                                                 endfunction
    2014                                                 task run_phase(uvm_phase phase);
    2015                                                     template_sequence sa_seq;
    2016                                                     phase.raise_objection(.obj(this));
    2017                                                         sa_seq = template_sequence::type_id::create(.name("sa_seq"), .contxt(get_full_name()));
    2018                                                         assert(sa_seq.randomize());
    2019                                                     sa_seq.start(sa_env.sa_agent.sa_seqr);
    2020                                                     phase.drop_objection(.obj(this));
    2021                                                 endtask: run_phase
    2022                                             endclass: template_test
    2023                                             // UVM_TEST : AXILITE_TEST [AXI4_LITE]
    2024                                             class axiLite_test extends uvm_test;
    2025                                                 `uvm_component_utils(axiLite_test)
    2026                                                 template_env aL_env;
    2027                                                 function new(string name, uvm_component parent);
    2028                                                     super.new(name, parent);
    2029                                                 endfunction: new
    2030                                                 function void build_phase(uvm_phase phase);
    2031                                                     super.build_phase(phase);
    2032                                                     begin
    2033                                                         axiLite_configuration axiLite_cfg;
    2034                                                         axiLite_cfg = new;
    2035                                                         assert(axiLite_cfg.randomize());
    2036                                                         uvm_config_db#(axiLite_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(axiLite_cfg));
    2037                                                         aL_env = template_env::type_id::create(.name("aL_env"),.parent(this));
    2038                                                     end
    2039                                                 endfunction: build_phase
    2040                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2041                                                     super.end_of_elaboration_phase(phase);
    2042                                                     this.print();
    2043                                                     factory.print();
    2044                                                 endfunction
    2045                                                 task run_phase(uvm_phase phase);
    2046                                                     axiLite_directed_sequence    axiLite_seq;
    2047                                                     phase.raise_objection(.obj(this));
    2048                                                     axiLite_seq = axiLite_directed_sequence::type_id::create(.name("axiLite_seq"));
    2049                                                     assert(axiLite_seq.randomize());
    2050                                                     `uvm_info("aL_env", { "\n", axiLite_seq.sprint() }, UVM_LOW)
    2051                                                     axiLite_seq.start(aL_env.aL_agt.aL_sqr);
    2052                                                     phase.drop_objection(.obj(this));
    2053                                                 endtask: run_phase
    2054                                             endclass: axiLite_test
    2055                                             // UVM_TEST : RGB_TEST1 [RGB]
    2056                                             class rgb_test1 extends uvm_test;
    2057                                                 `uvm_component_utils(rgb_test1)
    2058                                                 template_env frame_env;
    2059                                                 function new(string name, uvm_component parent);
    2060                                                     super.new(name, parent);
    2061                                                 endfunction
    2062                                                 function void build_phase(uvm_phase phase);
    2063                                                     super.build_phase(phase);
    2064                                                     begin
    2065                                                         rgb_configuration frame_cfg;
    2066                                                         frame_cfg = new;
    2067                                                         assert(frame_cfg.randomize());
    2068                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2069                                                         frame_env = template_env::type_id::create(.name("frame_env"),.parent(this));
    2070                                                     end
    2071                                                 endfunction: build_phase
    2072                                                 task run_phase(uvm_phase phase);
    2073                                                     top_sequence        random_sqr;
    2074                                                     uvm_component       component;
    2075                                                     rgb_sequencer       sequencer;
    2076                                                     random_sqr = top_sequence::type_id::create("random_sqr");
    2077                                                     if( !random_sqr.randomize() ) 
    2078                                                         `uvm_error("", "Randomize failed")
    2079                                                     random_sqr.starting_phase = phase;
    2080                                                     component = uvm_top.find("*.frame_seqr");
    2081                                                     if ($cast(sequencer, component))
    2082                                                         random_sqr.start(sequencer);
    2083                                                 endtask: run_phase
    2084                                             endclass: rgb_test1
    2085                                             // UVM_TEST : RGB_TEST2 [RGB]
    2086                                             class rgb_test2 extends rgb_test1;
    2087                                                 `uvm_component_utils(rgb_test2)
    2088                                                 function new (string name, uvm_component parent);
    2089                                                     super.new(name, parent);
    2090                                                 endfunction : new
    2091                                                 function void start_of_simulation_phase(uvm_phase phase);
    2092                                                     super.start_of_simulation_phase(phase);
    2093                                                     random_sequence_r1#(par_1)::type_id::set_type_override(random_sequence_r2::get_type());
    2094                                                 endfunction : start_of_simulation_phase
    2095                                             endclass: rgb_test2
    2096                                             class rgb_test extends uvm_test;
    2097                                                 `uvm_component_utils(rgb_test)
    2098                                                 template_env frame_env;
    2099                                                 rgb_agent#(par_1) frame_agent;
    2100                                                 rgb_agent#(par_2) frame_agent_b;
    2101                                                 rgb_agent#(par_3) frame_agent_cs[4];
    2102                                                 function new(string name, uvm_component parent);
    2103                                                     super.new(name, parent);
    2104                                                 endfunction
    2105                                                 function void build_phase(uvm_phase phase);
    2106                                                     super.build_phase(phase);
    2107                                                     begin
    2108                                                         rgb_configuration frame_cfg;
    2109                                                         frame_cfg = new;
    2110                                                         assert(frame_cfg.randomize());
    2111                                                         uvm_config_db#(rgb_configuration)::set(.cntxt(this),.inst_name("*"),.field_name("config"),.value(frame_cfg));
    2112                                                         frame_env       = template_env::type_id::create(.name("frame_env"),.parent(this));
    2113                                                         frame_agent     = rgb_agent#(par_1)::type_id::create("frame_agent", this);
    2114                                                         frame_agent_b   = rgb_agent#(par_2)::type_id::create("frame_agent_b", this);
    2115                                                         foreach (frame_agent_cs[i])
    2116                                                             frame_agent_cs[i] = rgb_agent#(par_3)::type_id::create($sformatf("frame_agent_cs_%0d", i), this);
    2117                                                     end
    2118                                                 endfunction: build_phase
    2119                                                function void end_of_elaboration_phase(uvm_phase phase);
    2120                                                   uvm_phase run_phase = uvm_run_phase::get();
    2121                                                   run_phase.phase_done.set_drain_time(this, 100us);
    2122                                                   frame_agent.frame_mon.agent_id = 0;
    2123                                                   frame_agent_b.frame_mon.agent_id = 1;
    2124                                                   foreach (frame_agent_cs[i])
    2125                                                     frame_agent_cs[i].frame_mon.agent_id = i + 2;
    2126                                                     this.print();
    2127                                                     factory.print();
    2128                                                endfunction
    2129                                                task run_phase(uvm_phase phase);
    2130                                                   super.run_phase(phase);
    2131                                                   phase.raise_objection(this);
    2132                                                   fork
    2133                                                      repeat (3) begin
    2134                                                         rgb_random_sequence#(par_1) rgb_seq_a = rgb_random_sequence#(par_1)::type_id::create("rgb_seq_a");
    2135                                                         rgb_seq_a.start(frame_env.frame_agent.frame_seqr);
    2136                                                      end
    2137                                                      repeat (3) begin
    2138                                                         rgb_random_sequence#(par_2) rgb_seq_b = rgb_random_sequence#(par_2)::type_id::create("rgb_seq_b");
    2139                                                         rgb_seq_b.start(frame_agent_b.frame_seqr);
    2140                                                      end
    2141                                                      begin
    2142                                                         foreach (frame_agent_cs[i])
    2143                                                            fork
    2144                                                               automatic int unsigned agent_id = i;
    2145                                                               repeat (3) begin
    2146                                                                  rgb_random_sequence#(par_3) rgb_seq_c = rgb_random_sequence#(par_3)::type_id::create("rgb_seq_c");
    2147                                                                  rgb_seq_c.start(frame_agent_cs[agent_id].frame_seqr);
    2148                                                               end
    2149                                                            join_none
    2150                                                         wait fork;
    2151                                                      end
    2152                                                   join
    2153                                                   phase.drop_objection(this);
    2154                                                endtask
    2155                                             // task run_phase(uvm_phase phase);
    2156                                                 // rgb_random_sequence#(par_1)    random_sqr;
    2157                                                 // phase.raise_objection(.obj(this));
    2158                                                 // random_sqr = rgb_random_sequence#(par_1)::type_id::create(.name("random_sqr"));
    2159                                                 // assert(random_sqr.randomize());
    2160                                                 // `uvm_info("aL_env", { "\n", random_sqr.sprint() }, UVM_LOW)
    2161                                                 // random_sqr.start(frame_env.frame_agent.frame_seqr);
    2162                                                 // phase.drop_objection(.obj(this));
    2163                                             // endtask: run_phase
    2164                                             endclass: rgb_test
    2165                                             class axi4_stream_test extends uvm_test;
    2166                                                 `uvm_component_utils(axi4_stream_test)
    2167                                                 axi4_stream_env             axi4_env;
    2168                                                 axi4_stream_agents_config   axi4_stream_cfg;
    2169                                                 axi4_stream_config          axi4_agent_handler1;
    2170                                                 function new(string name, uvm_component parent);
    2171                                                     super.new(name, parent);
    2172                                                 endfunction: new
    2173                                                 function void build_phase(uvm_phase phase);
    2174                                                     super.build_phase(phase);
    2175                                                     axi4_env        = axi4_stream_env            ::type_id::create(.name("axi4_env"), .parent(this));
    2176                                                     axi4_stream_cfg        = axi4_stream_agents_config  ::type_id::create("axi4_stream_cfg");
    2177                                                     axi4_agent_handler1 = axi4_stream_config         ::type_id::create("axi4_agent_handler1");
    2178                                                     if (! uvm_config_db#(virtual axi4s_if) ::get(.cntxt(this),.inst_name(""),.field_name("axi4s_vif"),.value(axi4_agent_handler1.axi4s_vif))) begin
    2179                                                         `uvm_error("axi4s_if", "axi4s_vif not found")
    2180                                                     end
    2181                                                     axi4_stream_cfg.axi4_agent_handler1 = axi4_agent_handler1;
    2182                                                     uvm_config_db#(axi4_stream_agents_config)::set(.cntxt(this),.inst_name("*"),.field_name("axi4_stream_cfg"),.value(axi4_stream_cfg));
    2183                                                 endfunction: build_phase
    2184                                                 function void end_of_elaboration_phase(uvm_phase phase);
    2185                                                     super.end_of_elaboration_phase(phase);
    2186                                                     this.print();
    2187                                                     factory.print();
    2188                                                 endfunction
    2189                                                 task run_phase(uvm_phase phase);
    2190                                                     axi4_stream_master_sequence axi4_sequencer;
    2191                                                     phase.raise_objection(.obj(this));
    2192                                                         axi4_sequencer = axi4_stream_master_sequence::type_id::create(.name("axi4_sequencer"), .contxt(get_full_name()));
    2193                                                         assert(axi4_sequencer.randomize());
    2194                                                     axi4_sequencer.start(axi4_env.axi4_stream_master_agt.axi_sequencer);
    2195                                                     phase.drop_objection(.obj(this));
    2196                                                 endtask: run_phase
    2197                                             endclass: axi4_stream_test
    2198                                             endpackage: socTest_pkg
    2199                                             //====================================================================================
    2200                                             //------------------------------------------------------------------------------------
    2201                                             //--------------------------------- INTERFACES
    2202                                             //------------------------------------------------------------------------------------
    2203                                             //====================================================================================
    2204                                             // INTERFACE : TEMPLATE_IF [TEMPLATE]
    2205                                             interface tp_if;
    2206                                                 logic        sig_clock;
    2207                                                 logic        sig_ina;
    2208                                                 logic        sig_inb;
    2209                                                 logic        sig_en_i;
    2210                                                 logic        sig_en_o;
    2211                                                 logic        sig_out;
    2212                                                 modport      templateSlave (input sig_clock,sig_ina,sig_inb,sig_en_i,output sig_en_o,sig_out);
    2213                                             endinterface: tp_if
    2214                                             // INTERFACE : AXILITE_IF [AXI4_LITE]
    2215                                             interface axi4l_if(input bit ACLK,ARESETN);
    2216                                                 logic [7:0]     AWADDR;
    2217                                                 logic [ 2:0]    AWPROT;
    2218                                                 logic           AWVALID;
    2219                                                 logic           AWREADY;
    2220                                                 logic [31:0]    WDATA;
    2221                                                 logic [ 3:0]    WSTRB;
    2222                                                 logic           WVALID;
    2223                                                 logic           WREADY;
    2224                                                 logic [1:0]     BRESP;
    2225                                                 logic           BVALID;
    2226                                                 logic           BREADY;
    2227                                                 logic [7:0]     ARADDR;
    2228                                                 logic [ 2:0]    ARPROT;
    2229                                                 logic           ARVALID;
    2230                                                 logic           ARREADY;
    2231                                                 logic [31:0]    RDATA;
    2232                                                 logic [ 1:0]    RRESP;
    2233                                                 logic           RVALID;
    2234                                                 logic           RREADY;
    2235                                                 modport         ConfigMaster(input ACLK,ARESETN,AWADDR,AWPROT,AWVALID,WDATA,WSTRB,WVALID,BREADY,ARADDR,ARPROT,ARVALID,RREADY, output  AWREADY,ARREADY,RDATA,RRESP,RVALID,WREADY,BRESP,BVALID);
    2236                                             endinterface: axi4l_if
    2237                                             // INTERFACE : RGB_IF [RGB]
    2238                                             interface rgb_if(input bit clk);
    2239                                                 logic [7:0]  iRed;
    2240                                                 logic [7:0]  iGreen;
    2241                                                 logic [7:0]  iBlue;
    2242                                                 logic        iValid;
    2243                                                 logic        iPixelEn;
    2244                                                 logic        iEof;
    2245                                                 int unsigned iX;
    2246                                                 int unsigned iY;
    2247                                                 logic [7:0]  oRed;
    2248                                                 logic [7:0]  oGreen;
    2249                                                 logic [7:0]  oBlue;
    2250                                                 logic        oValid;
    2251            1                          1         clocking master_cb @ (posedge clk);
    2252                                                     default input #1step output #1ns;
    2253                                                     output iPixelEn,iX,iY,iRed,iGreen,iBlue,iValid,iEof;
    2254            1                          1             input  oRed;
    2255                                                 endclocking: master_cb
    2256            1                          1         clocking slave_cb @ (posedge clk);
    2257                                                     default input #1step output #1ns;
    2258            1                          1             input  iX,iY,iRed,iGreen,iBlue,iPixelEn,iValid,iEof;
    2259                                                     output oRed;
    2260                                                 endclocking: slave_cb
    2261                                                 modport master_mp(input clk, output  oRed,oGreen,oBlue,oValid);
    2262                                                 modport slave_mp (input clk,iRed,iGreen,iBlue,iValid,iPixelEn,iEof,iX,iY,output oRed,oGreen,oBlue,oValid);
    2263                                                 modport master_sync_mp(clocking master_cb);
    2264                                                 modport slave_sync_mp (clocking slave_cb);
    2265                                             endinterface: rgb_if
    2266                                             interface axi4s_if(input bit ACLK,ARESET_N);
    2267                                                 parameter DATA_BYTES = 16;
    2268                                             	logic TVALID;	// Master valid
    2269                                             	logic TLAST;	// Master TLAST
    2270                                             	logic TREADY;	// Slave ready
    2271                                             	logic [DATA_BYTES-1:0] TDATA;	//-- Master data
    2272                                             	logic TUSER;	//-- Master sideband signals
    2273                                             	//--
    2274                                                 //--DEBUG signals
    2275                                                 //--
    2276                                             	//logic [DATA_BYTES/16-1:0] DEBUG_VALIDS;		//-- contains the AX-VALID Flags
    2277                                             	//logic [DATA_BYTES/16-1:0] DEBUG_HEADERS;	//-- contains the AX-HEADER Flags
    2278                                             	//logic [DATA_BYTES/16-1:0] DEBUG_TAILS;		//-- contains the AX-TAIL Flags
    2279                                             	////-- assigning the debug signals to TUSER
    2280                                             	//assign DEBUG_VALIDS     = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2281                                             	//assign DEBUG_HEADERS    = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2282                                             	//assign DEBUG_TAILS      = (DATA_BYTES /16)-1: (DATA_BYTES /16);
    2283                                             	//--
    2284                                             	//-- Interface Coverage
    2285                                             	//--
    2286                                             	covergroup axi4_cg @ (posedge ACLK);
    2287                                             		option.per_instance = 1;
    2288                                             		T_VALID : coverpoint TVALID;
    2289                                             		T_READY : coverpoint TREADY;
    2290                                             		//-- cover the amount of consecutive AXI4 transactions
    2291                                             		CONSECUTIVE_TRANSACTIONS: coverpoint {TVALID , TREADY}{
    2292                                             			bins transactions_single	= (0,1,2 =>3			=> 0,1,2);
    2293                                             			bins transactions_1_5[] 	= (0,1,2 =>3[*2:10] 	=> 0,1,2);
    2294                                             			bins transactions_11_50[] 	= (0,1,2 =>3[*11:50]	=> 0,1,2);
    2295                                             			bins transactions_huge 		= (0,1,2 =>3[*51:100000]=> 0,1,2);
    2296                                             		}
    2297                                             		//-- cover the waiting time after TVALID is set until TREADY in clock cycles
    2298                                             		TRANSACTION_WAITING: coverpoint {TVALID , TREADY}{
    2299                                             			bins zero_waiting_time		= (0,1				=> 3);
    2300                                             			bins low_waiting_time[]		= (2[*1:5]			=> 3);
    2301                                             			bins medium_waiting_time[]	= (2[*6:15] 		=> 3);
    2302                                             			bins high_waiting_time		= (2[*16:100000] 	=> 3);
    2303                                             			illegal_bins illegal		= (2				=> 0);
    2304                                             		}
    2305                                             		//-- Pause between Transactions
    2306                                             		TRANSACTION_PAUSE: coverpoint {TVALID , TREADY}{
    2307                                             			bins low_waiting_time[]		= (3 => 0[*1:5]		=> 2,3);
    2308                                             			bins medium_waiting_time[]	= (3 => 0[*6:15] 	=> 2,3);
    2309                                             			bins high_waiting_time		= (3 => 0[*16:100] 	=> 2,3);
    2310                                             		}
    2311                                             		//-- cover the time TREADY is active until deassertion or TVALID in clock cycles
    2312                                             		READY_WITHOUT_VALID: coverpoint {TVALID , TREADY}{
    2313                                             			bins short_ready_time[]		= (1[*1:5]  	=> 3,0);
    2314                                             			bins medium_ready_time[]	= (1[*6:15] 	=> 3,0);
    2315                                             			bins high_ready_time		= (1[*16:100000]=> 3,0);
    2316                                             		}
    2317                                             		//--cover all available transitions of TVALID/TREADY
    2318                                             		CASES_VALID_READY : cross T_VALID, T_READY;
    2319                                             		TRANSITIONS: coverpoint {TVALID, TREADY}{
    2320                                             			bins transition[] = ( 0,1,3 => [0:3]), (2 => 2,3) ;
    2321                                             		}
    2322                                             		//-- cover active VALID Flags
    2323                                             		//VALID_FLAGS : coverpoint DEBUG_VALIDS;
    2324                                             		//VALID_TRANSITIONS : coverpoint DEBUG_VALIDS {
    2325                                             		//	bins transition [] = ( [1:(1<<($size(DEBUG_VALIDS))) -1] => [1:(1<<($size(DEBUG_VALIDS))) -1] );
    2326                                             		//}
    2327                                             		//-- cover active HEADER Flags
    2328                                             		//HDR_FLAGS   : coverpoint DEBUG_HEADERS;
    2329                                             		//HDR_TRANSITIONS : coverpoint DEBUG_HEADERS {
    2330                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_HEADERS)) -1] => [1:1<<($size(DEBUG_HEADERS)) -1] );
    2331                                             		//}
    2332                                             		////-- cover active TAIL Flags
    2333                                             		//TAIL_FLAGS  : coverpoint DEBUG_TAILS;
    2334                                             		//TAIL_TRANSITIONS : coverpoint DEBUG_TAILS {
    2335                                             		//	bins transition [] = ( [1:1<<($size(DEBUG_TAILS)) -1] => [1:1<<($size(DEBUG_TAILS)) -1] );
    2336                                             		//}
    2337                                             		//CROSS_HDR_TAILS : cross HDR_FLAGS, TAIL_FLAGS;
    2338                                             		//HDR_TAILS : coverpoint { DEBUG_HEADERS != {$size(DEBUG_HEADERS){1'b0}} ,DEBUG_TAILS != {$size(DEBUG_TAILS){1'b0}}   };
    2339                                             	endgroup
    2340                                             	//-- creating an instance of the covergroup
    2341            1                          1     	axi4_cg axi4 = new();
    2342                                             	property reset_synchronous_deassert_p;
    2343                                             		@(edge ACLK)
    2344                                             		!ARESET_N |-> ARESET_N[->1];
    2345                                             	endproperty
    2346                                             	// chk_reset_tvalid	: assert property (
    2347                                             //	 	//-- TVALID must be inactive during Reset
    2348                                             //	 	@(posedge ACLK)
    2349                                             //	 	!ARESET_N |-> TVALID == 1'b0
    2350                                             //	 );
    2351                                             	chk_valid_hold 		: assert property (
    2352                                             		//-- if TVALID is set it must be active until TREADY
    2353                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2354                                             		(TVALID == 1 && TREADY == 0) |=> (TVALID==1)
    2355                                             	);
    2356                                             	//chk_valid_headers 	: assert property (
    2357                                             	//	//-- check if HEADER Flags are a subset of VALID Flags
    2358                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2359                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_HEADERS
    2360                                             	//						  == DEBUG_VALIDS)
    2361                                             	//);
    2362                                             	//chk_valid_tails 	: assert property (
    2363                                             	//	//-- check if TAIL Flags are a subset of VALID Flags
    2364                                             	//	@(posedge ACLK) disable iff (!ARESET_N)
    2365                                             	//	(TVALID == 1'b1)    |-> (DEBUG_VALIDS | DEBUG_TAILS
    2366                                             	//						  == DEBUG_VALIDS)
    2367                                             	//);
    2368                                             	//check_spanning_ax_pkts	: assert property (
    2369                                             	//	//-- check that TVALID stays high if a ax_packet ranges over multiple axi cycles
    2370                                             	//	//-- starts if more header than tails
    2371                                             	//	//-- completes if more tails than header
    2372                                             	//	@(posedge ACLK  )  disable iff (!ARESET_N)
    2373                                             	//		(TVALID &&						( $countones(DEBUG_HEADERS) > $countones(DEBUG_TAILS) ))
    2374                                             	//		|=>	(TVALID == 1) throughout 	( $countones(DEBUG_HEADERS) < $countones(DEBUG_TAILS) )[->1]
    2375                                             	//);
    2376                                             	time clk_rise;
    2377                                             	time reset_rise;
    2378            1                        100     	always @(posedge ACLK) begin	
    2379                                             		if(ARESET_N == 0)
    2380            1                         99     			clk_rise <= $time();
    2381                                             	end
    2382            1                          1     	always @(posedge ARESET_N) begin
    2383            1                          1     		reset_rise <= $time();
    2384                                             	end
    2385                                             	//TODO TODO ADD
    2386                                             	// check_sync_reset : assert property (
    2387                                             	// 	@(posedge ACLK)
    2388                                             	// 	$rose(ARESET_N) |=> (reset_rise == clk_rise)
    2389                                             	// 	);
    2390                                             	property data_hold_p;
    2391                                             		//-- if TVALID is set TDATA must not be changed until TREADY
    2392                                             		logic [DATA_BYTES-1:0] m_data;
    2393                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2394                                             			(TVALID == 1 && TREADY == 0,m_data = TDATA) |=> (TDATA == m_data);
    2395                                             	endproperty : data_hold_p
    2396                                             	property user_hold_p;
    2397                                             		//-- if TVALID is set TUSER must not be changed until TREADY
    2398                                             		logic  m_user;
    2399                                             		@(posedge ACLK) disable iff(!ARESET_N)
    2400                                             			(TVALID == 1 && TREADY == 0,m_user = TUSER) |=> (TUSER == m_user);
    2401                                             	endproperty : user_hold_p
    2402                                             	chk_data_hold 		: assert property(   data_hold_p);
    2403                                             	chk_user_hold		: assert property(   user_hold_p);
    2404                                                 modport      rx_channel (input ACLK,ARESET_N,TVALID,TUSER,TLAST,TDATA,output TREADY);
    2405                                             endinterface : axi4s_if
    2406                                             //====================================================================================
    2407                                             //------------------------------------------------------------------------------------
    2408                                             //--------------------------------- MODULES
    2409                                             //------------------------------------------------------------------------------------
    2410                                             //====================================================================================
    2411                                             // MODULE : ADDER [TEMPLATE]
    2412                                             module adder(tp_if.templateSlave tp_vif);
    2413                                                 import socTest_pkg::*;
    2414                                                 template dut (
    2415                                                .clk         (tp_vif.sig_clock),
    2416                                                .en_i        (tp_vif.sig_en_i),
    2417                                                .ina         (tp_vif.sig_ina),
    2418                                                .inb         (tp_vif.sig_inb),
    2419                                                .en_o        (tp_vif.sig_en_o),
    2420                                                .out_c       (tp_vif.sig_out));
    2421                                             endmodule: adder
    2422                                             // MODULE : VFPCONFIGDUT [AXI4_LITE] 
    2423                                             module vfpConfigDut(axi4l_if.ConfigMaster axi4l_vif,axi4s_if.rx_channel axi4s_vif,tp_if.templateSlave tp_vif);
    2424                                                 import socTest_pkg::*;
    2425                                                 VFP_v1_0 dutVFP_v1Inst (
    2426                                                 //d5m input
    2427                                                 .pixclk                (tp_vif.sig_clock),//(axi4l_vif.ACLK   ),
    2428                                                 .ifval                 (tp_vif.sig_en_i),//(axi4l_vif.ARESETN),
    2429                                                 .ilval                 (tp_vif.sig_ina),//(axi4l_vif.AWADDR ),
    2430                                                 .idata                 (),//(axi4l_vif.AWPROT ),
    2431                                                 //tx channel           (),//
    2432                                                 .rgb_m_axis_aclk       (axi4s_vif.ACLK     ),
    2433                                                 .rgb_m_axis_aresetn    (axi4s_vif.ARESET_N ),
    2434                                                 .rgb_m_axis_tready     (),//(axi4l_vif.AWADDR ),
    2435                                                 .rgb_m_axis_tvalid     (),//(axi4l_vif.AWPROT ),
    2436                                                 .rgb_m_axis_tlast      (),//(axi4l_vif.AWVALID),
    2437                                                 .rgb_m_axis_tuser      (),//(axi4l_vif.AWREADY),
    2438                                                 .rgb_m_axis_tdata      (),//(axi4l_vif.WDATA  ),
    2439                                                 //rx channel
    2440                                                 .rgb_s_axis_aclk       (axi4s_vif.ACLK     ),
    2441                                                 .rgb_s_axis_aresetn    (axi4s_vif.ARESET_N ),
    2442                                                 .rgb_s_axis_tready     (axi4s_vif.TREADY   ),
    2443                                                 .rgb_s_axis_tvalid     (axi4s_vif.TVALID   ),
    2444                                                 .rgb_s_axis_tlast      (axi4s_vif.TLAST    ),
    2445                                                 .rgb_s_axis_tuser      (axi4s_vif.TUSER    ),
    2446                                                 .rgb_s_axis_tdata      (axi4s_vif.TDATA    ),
    2447                                                 //destination channel  (),//
    2448                                                 .m_axis_mm2s_aclk      (axi4s_vif.ACLK     ),
    2449                                                 .m_axis_mm2s_aresetn   (axi4s_vif.ARESET_N ),
    2450                                                 .m_axis_mm2s_tready    (),//(axi4l_vif.AWADDR ),
    2451                                                 .m_axis_mm2s_tvalid    (),//(axi4l_vif.AWPROT ),
    2452                                                 .m_axis_mm2s_tuser     (),//(axi4l_vif.AWVALID),
    2453                                                 .m_axis_mm2s_tlast     (),//(axi4l_vif.AWREADY),
    2454                                                 .m_axis_mm2s_tdata     (),//(axi4l_vif.WDATA  ),
    2455                                                 .m_axis_mm2s_tkeep     (),//(axi4l_vif.AWPROT ),
    2456                                                 .m_axis_mm2s_tstrb     (),//(axi4l_vif.AWVALID),
    2457                                                 .m_axis_mm2s_tid       (),//(axi4l_vif.AWREADY),
    2458                                                 .m_axis_mm2s_tdest     (),//(axi4l_vif.WDATA  ),
    2459                                                 //video configuration  
    2460                                                 .vfpconfig_aclk        (axi4l_vif.ACLK   ),
    2461                                                 .vfpconfig_aresetn     (axi4l_vif.ARESETN),
    2462                                                 .vfpconfig_awaddr      (axi4l_vif.AWADDR ),
    2463                                                 .vfpconfig_awprot      (axi4l_vif.AWPROT ),
    2464                                                 .vfpconfig_awvalid     (axi4l_vif.AWVALID),
    2465                                                 .vfpconfig_awready     (axi4l_vif.AWREADY),
    2466                                                 .vfpconfig_wdata       (axi4l_vif.WDATA  ),
    2467                                                 .vfpconfig_wstrb       (axi4l_vif.WSTRB  ),
    2468                                                 .vfpconfig_wvalid      (axi4l_vif.WVALID ),
    2469                                                 .vfpconfig_wready      (axi4l_vif.WREADY ),
    2470                                                 .vfpconfig_bresp       (axi4l_vif.BRESP  ),
    2471                                                 .vfpconfig_bvalid      (axi4l_vif.BVALID ),
    2472                                                 .vfpconfig_bready      (axi4l_vif.BREADY ),
    2473                                                 .vfpconfig_araddr      (axi4l_vif.ARADDR ),
    2474                                                 .vfpconfig_arprot      (axi4l_vif.ARPROT ),
    2475                                                 .vfpconfig_arvalid     (axi4l_vif.ARVALID),
    2476                                                 .vfpconfig_arready     (axi4l_vif.ARREADY),
    2477                                                 .vfpconfig_rdata       (axi4l_vif.RDATA  ),
    2478                                                 .vfpconfig_rresp       (axi4l_vif.RRESP  ),
    2479                                                 .vfpconfig_rvalid      (axi4l_vif.RVALID ),
    2480                                                 .vfpconfig_rready      (axi4l_vif.RREADY ));
    2481                                             endmodule: vfpConfigDut
    2482                                             // MODULE : RGB_COLOR [RGB]
    2483                                             module rgb_color(rgb_if.slave_mp rgb_vif);
    2484                                                 import socTest_pkg::*;
    2485                                                 pixelCord dutModule2Inst (
    2486                                                .clk         (rgb_vif.clk),
    2487                                                .iRed        (rgb_vif.iRed),
    2488                                                .iGreen      (rgb_vif.iGreen),
    2489                                                .iBlue       (rgb_vif.iBlue),
    2490                                                .iValid      (rgb_vif.iValid),
    2491                                                .iPixelEn    (rgb_vif.iPixelEn),
    2492                                                .iEof        (rgb_vif.iEof),
    2493                                                .iX          (rgb_vif.iX),
    2494                                                .iY          (rgb_vif.iY),
    2495                                                .oRed        (rgb_vif.oRed),
    2496                                                .oGreen      (rgb_vif.oGreen),
    2497                                                .oBlue       (rgb_vif.oBlue),
    2498                                                .oValid      (rgb_vif.oValid));
    2499                                             endmodule: rgb_color
    2500                                             //====================================================================================
    2501                                             //------------------------------------------------------------------------------------
    2502                                             //--------------------------------- TOP
    2503                                             //------------------------------------------------------------------------------------
    2504                                             //====================================================================================
    2505                                             module top;
    2506                                                 import uvm_pkg::*;
    2507                                                 import socTest_pkg::*;
    2508                                                 reg ACLK;
    2509                                                 reg ARESETN;
    2510                                                 reg ARESET_N;
    2511                                                 reg clk;
    2512                                                 //INTERFACE
    2513                                                 axi4l_if        axi4l_vif(ACLK,ARESETN);            // AXI_LITE_INTERFACE  
    2514                                                 axi4s_if        axi4s_vif(ACLK,ARESET_N);         // AXI4_STREAM_INTERFACE  
    2515                                                 rgb_if          rgb_vif(clk);                           // RGB_INTERFACE 
    2516                                                 tp_if           tp_vif();                         // TEMPLATE_NTERFACE 
    2517                                                 //MODULE
    2518                                                 adder               template_dut(tp_vif);             // [TEMPLATE]
    2519                                                 vfpConfigDut        vfp_dut(axi4l_vif,axi4s_vif,tp_vif); // [AXI4_LITE]
    2520                                                 rgb_color           rgb_dut(rgb_vif);                       // [RGB]
    2521                                                 initial begin
    2522            1                          1             ARESETN  = 1'b0;
    2523            1                          1             ARESET_N = 1'b0;
    2524            1                          1         #1000;
    2525            1                          1             ARESETN  = 1'b1;
    2526            1                          1             ARESET_N = 1'b1;
    2527                                                 end
    2528                                                 initial begin
    2529            1                          1             ACLK = 0;
    2530            1                          1         #5ns ;
    2531            1                          1         forever #5ns ACLK = ! ACLK;
    2531            2                       2262     
    2531            3                       2261     
    2532                                                 end
    2533                                                 initial begin
    2534            1                          1             tp_vif.sig_clock = 0;
    2535            1                          1         #5ns ;
    2536            1                          1         forever #5ns tp_vif.sig_clock = ! tp_vif.sig_clock;
    2536            2                       2262     
    2536            3                       2261     
    2537                                                 end
    2538                                                 initial begin
    2539            1                          1             clk = 0;
    2540            1                          1             #5ns ;
    2541            1                          1             forever #5ns clk = ! clk;
    2541            2                       2262     
    2541            3                       2261     
    2542                                                 end
    2543                                                 initial begin
    2544            1                          1             uvm_config_db   #(virtual axi4l_if) ::set(null, "*", "axi4l_vif", axi4l_vif);
    2545            1                          1             uvm_resource_db #(virtual tp_if)    ::set(.scope("ifs"), .name("tp_if"), .val(tp_vif));
    2546            1                          1             uvm_resource_db #(virtual rgb_if)   ::set(.scope("ifs"),.name("rgb_if"),.val(rgb_vif));
    2547            1                          1             uvm_config_db   #(virtual axi4s_if) ::set(.cntxt(null),.inst_name("uvm_test_top"),.field_name("axi4s_vif"),.value(axi4s_vif));
    2548            1                          1             run_test();
    2549                                                 end
    2550                                             endmodule: top
    2551                                             //====================================================================================
    2552                                             //------------------------------------------------------------------------------------
    2553                                             //---------------------------------
    2554                                             //------------------------------------------------------------------------------------
    2555                                             //====================================================================================

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         2         2         0     100.0

================================Branch Details================================

Branch Coverage for file ../modules/top.sv --

------------------------------------IF Branch------------------------------------
    2379                                     100     Count coming in to IF
    2379            1                         99     		if(ARESET_N == 0)
                                               1     All False Count
Branch totals: 2 hits of 2 branches = 100.0%


Condition Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Condition Terms              0         0         0     100.0
Expression Coverage:
    Enabled Coverage            Active   Covered    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FEC Expression Terms             0         0         0     100.0
FSM Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    FSMs                                                       100.0
        States                       0         0         0     100.0
        Transitions                  0         0         0     100.0

COVERGROUP COVERAGE:
-----------------------------------------------------------------------------------------------
Covergroup                                             Metric       Goal    Status               
                                                                                              
-----------------------------------------------------------------------------------------------
 TYPE /top/axi4s_vif/axi4_cg                            35.8%        100    Uncovered            
    covered/total bins:                                    28        544                      
    missing/total bins:                                   516        544                      
    % Hit:                                               5.1%        100                      
    type_option.weight=1
    type_option.goal=100
    type_option.comment=
    type_option.strobe=0
    type_option.merge_instances=auto(0)
    Coverpoint axi4_cg::T_VALID                        100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::T_READY                         50.0%        100    Uncovered            
        covered/total bins:                                 1          2                      
        missing/total bins:                                 1          2                      
        % Hit:                                          50.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::CONSECUTIVE_TRANSACTIONS         0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_WAITING              5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSACTION_PAUSE                0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::READY_WITHOUT_VALID             51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Coverpoint axi4_cg::TRANSITIONS                     28.5%        100    Uncovered            
        covered/total bins:                                 4         14                      
        missing/total bins:                                10         14                      
        % Hit:                                          28.5%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
    Cross axi4_cg::CASES_VALID_READY                    50.0%        100    Uncovered            
        covered/total bins:                                 2          4                      
        missing/total bins:                                 2          4                      
        % Hit:                                          50.0%        100                      
        type_option.weight=1
        type_option.goal=100
        type_option.comment=
 Covergroup instance \/top/axi4s_vif/axi4               35.8%        100    Uncovered            
    covered/total bins:                                    28        544                      
    missing/total bins:                                   516        544                      
    % Hit:                                               5.1%        100                      
    option.name=\/top/axi4s_vif/axi4 
    option.weight=1
    option.goal=100
    option.comment=
    option.at_least=1
    option.auto_bin_max=64
    option.cross_num_print_missing=0
    option.detect_overlap=0
    option.per_instance=1
    option.get_inst_coverage=0
    Coverpoint T_VALID                                 100.0%        100    Covered              
        covered/total bins:                                 2          2                      
        missing/total bins:                                 0          2                      
        % Hit:                                         100.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                      1031          1    Covered              
        bin auto[1]                                       100          1    Covered              
    Coverpoint T_READY                                  50.0%        100    Uncovered            
        covered/total bins:                                 1          2                      
        missing/total bins:                                 1          2                      
        % Hit:                                          50.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin auto[0]                                         0          1    ZERO                 
        bin auto[1]                                      1030          1    Covered              
    Coverpoint CONSECUTIVE_TRANSACTIONS                  0.4%        100    Uncovered            
        covered/total bins:                                 2        443                      
        missing/total bins:                               441        443                      
        % Hit:                                           0.4%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transactions_single                            89          1    Covered              
        bin transactions_1_5[2=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[2=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*2]=>1]                   5          1    Covered              
        bin transactions_1_5[1=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[1=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*2]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*3]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*4]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*5]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*6]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*7]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*8]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>2]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>1]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*9]=>0]                   0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>2]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>1]                  0          1    ZERO                 
        bin transactions_1_5[0=>3[*10]=>0]                  0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[2=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[1=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*11]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*12]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*13]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*14]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*15]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*16]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*17]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*18]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*19]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*20]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*21]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*22]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*23]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*24]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*25]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*26]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*27]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*28]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*29]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*30]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*31]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*32]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*33]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*34]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*35]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*36]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*37]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*38]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*39]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*40]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*41]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*42]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*43]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*44]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*45]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*46]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*47]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*48]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*49]=>0]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>2]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>1]                0          1    ZERO                 
        bin transactions_11_50[0=>3[*50]=>0]                0          1    ZERO                 
        bin transactions_huge                               0          1    ZERO                 
    Coverpoint TRANSACTION_WAITING                       5.8%        100    Uncovered            
        covered/total bins:                                 1         17                      
        missing/total bins:                                16         17                      
        % Hit:                                           5.8%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        illegal_bin illegal                                 0               ZERO                 
        bin zero_waiting_time                              95          1    Covered              
        bin low_waiting_time[2[*1]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*2]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*3]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*4]=>3]                      0          1    ZERO                 
        bin low_waiting_time[2[*5]=>3]                      0          1    ZERO                 
        bin medium_waiting_time[2[*6]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*7]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*8]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*9]=>3]                   0          1    ZERO                 
        bin medium_waiting_time[2[*10]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*11]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*12]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*13]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*14]=>3]                  0          1    ZERO                 
        bin medium_waiting_time[2[*15]=>3]                  0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint TRANSACTION_PAUSE                         0.0%        100    ZERO                 
        covered/total bins:                                 0         31                      
        missing/total bins:                                31         31                      
        % Hit:                                           0.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin low_waiting_time[3=>0[*1]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*1]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*2]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*3]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*4]=>2]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>3]                   0          1    ZERO                 
        bin low_waiting_time[3=>0[*5]=>2]                   0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*6]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*7]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*8]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>3]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*9]=>2]                0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*10]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*11]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*12]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*13]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*14]=>2]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>3]               0          1    ZERO                 
        bin medium_waiting_time[3=>0[*15]=>2]               0          1    ZERO                 
        bin high_waiting_time                               0          1    ZERO                 
    Coverpoint READY_WITHOUT_VALID                      51.6%        100    Uncovered            
        covered/total bins:                                16         31                      
        missing/total bins:                                15         31                      
        % Hit:                                          51.6%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin short_ready_time[1[*1]=>3]                     95          1    Covered              
        bin short_ready_time[1[*1]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*2]=>3]                     92          1    Covered              
        bin short_ready_time[1[*2]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*3]=>3]                     87          1    Covered              
        bin short_ready_time[1[*3]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*4]=>3]                     80          1    Covered              
        bin short_ready_time[1[*4]=>0]                      0          1    ZERO                 
        bin short_ready_time[1[*5]=>3]                     76          1    Covered              
        bin short_ready_time[1[*5]=>0]                      0          1    ZERO                 
        bin medium_ready_time[1[*6]=>3]                    72          1    Covered              
        bin medium_ready_time[1[*6]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*7]=>3]                    66          1    Covered              
        bin medium_ready_time[1[*7]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*8]=>3]                    61          1    Covered              
        bin medium_ready_time[1[*8]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*9]=>3]                    55          1    Covered              
        bin medium_ready_time[1[*9]=>0]                     0          1    ZERO                 
        bin medium_ready_time[1[*10]=>3]                   52          1    Covered              
        bin medium_ready_time[1[*10]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*11]=>3]                   46          1    Covered              
        bin medium_ready_time[1[*11]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*12]=>3]                   38          1    Covered              
        bin medium_ready_time[1[*12]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*13]=>3]                   32          1    Covered              
        bin medium_ready_time[1[*13]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*14]=>3]                   24          1    Covered              
        bin medium_ready_time[1[*14]=>0]                    0          1    ZERO                 
        bin medium_ready_time[1[*15]=>3]                   18          1    Covered              
        bin medium_ready_time[1[*15]=>0]                    0          1    ZERO                 
        bin high_ready_time                                14          1    Covered              
    Coverpoint TRANSITIONS                              28.5%        100    Uncovered            
        covered/total bins:                                 4         14                      
        missing/total bins:                                10         14                      
        % Hit:                                          28.5%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.auto_bin_max=64
        option.detect_overlap=0
        bin transition[3=>3]                                5          1    Covered              
        bin transition[3=>2]                                0          1    ZERO                 
        bin transition[3=>1]                               94          1    Covered              
        bin transition[3=>0]                                0          1    ZERO                 
        bin transition[1=>3]                               95          1    Covered              
        bin transition[1=>2]                                0          1    ZERO                 
        bin transition[1=>1]                              835          1    Covered              
        bin transition[1=>0]                                0          1    ZERO                 
        bin transition[0=>3]                                0          1    ZERO                 
        bin transition[0=>2]                                0          1    ZERO                 
        bin transition[0=>1]                                0          1    ZERO                 
        bin transition[0=>0]                                0          1    ZERO                 
        bin transition[2=>3]                                0          1    ZERO                 
        bin transition[2=>2]                                0          1    ZERO                 
    Cross CASES_VALID_READY                             50.0%        100    Uncovered            
        covered/total bins:                                 2          4                      
        missing/total bins:                                 2          4                      
        % Hit:                                          50.0%        100                      
        option.weight=1
        option.goal=100
        option.comment=
        option.at_least=1
        option.cross_num_print_missing=0
        bin <auto[0],auto[1]>                             930          1    Covered              
        bin <auto[1],auto[1]>                             100          1    Covered              
        bin <auto[0],auto[0]>                               0          1    ZERO                 
        bin <auto[1],auto[0]>                               0          1    ZERO                 

TOTAL COVERGROUP COVERAGE: 35.8%  COVERGROUP TYPES: 1

ASSERTION RESULTS:
-------------------------------------------------------
Name                 File(Line)           Failure Pass 
                                          Count   Count 
-------------------------------------------------------
/top/axi4s_vif/chk_valid_hold
                     ../modules/top.sv(2355)       0     0
/top/axi4s_vif/chk_data_hold
                     ../modules/top.sv(2402)       0     0
/top/axi4s_vif/chk_user_hold
                     ../modules/top.sv(2403)       0     0
/socTest_pkg/axi4_stream_master_sequence/body/#ublk#215236535#773/immed__776
                     ../modules/top.sv(776)       0     1
/socTest_pkg/axi4_stream_test/run_phase/immed__2193
                     ../modules/top.sv(2193)       0     1

Total Coverage By File (code coverage only, filtered view): 19.4%

